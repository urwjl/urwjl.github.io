<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/312127.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/312127.svg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="RISC-V IOMMU spec 的翻译，基于V1.0版本">
<meta property="og:type" content="article">
<meta property="og:title" content="RISC-V IOMMU 架构规范">
<meta property="og:url" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/index.html">
<meta property="og:site_name" content="WJL">
<meta property="og:description" content="RISC-V IOMMU spec 的翻译，基于V1.0版本">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808100526056-1730797861484-1.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808101406825-1730797861485-3.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808101631677-1730797861485-5.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808102108573-1730797861485-7.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808102225275-1730797861485-9.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808103533694-1730797861485-11.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808104925656-1730797861485-13.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808105003664-1730797861485-15.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808105102573-1730797861485-17.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808105146471-1730797861485-19.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808105614645-1730797861485-21.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808105702072-1730797861485-25.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808105727608-1730797861485-23.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808110051118-1730797861485-27.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808110856889-1730797861485-29.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808135937149-1730797861485-31.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808140100389-1730797861485-33.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808140627848-1730797861485-35.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808141606246-1730797861485-37.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808142211835-1730797861485-39.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808142244388-1730797861485-41.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808144243491-1730797861485-45.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808144314424-1730797861485-43.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808144402797-1730797861485-51.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808144517205-1730797861485-47.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808144611178-1730797861485-49.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808162821338-1730797861485-55.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808163130662-1730797861485-53.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808164528522-1730797861485-57.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808170133023-1730797861485-59.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808170506800-1730797861485-61.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808171138932-1730797861485-63.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808171536592-1730797861485-67.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808171557302-1730797861485-65.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808171717824-1730797861485-69.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808181912574-1730797861485-71.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808181951178-1730797861485-73.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810092542280-1730797861485-75.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810095452159-1730797861485-77.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810100136084-1730797861485-79.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810102950921-1730797861485-81.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810103454277-1730797861485-83.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810103620004-1730797861485-85.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810103710738-1730797861485-87.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810103957689-1730797861485-89.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810104044100-1730797861485-91.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810104141756-1730797861485-93.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810104538319-1730797861486-97.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810104642099-1730797861485-95.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810104747844-1730797861486-99.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810111531824-1730797861486-101.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810112737105-1730797861486-103.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810114211456-1730797861486-105.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810114833875-1730797861486-107.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810133156252-1730797861486-109.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810133334134-1730797861486-111.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810133536491-1730797861486-113.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810133642271-1730797861486-117.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810141126482-1730797861486-115.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810141313111-1730797861486-119.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810142124127-1730797861486-121.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810143715581-1730797861486-123.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810145214359-1730797861486-125.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810145359660-1730797861486-127.png">
<meta property="og:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810145641174-1730797861486-129.png">
<meta property="article:published_time" content="2023-12-06T05:52:39.000Z">
<meta property="article:modified_time" content="2024-11-15T03:24:28.122Z">
<meta property="article:author" content="Wu JInlin">
<meta property="article:tag" content="RISC-V">
<meta property="article:tag" content="IOMMU">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808100526056-1730797861484-1.png">


<link rel="canonical" href="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/","path":"2023/12/06/RISC-V_IOMMU_架构规范/","title":"RISC-V IOMMU 架构规范"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>RISC-V IOMMU 架构规范 | WJL</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">WJL</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Fighting forgetfulness</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RISC-V-IOMMU-%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83"><span class="nav-text">RISC-V IOMMU 架构规范</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AE%80%E4%BB%8B"><span class="nav-text">第一章简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E8%AF%8D%E6%B1%87%E8%A1%A8"><span class="nav-text">1.1.词汇表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="nav-text">1.2.使用模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E9%9D%9E%E8%99%9A%E6%8B%9F%E5%8C%96%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">1.2.1.非虚拟化操作系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-Hypervisor"><span class="nav-text">1.2.2.Hypervisor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-Guest-OS"><span class="nav-text">1.2.3.Guest OS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%B8%83%E5%B1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-text">1.3.布局和数据流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-IOMMU%E7%89%B9%E6%80%A7"><span class="nav-text">1.4. IOMMU特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-2-%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">第 2 章 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E8%AE%BE%E5%A4%87%E7%9B%AE%E5%BD%95%E8%A1%A8-DDT"><span class="nav-text">2.1.设备目录表 (DDT)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E9%9D%9E%E5%8F%B6-DDT-%E6%9D%A1%E7%9B%AE"><span class="nav-text">2.1.1.非叶 DDT 条目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E5%8F%B6-DDT-%E6%9D%A1%E7%9B%AE"><span class="nav-text">2.1.2.叶 DDT 条目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-%E8%AE%BE%E5%A4%87%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AD%97%E6%AE%B5"><span class="nav-text">2.1.3.设备上下文字段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%8E%A7%E5%88%B6-tc"><span class="nav-text">转换控制 (tc)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO-%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8FGuest%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BF%9D%E6%8A%A4-iohgatp"><span class="nav-text">IO 管理程序Guest地址转换和保护 (iohgatp)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BF%BB%E8%AF%91%E5%B1%9E%E6%80%A7-ta"><span class="nav-text">翻译属性 (ta)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E4%B8%8A%E4%B8%8B%E6%96%87-fsc"><span class="nav-text">第一阶段上下文 (fsc)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MSI-%E9%A1%B5%E8%A1%A8%E6%8C%87%E9%92%88-msiptp"><span class="nav-text">MSI 页表指针 (msiptp)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MSI-%E5%9C%B0%E5%9D%80%E6%8E%A9%E7%A0%81-msi-addr-mask-%E5%92%8C%E6%A8%A1%E5%BC%8F-msi-addr-pattern"><span class="nav-text">MSI 地址掩码 (msi_addr_mask) 和模式 (msi_addr_pattern)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-%E8%AE%BE%E5%A4%87%E4%B8%8A%E4%B8%8B%E6%96%87%E9%85%8D%E7%BD%AE%E6%A3%80%E6%9F%A5"><span class="nav-text">2.1.4.设备上下文配置检查</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E8%BF%9B%E7%A8%8B%E7%9B%AE%E5%BD%95%E8%A1%A8-PDT"><span class="nav-text">2.2.进程目录表 (PDT)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E9%9D%9E%E5%8F%B6-PDT-%E6%9D%A1%E7%9B%AE"><span class="nav-text">2.2.1.非叶 PDT 条目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E5%8F%B6-PDT-%E6%9D%A1%E7%9B%AE"><span class="nav-text">2.2.2.叶 PDT 条目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-%E6%B5%81%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AD%97%E6%AE%B5"><span class="nav-text">2.2.3.流程上下文字段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BF%BB%E8%AF%91%E5%B1%9E%E6%80%A7-ta-1"><span class="nav-text">翻译属性 (ta)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E4%B8%8A%E4%B8%8B%E6%96%87-fsc-1"><span class="nav-text">第一阶段上下文 (fsc)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E9%85%8D%E7%BD%AE%E6%A3%80%E6%9F%A5"><span class="nav-text">2.2.4.进程上下文配置检查</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E7%BF%BB%E8%AF%91-IOVA-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-text">2.3. 翻译 IOVA 的流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-%E5%AE%9A%E4%BD%8D%E8%AE%BE%E5%A4%87%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">2.3.1.定位设备上下文的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-%E6%9F%A5%E6%89%BE%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="nav-text">2.3.2.查找进程上下文的进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-%E8%BD%AC%E6%8D%A2-MSI-%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">2.3.3.转换 MSI 地址的过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-IOMMU-%E6%9B%B4%E6%96%B0-PTE-%E8%AE%BF%E9%97%AE%E7%9A%84-A-%E5%92%8C%E8%84%8F%E7%9A%84-D-%E6%9B%B4%E6%96%B0"><span class="nav-text">2.4. IOMMU 更新 PTE 访问的 (A) 和脏的 (D) 更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-text">2.5. 虚拟地址转换过程中的错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-PCIe-ATS-%E8%BD%AC%E6%8D%A2%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="nav-text">2.6. PCIe ATS 转换请求处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-PCIe-ATS-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="nav-text">2.7. PCIe ATS 页面请求处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-%E7%BC%93%E5%AD%98%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">2.8.缓存内存中的数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-%E6%9B%B4%E6%96%B0%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%A1%E7%9B%AE"><span class="nav-text">2.9.更新内存数据结构条目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-10-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F"><span class="nav-text">2.10.内存数据结构的字节顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-3-%E7%AB%A0-%E5%86%85%E5%AD%98%E9%98%9F%E5%88%97%E6%8E%A5%E5%8F%A3"><span class="nav-text">第 3 章 内存队列接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%91%BD%E4%BB%A4%E9%98%9F%E5%88%97-CQ"><span class="nav-text">3.1.命令队列 (CQ)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-IOMMU-%E9%A1%B5%E8%A1%A8%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E5%91%BD%E4%BB%A4"><span class="nav-text">3.1.1. IOMMU 页表缓存失效命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-IOMMU-%E5%91%BD%E4%BB%A4%E9%98%9F%E5%88%97-Fence-%E5%91%BD%E4%BB%A4"><span class="nav-text">3.1.2. IOMMU 命令队列 Fence 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-IOMMU-%E7%9B%AE%E5%BD%95%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E5%91%BD%E4%BB%A4"><span class="nav-text">3.1.3. IOMMU 目录缓存失效命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-IOMMU-PCIe-ATS-%E5%91%BD%E4%BB%A4"><span class="nav-text">3.1.4. IOMMU PCIe ATS 命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%95%85%E9%9A%9C-%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97-FQ"><span class="nav-text">3.2.故障&#x2F;事件队列 (FQ)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97-PQ"><span class="nav-text">3.3.页面请求队列 (PQ)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-4-%E7%AB%A0-%E8%B0%83%E8%AF%95%E6%94%AF%E6%8C%81"><span class="nav-text">第 4 章 调试支持</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-5-%E7%AB%A0-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%AF%84%E5%AD%98%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-text">第 5 章 内存映射寄存器接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E5%AF%84%E5%AD%98%E5%99%A8%E5%B8%83%E5%B1%80"><span class="nav-text">5.1.寄存器布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E9%87%8D%E7%BD%AE%E8%A1%8C%E4%B8%BA"><span class="nav-text">5.2.重置行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-IOMMU%E8%83%BD%E5%8A%9B%EF%BC%88capabilities%EF%BC%89"><span class="nav-text">5.3. IOMMU能力（capabilities）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E5%8A%9F%E8%83%BD%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8-fctl"><span class="nav-text">5.4.功能控制寄存器 (fctl)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E8%AE%BE%E5%A4%87%E7%9B%AE%E5%BD%95%E8%A1%A8%E6%8C%87%E9%92%88-ddtp"><span class="nav-text">5.5.设备目录表指针 (ddtp)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-%E5%91%BD%E4%BB%A4%E9%98%9F%E5%88%97%E5%BA%93-cqb"><span class="nav-text">5.6.命令队列库 (cqb)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-%E5%91%BD%E4%BB%A4%E9%98%9F%E5%88%97%E5%A4%B4-cqh"><span class="nav-text">5.7.命令队列头 (cqh)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-%E5%91%BD%E4%BB%A4%E9%98%9F%E5%88%97%E5%B0%BE%E9%83%A8-cqt"><span class="nav-text">5.8.命令队列尾部 (cqt)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-9-%E6%95%85%E9%9A%9C%E9%98%9F%E5%88%97%E5%BA%93-fqb"><span class="nav-text">5.9.故障队列库 (fqb)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-10-%E6%95%85%E9%9A%9C%E9%98%9F%E5%88%97%E5%A4%B4-fqh"><span class="nav-text">5.10.故障队列头 (fqh)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-11-%E6%95%85%E9%9A%9C%E9%98%9F%E5%88%97%E5%B0%BE%E9%83%A8-fqt"><span class="nav-text">5.11.故障队列尾部 (fqt)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-12-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80-pqb"><span class="nav-text">5.12.页面请求队列基础 (pqb)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-13-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97%E5%A4%B4-pqh"><span class="nav-text">5.13.页面请求队列头 (pqh)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-14-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97%E5%B0%BE%E9%83%A8-pqt"><span class="nav-text">5.14.页面请求队列尾部 (pqt)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-15-%E5%91%BD%E4%BB%A4%E9%98%9F%E5%88%97-CSR-cqcsr"><span class="nav-text">5.15.命令队列 CSR (cqcsr)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-16-%E6%95%85%E9%9A%9C%E9%98%9F%E5%88%97-CSR-fqcsr"><span class="nav-text">5.16.故障队列 CSR (fqcsr)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-17-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97-CSR-pqcsr"><span class="nav-text">5.17.页面请求队列 CSR (pqcsr)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-18-%E4%B8%AD%E6%96%AD%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8-ipsr"><span class="nav-text">5.18.中断挂起状态寄存器 (ipsr)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-19-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E8%AE%A1%E6%95%B0%E5%99%A8%E6%BA%A2%E5%87%BA%E7%8A%B6%E6%80%81-iocountovf"><span class="nav-text">5.19.性能监控计数器溢出状态 (iocountovf)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-20-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E8%AE%A1%E6%95%B0%E5%99%A8%E7%A6%81%E6%AD%A2-iocountinh"><span class="nav-text">5.20.性能监控计数器禁止 (iocountinh)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-21-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%91%A8%E6%9C%9F%E8%AE%A1%E6%95%B0%E5%99%A8-iohpmcycles"><span class="nav-text">5.21.性能监控周期计数器 (iohpmcycles)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-22-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%BA%8B%E4%BB%B6%E8%AE%A1%E6%95%B0%E5%99%A8-iohpmctr1-31"><span class="nav-text">5.22.性能监控事件计数器 (iohpmctr1-31)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-23-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%BA%8B%E4%BB%B6%E9%80%89%E6%8B%A9%E5%99%A8-iohpmevt1-31"><span class="nav-text">5.23.性能监控事件选择器 (iohpmevt1-31)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-24-%E7%BF%BB%E8%AF%91%E8%AF%B7%E6%B1%82-IOVA-tr-req-iova"><span class="nav-text">5.24.翻译请求 IOVA (tr_req_iova)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-25-%E7%BF%BB%E8%AF%91%E8%AF%B7%E6%B1%82%E6%8E%A7%E5%88%B6-tr-req-ctl"><span class="nav-text">5.25.翻译请求控制 (tr_req_ctl)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-26-%E7%BF%BB%E8%AF%91%E5%93%8D%E5%BA%94-tr-response"><span class="nav-text">5.26.翻译响应 (tr_response)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-27-%E4%B8%AD%E6%96%AD%E5%8E%9F%E5%9B%A0%E5%88%B0%E5%90%91%E9%87%8F%E5%AF%84%E5%AD%98%E5%99%A8-icvec"><span class="nav-text">5.27.中断原因到向量寄存器 (icvec)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-28-MSI-%E9%85%8D%E7%BD%AE%E8%A1%A8-msi-cfg-tbl"><span class="nav-text">5.28. MSI 配置表 (msi_cfg_tbl)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-6-%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E6%8C%87%E5%8D%97"><span class="nav-text">第 6 章 软件指南</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E8%AF%BB%E5%86%99IOMMU%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">6.1.读写IOMMU寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8C%87%E5%8D%97"><span class="nav-text">6.2.初始化指南</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E6%97%A0%E6%95%88%E6%8C%87%E5%8D%97"><span class="nav-text">6.3.无效指南</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-%E6%9B%B4%E6%94%B9%E8%AE%BE%E5%A4%87%E7%9B%AE%E5%BD%95%E8%A1%A8%E6%9D%A1%E7%9B%AE"><span class="nav-text">6.3.1.更改设备目录表条目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-%E6%9B%B4%E6%94%B9%E8%BF%9B%E7%A8%8B%E7%9B%AE%E5%BD%95%E8%A1%A8%E6%9D%A1%E7%9B%AE"><span class="nav-text">6.3.2.更改进程目录表条目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-3-%E6%9B%B4%E6%94%B9-MSI-%E9%A1%B5%E8%A1%A8%E6%9D%A1%E7%9B%AE"><span class="nav-text">6.3.3.更改 MSI 页表条目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-4-%E6%9B%B4%E6%94%B9%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A1%B5%E8%A1%A8%E9%A1%B9"><span class="nav-text">6.3.4.更改第二阶段页表项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-5-%E6%9B%B4%E6%94%B9%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E9%A1%B5%E8%A1%A8%E9%A1%B9"><span class="nav-text">6.3.5.更改第一阶段页表项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-6-%E5%B7%B2%E8%AE%BF%E9%97%AE-A-%E8%84%8F-D-%E4%BD%8D%E6%9B%B4%E6%96%B0%E5%92%8C%E9%A1%B5%E9%9D%A2%E5%8D%87%E7%BA%A7"><span class="nav-text">6.3.6.已访问 (A)&#x2F;脏 (D) 位更新和页面升级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-7-%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88"><span class="nav-text">6.3.7.设备地址转换缓存失效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-8-%E7%BC%93%E5%AD%98%E6%97%A0%E6%95%88%E6%9D%A1%E7%9B%AE"><span class="nav-text">6.3.8.缓存无效条目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AE-PMA"><span class="nav-text">6.4.重新配置 PMA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-%E5%A4%84%E7%90%86-IOMMU-%E4%B8%AD%E6%96%AD%E7%9A%84%E6%8C%87%E5%8D%97"><span class="nav-text">6.5.处理 IOMMU 中断的指南</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-%E5%90%AF%E7%94%A8%E5%92%8C%E7%A6%81%E7%94%A8-ATS-%E5%92%8C-%E6%88%96-PRI-%E7%9A%84%E6%8C%87%E5%8D%97"><span class="nav-text">6.6.启用和禁用 ATS 和&#x2F;或 PRI 的指南</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-7-%E7%AB%A0-%E7%A1%AC%E4%BB%B6%E6%8C%87%E5%8D%97"><span class="nav-text">第 7 章  硬件指南</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E5%B0%86-IOMMU-%E9%9B%86%E6%88%90%E4%B8%BA-PCIe-%E8%AE%BE%E5%A4%87"><span class="nav-text">7.1.将 IOMMU 集成为 PCIe 设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-PMA-%E5%92%8C-PMP-%E7%9A%84%E6%95%85%E9%9A%9C"><span class="nav-text">7.2. PMA 和 PMP 的故障</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E4%B8%AD%E6%AD%A2%E5%A4%84%E7%90%86"><span class="nav-text">7.3.中止处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7-RAS"><span class="nav-text">7.4.可靠性、可用性和可维护性 (RAS)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E4%B9%A6%E7%9B%AE"><span class="nav-text">参考书目</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wu JInlin"
      src="/images/20241114140630.jpg">
  <p class="site-author-name" itemprop="name">Wu JInlin</p>
  <div class="site-description" itemprop="description">个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/20241114140630.jpg">
      <meta itemprop="name" content="Wu JInlin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WJL">
      <meta itemprop="description" content="个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="RISC-V IOMMU 架构规范 | WJL">
      <meta itemprop="description" content="RISC-V IOMMU spec 的翻译，基于V1.0版本">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RISC-V IOMMU 架构规范
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-06 13:52:39" itemprop="dateCreated datePublished" datetime="2023-12-06T13:52:39+08:00">2023-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-15 11:24:28" itemprop="dateModified" datetime="2024-11-15T11:24:28+08:00">2024-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/RISC-V/" itemprop="url" rel="index"><span itemprop="name">RISC-V</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/RISC-V/IOMMU/" itemprop="url" rel="index"><span itemprop="name">IOMMU</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">RISC-V IOMMU spec 的翻译，基于V1.0版本</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="RISC-V-IOMMU-架构规范"><a href="#RISC-V-IOMMU-架构规范" class="headerlink" title="RISC-V IOMMU 架构规范"></a>RISC-V IOMMU 架构规范</h1><p>Version 1.0, 06&#x2F;2023:</p>
<h1 id="第一章简介"><a href="#第一章简介" class="headerlink" title="第一章简介"></a>第一章简介</h1><p>输入输出内存管理单元 (IOMMU)，有时称为系统 MMU (SMMU)，是一种系统级内存管理单元 (MMU)，它将可直接内存访问的输入&#x2F;输出 (I&#x2F;O) 设备连接到系统内存。</p>
<p>对于通过 IOMMU 连接到系统的每个 I&#x2F;O 设备，软件可以在 IOMMU 处配置设备上下文，该设备上下文与设备的特定虚拟地址空间和其他每设备参数相关联。通过在 IOMMU 中为每个设备提供其自己的单独设备上下文，每个设备都可以针对单独的操作系统进行单独配置，该操作系统可以是Guest OS或主（主机）操作系统。在设备发起的每次内存访问中，IOMMU 通过某种形式的唯一设备标识符来识别原始设备，然后 IOMMU 使用该标识符在软件提供的数据结构中定位适当的设备上下文。</p>
<blockquote>
<p>例如，对于 PCIe [1]，始发(originating)设备可以通过唯一的 16 位三元组 PCI 总线号（8 位）、设备号（5 位）和功能号（3 位）（统称为当 IOMMU 支持多个层次结构时，路由标识符或 RID）以及可选的最多 8 位段号。</p>
</blockquote>
<p>该规范将这种<strong>唯一设备标识符称为<code>device_id</code><strong>，并支持</strong>最多24位宽</strong>的标识符。</p>
<blockquote>
<p>层次结构是 PCI Express I&#x2F;O 互连拓扑，其中配置空间地址（称为总线&#x2F;设备&#x2F;功能编号的元组）是唯一的。在某些上下文中，层次结构也称为段(Segment)，在 Flit 模式中，段编号有时包含在函数的 ID 中。</p>
</blockquote>
<p>某些设备可能支持<strong>共享虚拟寻址</strong>，即与<strong>设备共享进程地址空间</strong>的能力。与设备共享进程地址空间允许依赖核心内核内存管理进行 DMA，从而消除应用程序和设备驱动程序的一些复杂性。</p>
<p>绑定到设备后，应用程序可以指示它在静态或动态分配的缓冲区上执行 DMA。为了支持这种寻址，软件可以将一个或多个<strong>进程上下文</strong>配置到设备上下文中。由这样的设备发起的每个存储器访问都伴随着唯一的<strong>进程标识符</strong>，IOMMU将其与唯一的设备标识符结合使用来定位由设备上下文中的软件配置的适当的进程上下文。例如，对于 PCIe，进程上下文可以通过唯一的 20 位<strong>进程地址空间标识符</strong> (PASID) 来标识。该规范引用了诸如 process_id 之类的唯一进程标识符，并支持最多 20 位宽的标识符。</p>
<p><strong>IOMMU 采用两阶段地址转换过程将 IOVA 转换为 SPA 并强制执行 DMA 的内存保护</strong>。为了执行地址转换和内存保护，IOMMU 使用与 CPU 的 MMU 用于第一阶段和第二阶段地址转换相同的页表格式。使用与 CPU 的 MMU 相同的页表格式可以消除 DMA 的一些内存管理复杂性。使用相同的格式还允许 CPU MMU 和 IOMMU 同时使用相同的页表。</p>
<p>尽管没有禁用两阶段地址转换的选项，但通过将该阶段的虚拟内存方案配置为 Bare，即不执行地址转换或内存保护，可以有效地禁用任一阶段。</p>
<p>IOMMU所采用的虚拟存储器方案可以针对IOMMU中的每个设备单独配置。设备使用 I&#x2F;O 虚拟地址 (IOVA) 执行 DMA。根据为设备选择的虚拟内存方案，设备使用的 IOVA 可以是管理程序物理地址 (SPA)、Guest physical addresses (GPA) 或虚拟地址 (VA)。</p>
<p>如果为两个阶段选择的虚拟内存方案都是 Bare，则 IOVA 是 SPA。 IOMMU 不执行地址转换或保护。</p>
<p>如果第一阶段选择的虚拟内存方案是 Bare，但第二阶段的方案不是 Bare，则 IOVA 是 GPA。第一阶段被有效禁用。第二阶段将 GPA 转换为 SPA 并强制执行配置的内存保护。当设备控制传递到虚拟机但 VM 中的Guest OS不使用第一阶段地址转换来进一步限制来自此类设备的内存访问时，通常会采用这种配置。与 RISC-V hart 相比，此配置类似于 RISC-V hart 上有效的两级地址转换，其中 G 级处于活动状态，VS 级设置为 Bare。</p>
<p>如果第一阶段选择的虚拟内存方案不是 Bare，但第二阶段选择的虚拟内存方案是 Bare，则 IOVA 是 VA。第二阶段被有效禁用。第一阶段将 VA 转换为 SPA 并强制执行配置的内存保护。当 IOMMU 由本机操作系统使用或当设备的控制由hypervisor本身保留时，通常会采用此配置。与 RISC-V hart 相比，此配置类似于 RISC-V hart 上有效的单级地址转换。</p>
<p>如果为两个阶段选择的虚拟内存方案均不是 Bare，则 IOVA 为 VA。两阶段地址转换生效。第一阶段将 VA 转换为 GPA，第二阶段将 GPA 转换为 SPA。每个阶段都会强制执行已配置的内存保护。当设备控制传递到虚拟机并且VM中的Guest OS使用第一阶段地址转换来进一步限制此类设备访问的存储器以及相关联的特权和存储器保护时，通常会采用这种配置。与 RISC-V hart 相比，此配置类似于在 G 级和 VS 级均处于活动状态（not Bare）的 RISC-V hart 上有效的两级地址转换。</p>
<p>IOMMU 中的 DMA 地址转换对 DMA 访问具有一定的性能影响，因为使用软件提供的数据结构确定 SPA 所需的时间可能会延长访问时间。 CPU MMU 中的类似开销通常通过使用转换后备缓冲区 (TLB) 来缓存这些地址转换来减轻，以便可以重新使用它们来减少后续访问的转换开销。 IOMMU可以采用类似的地址转换高速缓存，称为IOMMU地址转换高速缓存(IOATC)。</p>
<p> <strong>IOMMU 为软件提供了在 IOATC 被修改时将 IOATC 与用于地址转换的内存驻留数据结构同步的机制。</strong></p>
<ul>
<li>软件可以使用称为Guest软上下文标识符（GSCID）的软件定义的上下文标识符来配置设备上下文，以指示设备集合被分配给同一VM并因此访问公共虚拟地址空间。</li>
<li>软件可以使用称为进程软上下文标识符（PSCID）的软件定义的上下文标识符来配置进程上下文，以识别共享公共虚拟地址空间的进程的集合。</li>
</ul>
<p> IOMMU可以使用GSCID和PSCID来标记IOATC中的条目以避免重复并简化无效操作。</p>
<p>一些设备可以参与转换过程并为其自己的存储器访问提供设备侧ATC（DevATC）。通过提供 DevATC，设备分担翻译缓存责任，从而降低 IOATC 中“颠簸(thrashing)”的可能性。</p>
<p>DevATC 可以由设备调整大小，以满足其独特的性能要求，并且设备还可以使用 DevATC 通过预取转换来优化 DMA 延迟。此类机制需要设备和 IOMMU 使用协议密切合作。例如，对于 PCIe，设备可以使用地址转换服务 (ATS) 协议来请求转换以缓存在 DevATC 中，并将其与软件地址转换数据结构所做的更新同步。参与地址转换过程的设备还启用 I&#x2F;O 页错误的使用，以避免核心内核内存管理器(core kernel memory manager )必须始终驻留设备可能访问的所有物理内存。例如，对于 PCIe，设备可以实现页面请求接口 (PRI)，以便在发现其请求转换的页面不可用时动态地请求内存管理器驻留页面。 IOMMU 可以支持专用软件接口和设备协议，以支持 PCIe ATS 和 PCIe PRI [1] 等服务。</p>
<p>在使用传入消息信号中断控制器 (IMSIC) 构建的系统中，IOMMU 可以由hypervisor进行编程，以将消息信号中断 (MSI) 从由Guest OS控制的设备定向到 IMSIC 中的Guest interrupt file。由于来自设备的 MSI 只是内存写入，因此它们自然会受到 IOMMU 应用于其他内存写入的相同地址转换的影响。然而，RISC-V 高级中断架构 [2] 要求 IOMMU 专门对待针对虚拟机的 MSI，部分是为了简化软件，部分是为了允许对内存驻留中断文件的可选支持。设备上下文由软件配置参数来识别对虚拟中断文件的内存访问，并使用设备上下文中软件配置的 MSI 地址转换表进行转换。</p>
<h2 id="1-1-词汇表"><a href="#1-1-词汇表" class="headerlink" title="1.1.词汇表"></a>1.1.词汇表</h2><p>表 1. 术语和定义</p>
<table>
<thead>
<tr>
<th>Term</th>
<th>Definition</th>
</tr>
</thead>
<tbody><tr>
<td>AIA</td>
<td>RISC-V 先进的中断架构 [2].</td>
</tr>
<tr>
<td>ATS &#x2F; PCIe ATS</td>
<td>地址转换服务：支持 DevATC 的 PCIe 协议 [1]。</td>
</tr>
<tr>
<td>CXL</td>
<td>Compute Express Link 总线标准。</td>
</tr>
<tr>
<td>DC &#x2F; Device Context</td>
<td>状态的硬件表示，用于标识设备以及该设备所分配到的 VM。</td>
</tr>
<tr>
<td>DDT</td>
<td>设备目录表：使用唯一设备标识符遍历的基数树结构以定位设备上下文结构。</td>
</tr>
<tr>
<td>DDI</td>
<td>设备目录索引：唯一设备标识符的子字段，用作叶或非叶 DDT 结构的索引。</td>
</tr>
<tr>
<td>Device ID</td>
<td>最多 24 位的标识号，用于标识 DMA 或中断请求的源。对于 PCIe 设备，这是路由标识符 (RID) [1]。</td>
</tr>
<tr>
<td>DevATC</td>
<td>设备上的地址转换缓存。</td>
</tr>
<tr>
<td>DMA</td>
<td>直接内存访问</td>
</tr>
<tr>
<td>GPA</td>
<td>Guest physical address：虚拟机的虚拟化物理内存空间中的地址。</td>
</tr>
<tr>
<td>GSCID</td>
<td>Guest软上下文标识符：软件使用的标识号，用于唯一标识分配给虚拟机的设备集合。 IOMMU 可以用 GSCID 来标记 IOATC 条目。<br>使用相同 GSCID 编程的设备上下文也必须使用相同的第二阶段页表进行编程。</td>
</tr>
<tr>
<td>Guest</td>
<td>虚拟机中的软件</td>
</tr>
<tr>
<td>HPM</td>
<td>硬件性能监视器</td>
</tr>
<tr>
<td>Hypervisor</td>
<td>控制虚拟化的软件实体。</td>
</tr>
<tr>
<td>ID</td>
<td>Identifier 标识符</td>
</tr>
<tr>
<td>IMSIC</td>
<td>传入消息信号中断控制器。</td>
</tr>
<tr>
<td>IOATC</td>
<td>IOMMU 地址转换缓存：IOMMU 中的缓存，用于缓存用于地址转换的数据结构。</td>
</tr>
<tr>
<td>IOVA</td>
<td>I&#x2F;O 虚拟地址：设备 DMA 的虚拟地址。</td>
</tr>
<tr>
<td>MSI</td>
<td>消息信号中断。</td>
</tr>
<tr>
<td>OS</td>
<td>操作系统。</td>
</tr>
<tr>
<td>PASID</td>
<td>进程地址空间标识符：它标识进程的地址空间。 PASID 值在请求的 PASID TLP 前缀中提供。</td>
</tr>
<tr>
<td>PBMT</td>
<td>基于页的内存类型</td>
</tr>
<tr>
<td>PPN</td>
<td>物理页码。</td>
</tr>
<tr>
<td>PRI</td>
<td>页面请求接口 - 一种 PCIe 协议，使设备能够请求操作系统内存管理器服务以使页面驻留 [1]。</td>
</tr>
<tr>
<td>PC</td>
<td>进程上下文。</td>
</tr>
<tr>
<td>PCIe</td>
<td>外围组件互连 Express 总线标准 [1]。</td>
</tr>
<tr>
<td>PDI</td>
<td>Process-directory-index：唯一进程标识符的子字段，用于索引叶或非叶 PDT 结构。</td>
</tr>
<tr>
<td>PDT</td>
<td>进程目录表：使用唯一进程标识符遍历的基数树数据结构，以定位进程上下文结构。</td>
</tr>
<tr>
<td>PMA</td>
<td>物理内存属性。</td>
</tr>
<tr>
<td>PMP</td>
<td>物理内存保护。</td>
</tr>
<tr>
<td>PPN</td>
<td>物理页码。</td>
</tr>
<tr>
<td>PRI</td>
<td>页面请求接口 - 一种 PCIe 协议 [1]，使设备能够请求操作系统内存管理器服务来驻留页面。</td>
</tr>
<tr>
<td>Process ID</td>
<td>最多 20 位的标识号，用于标识进程上下文。对于 PCIe 设备，这是 PASID [1]。</td>
</tr>
<tr>
<td>PSCID</td>
<td>进程软上下文标识符：软件用来标识唯一地址空间的标识号。 IOMMU可以用PSCID来标记IOATC条目。</td>
</tr>
<tr>
<td>PT</td>
<td>页表。</td>
</tr>
<tr>
<td>PTE</td>
<td>页表条目。页表中的叶或非叶条目。</td>
</tr>
<tr>
<td>Reserved</td>
<td>保留供将来使用的寄存器或数据结构字段。数据结构中的保留字段必须由软件设置为 0。当将值写入同一寄存器中的其他字段时，软件必须忽略寄存器中的保留字段并保留这些字段中保存的值。</td>
</tr>
<tr>
<td>RID &#x2F; PCIe RID</td>
<td>PCIe 路由标识符 [1]。</td>
</tr>
<tr>
<td>RO</td>
<td>只读 - 寄存器位是只读的，不能通过软件更改。在明确定义的情况下，这些位用于反映不断变化的硬件状态，因此可以观察到位值在运行时发生变化。<br><br>如果未实现设置位的可选功能，则这些位必须硬连线为零</td>
</tr>
<tr>
<td>RW</td>
<td>读写 - 寄存器位可以读写，并且允许通过软件将其设置或清除为所需状态。<br><br>如果未实现与位相关的可选功能，则允许将位硬连线为零。</td>
</tr>
<tr>
<td>RW1C</td>
<td>写 1 清除状态 - 寄存器位指示读取时的状态。设置位指示状态事件，通过写入 1b 来清除该状态事件。将 0b 写入 RW1C 位没有任何效果。<br><br>如果未实现设置该位的可选功能，则该位必须是只读的并硬连线为零</td>
</tr>
<tr>
<td>RW1S</td>
<td>读-写-1-设置 - 寄存器位指示读取时的状态。该位可以通过写入 1b 来设置。将 0b 写入 RW1S 位没有任何效果。<br><br>如果未实现引入该位的可选功能，则该位必须是只读的并硬连线为零</td>
</tr>
<tr>
<td>SOC</td>
<td>片上系统</td>
</tr>
<tr>
<td>SPA</td>
<td>Supervisor 物理地址：用于访问内存和内存映射资源的物理地址。</td>
</tr>
<tr>
<td>TLP</td>
<td>事务层数据包。</td>
</tr>
<tr>
<td>VA</td>
<td>虚拟地址</td>
</tr>
<tr>
<td>VM</td>
<td>虚拟机：真实计算机系统的高效、隔离的副本。在本规范中，它指的是当支持hypervisor扩展的 RISC-V 硬件在虚拟化模式设置为 1 的情况下执行时可访问的资源和状态的集合。</td>
</tr>
<tr>
<td>VMM</td>
<td>虚拟机监视器。也称为hypervisor。</td>
</tr>
<tr>
<td>VS</td>
<td>Virtual Supervisor：虚拟化模式下的Supervisor权限</td>
</tr>
<tr>
<td>WARL</td>
<td>写入任何值，读取合法值：寄存器字段的属性，仅为位编码的子集定义，但允许写入任何值，同时保证每次读取时返回合法值。</td>
</tr>
<tr>
<td>WPRI</td>
<td>写入保留值，读取忽略值：保留供将来使用的寄存器字段的属性。</td>
</tr>
</tbody></table>
<h2 id="1-2-使用模型"><a href="#1-2-使用模型" class="headerlink" title="1.2.使用模型"></a>1.2.使用模型</h2><h3 id="1-2-1-非虚拟化操作系统"><a href="#1-2-1-非虚拟化操作系统" class="headerlink" title="1.2.1.非虚拟化操作系统"></a>1.2.1.非虚拟化操作系统</h3><p>非虚拟化操作系统可以使用 IOMMU 来实现以下重要的系统级功能：</p>
<ol>
<li>保护操作系统免受来自错误设备的错误内存访问 </li>
<li>在 64 位环境中支持 32 位设备（避免反弹缓冲区） </li>
<li>支持将连续虚拟地址映射到底层分段物理地址（避免分散&#x2F;收集列表）</li>
<li>支持共享虚拟寻址</li>
</ol>
<p>在没有 IOMMU 的情况下，设备可以访问任何内存（例如特权内存），并导致恶意或意外损坏。这可能是由于硬件错误、设备驱动程序错误或恶意软件&#x2F;硬件造成的。</p>
<p>IOMMU 为操作系统提供了一种机制，通过限制设备可以访问的内存来防止此类意外损坏。如图 1 所示，操作系统可以使用页表配置 IOMMU 以转换 IOVA，从而将可访问的地址限制为页表允许的地址。</p>
<p>旧版 32 位设备无法访问 4 GiB 以上的内存。 IOMMU 通过其地址重新映射功能，为设备提供了一种简单的机制来直接访问系统中的任何地址（具有适当的访问权限）。如果没有 IOMMU，操作系统必须通过分配在 4 GiB 以下内存中的缓冲区（也称为反弹缓冲区）来复制数据。在这种情况下，IOMMU 提高了系统性能。</p>
<p>IOMMU 对于执行分散&#x2F;集中 DMA 非常有用，因为它允许为 I&#x2F;O 分配大块内存区域，而不需要所有内存都是连续的。连续的虚拟地址范围可以映射到这种分段的物理地址以及用该虚拟地址范围编程的设备。</p>
<p>IOMMU 可用于支持共享虚拟寻址，即与设备共享进程地址空间的能力。然后，IOMMU 将用于 DMA 的虚拟地址转换为 SPA。</p>
<p>当IOMMU用于非虚拟化操作系统时，第一阶段足以提供所需的地址转换和保护功能，第二阶段可以设置为Bare。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808100526056-1730797861484-1.png" alt="image-20230808100526056"></p>
<p>图 1. 非虚拟化操作系统中的设备隔离</p>
<h3 id="1-2-2-Hypervisor"><a href="#1-2-2-Hypervisor" class="headerlink" title="1.2.2.Hypervisor"></a>1.2.2.Hypervisor</h3><p>IOMMU 使得在虚拟机中运行的Guest OS能够直接控制 I&#x2F;O 设备，而只需最少的 Hypervisor 干预。</p>
<p>直接控制设备的Guest OS将使用Guest physical address对设备进行编程，因为这是操作系统所知道的全部内容。当设备使用这些地址执行内存访问时，IOMMU 负责将这些 Guest physical addresse s转换为 Supervisor physical addresses，引用 hypervisor 提供的地址转换数据结构。</p>
<p>图 2 说明了这一概念。设备D1直接分配给VM-1，设备D2直接分配给VM-2。 VMM为每个设备配置要使用的第二级页表，并将D1可以访问的内存限制为VM-1关联内存以及D2可以访问VM-2关联内存。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808101406825-1730797861485-3.png" alt="image-20230808101406825"></p>
<p>图 2. DMA 转换以实现直接设备分配</p>
<p>为了处理来自Guest OS控制的设备的 MSI，管理程序配置 IOMMU 以将这些 MSI 重定向到 IMSIC 中的Guest interrupt file（参见图 3）或内存驻留中断文件。 IOMMU 负责使用管理程序提供的 MSI 地址转换数据结构来执行 MSI 重定向。由于每个中断文件（无论是真实的还是虚拟的）都会占用自然对齐的 4 KiB 页地址空间，因此所需的地址转换是从虚拟（Guest）页地址到物理页地址，与常规 RISC-V 页所支持的相同基于地址的转换。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808101631677-1730797861485-5.png" alt="image-20230808101631677"></p>
<p>图 3. 将 MSI 地址转换为直接Guest编程的 MSI 到 IMSIC Guest interrupt file</p>
<h3 id="1-2-3-Guest-OS"><a href="#1-2-3-Guest-OS" class="headerlink" title="1.2.3.Guest OS"></a>1.2.3.Guest OS</h3><p>hypervisor 可以通过硬件仿真或通过启发Guest OS使用与 hypervisor 的软件接口（也称为半虚拟化）来提供虚拟 IOMMU 设施。然后，Guest OS可以使用虚拟IOMMU提供的设施，通过使用其控制的第一阶段页表来获得与针对非虚拟化操作系统所讨论的相同的好处。hypervisor 建立第二阶段页表，它控制该页表来虚拟化虚拟机的地址空间，并包含从传递到 VM 的设备到与 VM 关联的内存的内存访问。</p>
<p>当两阶段地址转换处于活动状态时，首先使用Guest OS管理的第一阶段页表将 IOVA 转换为 GPA，然后使用hypervisor管理的第二阶段页表将 GPA 转换为 SPA。</p>
<p>图 4 说明了这一概念。</p>
<p>IOMMU被配置为使用设备D1的第一级和第二级页表来执行地址转换。第二阶段通常由管理程序用于将 GPA 转换为 SPA 并将设备 D1 限制为与 VM-1 关联的内存。第一阶段通常由Guest OS配置，将 VA 转换为 GPA，并包含设备 D1 对 VM-1 内存子集的访问。</p>
<p>对于设备 D2，仅第二级处于活动状态，第一级设置为 Bare。</p>
<p>主机操作系统或 hypervisor 还可以保留设备（例如 D3）供其自己使用。第一阶段足以为设备D3提供所需的地址转换和保护功能，第二阶段设置为Bare。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808102108573-1730797861485-7.png" alt="image-20230808102108573"></p>
<h2 id="1-3-布局和数据流"><a href="#1-3-布局和数据流" class="headerlink" title="1.3.布局和数据流"></a>1.3.布局和数据流</h2><p>图 5 显示了具有 RISC-V hart 的典型片上系统 (SOC) 的示例。 SOC 包含内存控制器和多个 IO 设备。该 SOC 还包含两个 IOMMU 实例。设备可以直接连接到 IO 桥和系统互连，或者当需要 IO 协议事务到系统互连事务转换时可以通过根端口连接。例如，在 PCIe [1] 的情况下，根端口是一个 PCIe 端口，它通过关联的虚拟 PCI-PCI 桥映射层次结构的一部分，并将 PCIe IO 协议事务映射到系统互连事务。</p>
<p>第一个 IOMMU 实例 IOMMU 0（与 IO Bridge 0 关联）将根端口连接到系统结构&#x2F;互连。一个或多个端点设备通过该根端口连接到 SoC。对于 PCIe，根端口包含一个到 IOMMU 的 ATS 接口，用于由 IOMMU 支持 PCIe ATS 协议。该示例显示了具有设备端 ATC (DevATC) 的端点设备，该设备保存设备使用 PCIe ATS 协议 [1] 从 IOMMU 0 获取的转换。</p>
<p>当不需要使用根端口的这种IO协议到系统结构协议转换时，设备可以直接与系统结构连接。第二个 IOMMU 实例 IOMMU 1（与 IO 桥 1 关联）说明了在不使用根端口的情况下将设备（IO 设备 A 和 B）连接到系统结构。</p>
<p>IO 桥放置在设备和系统互连之间以处理 DMA 事务。 IO 设备可以使用 IO 虚拟地址（VA、GVA 或 GPA）执行 DMA 事务。 IO 桥调用关联的 IOMMU 将 IOVA 转换为 Supervisor 物理地址 (SPA)</p>
<p>不会为出站事务调用 IOMMU。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808102225275-1730797861485-9.png" alt="image-20230808102225275"></p>
<p>图 5. SoC 中 IOMMU 集成的示例。</p>
<p>IOMMU 由 IO 桥调用以进行地址转换和入站事务保护。 IOMMU 不处理与入站事务关联的数据。IOMMU 的行为类似于 IO 桥的后备 IP，并具有多个接口（参见图 6）：</p>
<ul>
<li><p>主机接口：它是IOMMU 的接口，供hart 访问其内存映射寄存器并执行全局配置和&#x2F;或维护操作。</p>
</li>
<li><p>设备转换请求接口：该接口接收来自IO Bridge 的转换请求。在此接口上，IO 桥提供有关请求的信息，例如：</p>
<ul>
<li>a. 与事务关联的硬件身份 - device_id 以及 process_id（如果适用）及其有效性。 IOMMU 使用硬件标识来检索上下文信息以执行请求的地址转换。</li>
<li>b. IOVA 和事务类型（已翻译或未翻译）。</li>
<li>c. 请求是读取、写入、执行还是原子操作。<ul>
<li>i.执行请求必须与请求显式关联（例如，使用 PCIe PASID）。如果没有明确请求，则默认值必须为 0。</li>
</ul>
</li>
<li>d.与请求关联的特权模式。当权限模式未与请求显式关联时（例如，使用 PCIe PASID），默认权限模式必须是用户。对于没有 process_id 的请求，权限模式必须是 User。</li>
<li>e.请求访问的字节数。</li>
<li>f. IO 桥还可以提供一些附加的不透明信息（例如标签），这些信息不由 IOMMU 解释，而是与 IOMMU 的响应一起返回到 IO 桥。由于允许 IOMMU 无序地完成转换请求，因此 IO 桥可以使用此类信息来将完成情况与先前的请求相关联。</li>
</ul>
</li>
<li><p>数据结构接口：IOMMU 使用它来隐式访问内存。它是 IO 桥的请求者接口，用于从主存储器获取所需的数据结构。<br>该接口用于访问：</p>
<ul>
<li>a. 用于获取上下文信息和转换规则的设备和进程目录。</li>
<li>b. 用于转换IOVA的第一阶段和&#x2F;或第二阶段页表条目。</li>
<li>c.  内存队列（命令队列、故障队列和页面请求队列）用于与软件交互。</li>
</ul>
</li>
<li><p>设备转换完成接口：它是一个为先前请求的地址转换提供来自 IOMMU 的完成响应的接口。完成接口可以提供诸如以下的信息：</p>
<ul>
<li>a. 请求的状态，指示请求是成功完成还是发生错误。</li>
<li>b. 如果请求成功完成；主管物理地址 (SPA)。</li>
<li>c. 与请求关联的不透明信息（例如标签）（如果适用）。</li>
<li>d. 基于页的内存类型 (PBMT)（如果支持 Svpbmt）从 IOMMU 地址转换页表获取。 IOMMU 提供在第一阶段和第二阶段页表条目之间解析的基于页的内存类型。</li>
</ul>
</li>
<li><p>ATS 接口：如果 IOMMU 支持可选 PCIe ATS 功能，则 ATS 接口用于通过 PCIe 根端口与支持 ATS 的端点进行通信。该接口使用：</p>
<ul>
<li>a. 从端点接收 ATS 转换请求并将完成结果返回到端点。根端口可以提供发起请求的端点是否是 CXL 类型 1 或类型 2 设备的指示。</li>
<li>b. 向端点发送 ATS“无效请求”消息并从端点接收“无效完成”消息。</li>
<li>c. 从端点接收“页面请求”和“停止标记”消息并向端点发送“页面请求组响应”消息。</li>
</ul>
<p>与在内存驻留中断文件 (MRIF) 中记录传入 MSI 相关的接口（请参阅 RISC-V 高级中断架构 [2]）是特定于实现的。 IOMMU 和 IO 桥之间用于在 MRIF 中记录传入 MSI 并生成相关通知 MSI 的责任划分是特定于实现的。</p>
</li>
</ul>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808103533694-1730797861485-11.png" alt="image-20230808103533694"></p>
<p>图 6.IOMMU 接口。</p>
<p>与 RISC-V hart 类似，即使 IOMMU 处于旁路（裸模式）下，也必须对所有入站 IO 事务完成物理内存属性 (PMA) 和物理内存保护 (PMP) 检查。 PMA 和 PMP 检查器的放置和集成是一个平台选择。</p>
<p>PMA 和 PMP 检查器驻留在 IOMMU 之外。上面的示例在 IO 桥中显示了它们。</p>
<p>PMA 检查器检查 IOMMU 本身通过数据结构接口进行的隐式访问。 PMA 与给定物理平台的组织紧密相关，并且许多细节本质上是特定于平台的。</p>
<p>IOMMU 使用数据结构接口执行的存储器访问通常不需要与设备启动的存储器访问一起排序。</p>
<blockquote>
<p>IOMMU可以在数据结构接口上生成隐式存储器访问以访问执行地址转换所需的数据结构。此类访问不得被原始设备发起的内存访问所阻止。</p>
<p>IO桥可以在数据结构接口上执行存储器访问的排序，以满足必要的危险检查和由IO桥和系统互连定义的其他规则。</p>
</blockquote>
<p>IOMMU 向 IO 桥提供已解析的 PBMT（PMA、IO、NC）以及设备转换完成接口上的已转换地址。 IO 桥中的 PMA 检查器可以使用提供的 PBMT 来覆盖关联内存页的 PMA。</p>
<p>PMP检查器可以使用总线访问发起器的硬件ID来确定物理存储器访问权限。由于IOMMU本身是其隐式访问的总线访问发起者，因此PMP检查器可以使用IOMMU硬件ID来选择适当的访问控制规则。</p>
<blockquote>
<p>IOMMU 不验证 IO 桥提供的硬件 ID 的真实性。</p>
<p>IO 桥和&#x2F;或根端口必须包含适当的机制来验证硬件 ID。在一些 SOC 中，这可以通过集成到 SOC 中的设备及其 ID 不可变的属性来轻松实现。例如，对于 PCIe，PCIe 定义的访问控制服务 (ACS) 源验证功能可用于验证硬件 ID。</p>
<p>可以提供IO桥中的其他特定于实现的方法来执行这样的认证。</p>
</blockquote>
<h2 id="1-4-IOMMU特性"><a href="#1-4-IOMMU特性" class="headerlink" title="1.4. IOMMU特性"></a>1.4. IOMMU特性</h2><p>RISC-V IOMMU 规范 1.0 版支持以下功能：</p>
<ul>
<li><p>基于内存的设备上下文来定位参数和地址转换结构。设备上下文使用硬件提供的唯一device_id 进行定位。支持的 device_id 宽度最多可达 24 位。</p>
</li>
<li><p>基于内存的进程上下文，使用硬件提供的唯一process_id 来定位参数和地址转换结构。支持的process_id最多可达20位。</p>
</li>
<li><p>16 位GSCID 和20 位PSCID。</p>
</li>
<li><p>两阶段地址转换。</p>
</li>
<li><p>RISC-V 特权规范[3] 指定的基于页的虚拟内存系统允许软件灵活地为CPU MMU 和IOMMU 使用通用页表，或为IOMMU 使用单独的页表。</p>
</li>
<li><p>高达57 位虚拟地址宽度、56 位系统物理地址和59 位Guest 物理地址宽度。</p>
</li>
<li><p>PTE 访问位和脏位的硬件更新。</p>
</li>
<li><p>使用RISC-V 高级中断架构[2] 指定的MSI 页表识别对虚拟中断文件的内存访问和MSI 地址转换。</p>
</li>
<li><p>Svnapot 和Svpbmt 扩展。</p>
</li>
<li><p>PCIe ATS 和PRI 服务[1]。支持将 IOVA 翻译为 GPA 而不是 SPA 以响应翻译请求。</p>
</li>
<li><p>硬件性能监视器(HPM)。</p>
</li>
<li><p>MSI 和有线信号中断以请求软件服务。</p>
</li>
<li><p>软件的寄存器接口，用于请求地址转换以支持调试。</p>
</li>
</ul>
<p>IOMMU 支持的功能可以使用第 5.3 节的功能寄存器来发现。</p>
<h1 id="第-2-章-数据结构"><a href="#第-2-章-数据结构" class="headerlink" title="第 2 章 数据结构"></a>第 2 章 数据结构</h1><p>IOMMU 使用称为设备上下文 (DC) 的数据结构将设备与地址空间关联起来，并保存 IOMMU 用于执行地址转换的其他每设备参数。使用 device_id 遍历称为设备目录表 (DDT) 的基数树数据结构来定位 DC。</p>
<p>当设备的控制权传递给Guest OS时，设备使用的地址空间可能需要第二阶段地址转换和保护。Guest OS可以选择提供第一阶段页表，用于将Guest OS控制的设备使用的IOVA转换为GPA。当不需要使用第一阶段时，可以通过将第一阶段地址转换方案选择为Bare来有效地禁用第一阶段。第二阶段用于将 GPA 转换为 SPA。</p>
<p>当设备的控制权由hypervisor或主机操作系统本身保留时，只有第一阶段足以执行必要的地址转换和保护；通过将第二阶段地址转换方案编程为Bare，可以有效地为设备禁用第二阶段方案。</p>
<p>当第二阶段地址转换不为Bare时，DC保存根第二阶段页表的PPN；Guest软上下文 ID (GSCID)，有助于在每个虚拟机的基础上使缓存的地址转换失效；和第二阶段地址转换方案。</p>
<p>一些设备支持多个进程上下文，其中每个上下文可以与不同的进程相关联，从而与不同的虚拟地址空间相关联。此类设备中的上下文可以配置有标识地址空间的process_id。当进行内存访问时，此类设备会发出 process_id 和 device_id 信号来标识所访问的地址空间。</p>
<p>这种设备的示例可以是支持多个进程上下文的GPU，其中每个上下文与不同的用户进程相关联，使得GPU可以使用用户进程本身提供的虚拟地址来访问存储器。为了支持选择与 process_id 关联的地址空间，DC 保存根进程目录表 (PDT) 的 PPN，这是一种基数树数据结构，使用 process_id 的字段进行索引以定位称为进程上下文 (PC) 的数据结构。 ）。</p>
<p>当 PDT 处于活动状态时，第一阶段地址转换的控制由 (PC) 控制。</p>
<p>当 PDT 未激活时，第一阶段地址转换的控制由 DC 本身控制。</p>
<p>第一级地址转换控制包括根第一级页表的PPN；进程软上下文 ID (PSCID)，有助于在每个地址空间的基础上使缓存的地址转换失效；以及第一阶段地址转换方案。</p>
<p>要处理来自Guest OS控制的设备的 MSI，IOMMU 必须能够将这些 MSI 重定向到 IMSIC 中的Guest interrupt file。由于来自设备的 MSI 只是内存写入，因此它们自然会受到 IOMMU 应用于其他内存写入的相同地址转换的影响。然而，IOMMU架构可以专门对待针对虚拟机的MSI，部分是为了简化软件，部分是为了允许对驻留内存的中断文件的可选支持。为了支持此功能，该架构向设备上下文添加了 MSI 地址掩码和地址模式，它们一起用于识别作为 MSI 目的地的Guest 物理地址空间中的页面；以及用于控制来自设备的MSI的转换和&#x2F;或转换的MSI页表的真实物理地址。 IOMMU 对虚拟机 MSI 的支持由高级中断架构规范指定。</p>
<p>DC 进一步控制允许设备生成的事务类型。这种控制的一个例子是是否允许设备使用 PCIe 定义的地址转换服务 (ATS) [1]。</p>
<p>支持两种格式的设备上下文结构：</p>
<ul>
<li><p>基本格式 - 当 IOMMU 不支持第 2.3.3 节中指定的 MSI 特殊处理时，使用 32 字节大小。</p>
</li>
<li><p>扩展格式 - 大小为 64 字节，并使用附加字段扩展基本格式 DC，以按照第 2.3.3 节中的规定转换 MSI。</p>
</li>
</ul>
<p>如果功能.MSI_FLAT 为 1，则使用扩展格式，否则使用基本格式。</p>
<p>用于定位 DC 的 DDT 可以配置为 1、2 或 3 级基数树，具体取决于支持的 device_id 的最大宽度。对device_id进行分区以获得设备目录索引（DDI）以遍历DDT基数树如下：</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808104925656-1730797861485-13.png" alt="image-20230808104925656"></p>
<p>图 7. 基本格式 device_id 分区</p>
<p>图 8. 扩展格式 device_id 分区</p>
<p>PDT 可以配置为 1、2 或 3 级基数树，具体取决于该设备支持的 process_id 的最大宽度。对 process_id 进行分区以获得进程目录索引（PDI）以遍历 PDT 基数树，如下所示：</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808105003664-1730797861485-15.png" alt="image-20230808105003664"></p>
<p>图 9. PDT 基数树遍历的 process_id 分区</p>
<blockquote>
<p>process_id 分区设计为每个进程目录表最多需要 4 KiB（一页）内存。使用 20 位宽的 process_id 时，表的根未完全填充。考虑过让根表占用 32 KiB 的选项，但没有采用，因为这些表是在运行时分配的，并且大于页面的连续内存分配可能会给Guest和管理程序内存分配器带来压力。</p>
</blockquote>
<blockquote>
<p>所有 RISC-V IOMMU 实现都需要支持位于主内存中的 DDT 和 PDT。支持 I&#x2F;O 存储器中的数据结构不是必需的，但本规范并不禁止。</p>
</blockquote>
<h2 id="2-1-设备目录表-DDT"><a href="#2-1-设备目录表-DDT" class="headerlink" title="2.1.设备目录表 (DDT)"></a>2.1.设备目录表 (DDT)</h2><p>DDT 是使用 device_id 的设备目录索引 (DDI) 位进行索引的 1、2 或 3 级基数树，以定位 DC。</p>
<p>下图说明了 DDT 基数树。根设备目录表的 PPN 保存在称为 <strong>设备目录表指针</strong> (ddtp) 的内存映射寄存器中。</p>
<p>每个有效的非叶 (NL) 条目的大小为 8 字节，并保存下一个设备目录表的 PPN。</p>
<p>有效的叶设备目录表条目保存设备上下文 (DC)。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808105102573-1730797861485-17.png" alt="image-20230808105102573"></p>
<p>图 10. 具有扩展格式 DC 的三级、二级和单级设备目录</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808105146471-1730797861485-19.png" alt="image-20230808105146471"></p>
<p>图 11. 具有基本格式 DC 的三级、二级和单级设备目录</p>
<h3 id="2-1-1-非叶-DDT-条目"><a href="#2-1-1-非叶-DDT-条目" class="headerlink" title="2.1.1.非叶 DDT 条目"></a>2.1.1.非叶 DDT 条目</h3><p>有效的 (V&#x3D;&#x3D;1) 非叶 DDT 条目提供下一级 DDT 的 PPN。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808105614645-1730797861485-21.png" alt="image-20230808105614645"></p>
<p>图 12. 非叶设备目录表条目</p>
<h3 id="2-1-2-叶-DDT-条目"><a href="#2-1-2-叶-DDT-条目" class="headerlink" title="2.1.2.叶 DDT 条目"></a>2.1.2.叶 DDT 条目</h3><p>叶 DDT 页由 DDI[0] 索引并保存设备上下文 (DC)。</p>
<p>在基本格式中，DC 为 32 字节。在扩展格式中，DC 为 64 字节。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808105702072-1730797861485-25.png" alt="image-20230808105702072"></p>
<p>图 13. 基本格式设备上下文</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808105727608-1730797861485-23.png" alt="image-20230808105727608"></p>
<p>图 14. 扩展格式设备上下文</p>
<p>DC 在基本格式中被解释为 4 个 64 位双字，在扩展格式中被解释为 8 个 64 位双字。内存中每个双字的字节顺序（小端字节序或大端字节序）是由 fctl.BE（第 5.4 节）确定的字节序。 IOMMU 可以按任何顺序读取 DC 字段。</p>
<h3 id="2-1-3-设备上下文字段"><a href="#2-1-3-设备上下文字段" class="headerlink" title="2.1.3.设备上下文字段"></a>2.1.3.设备上下文字段</h3><h4 id="转换控制-tc"><a href="#转换控制-tc" class="headerlink" title="转换控制 (tc)"></a>转换控制 (tc)</h4><p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808110051118-1730797861485-27.png" alt="image-20230808110051118"></p>
<p>图 15. 转换控制 (tc) 字段</p>
<p>V位为1时DC有效；如果为 0，则 DC 中的所有其他位都无关紧要，可以由软件自由使用。</p>
<p>如果 IOMMU 支持 PCIe ATS 规范 [1]（请参阅功能寄存器），则 EN_ATS 位用于启用 ATS 事务处理。如果 EN_ATS 设置为 1，IOMMU 支持以下入站事务；否则它们将被视为不受支持的请求。</p>
<ol>
<li>执行事务的已转换读 </li>
<li>已转换读事务 </li>
<li>已转换写&#x2F;AMO 事务 </li>
<li>PCIe ATS 转换请求 </li>
<li>PCIe ATS 无效完成消息</li>
</ol>
<p>如果 EN_ATS 位为 1 并且 T2GPA 位设置为 1，则 IOMMU 执行两阶段地址转换，以确定在完成来自设备的 PCIe ATS 转换请求时要提供的转换大小和权限。然而，IOMMU 返回 GPA，而不是 SPA，作为响应中 IOVA 的翻译。在此操作模式下，设备中的 ATC 缓存 GPA 作为 IOVA 的转换，并在后续转换的内存访问事务中使用 GPA 作为地址。通常，已转换的请求使用 SPA，不需要 IOMMU 执行进一步的转换。然而，当 T2GPA 为 1 时，来自设备的转换请求使用 GPA，并由 IOMMU 使用第二阶段页表转换为 SPA。 T2GPA 控制使管理程序能够包含来自设备的 DMA，即使设备滥用 ATS 功能并尝试访问与 VM 不关联的内存也是如此。</p>
<blockquote>
<p>当 T2GPA 启用时，为响应 PCIe ATS 转换请求而提供给设备的地址无法由将设备连接到其他对等设备和主机的 I&#x2F;O 结构（例如 PCI 交换机）直接路由。当支持设备内的点对点事务（例如，设备的功能之间）时，此类地址也无法在设备内路由。</p>
<p>将 T2GPA 配置为 1 的管理程序必须通过特定于协议的方式确保已转换的访问通过主机进行路由，以便 IOMMU 可以转换 GPA，然后将基于 PA 的事务路由到内存或对等设备。例如，对于 PCIe，访问控制服务 (ACS) 必须配置为始终将对等 (P2P) 请求上游重定向到主机。</p>
<p>使用设置为 1 的 T2GPA 可能与实现由响应 PCIe ATS 转换请求而返回的转换地址标记的缓存的设备不兼容。</p>
<p>作为将 T2GPA 设置为 1 的替代方案，如果设备支持身份验证协议，管理程序可以与设备建立信任关系。例如，对于 PCIe，PCIe 组件测量和身份验证 (CMA) 功能提供了一种机制来验证设备的配置和固件&#x2F;可执行文件（测量）以及硬件身份（身份验证），以建立此类信任关系。</p>
</blockquote>
<p>如果 EN_PRI 位为 0，则来自设备的 PCIe“页面请求”消息是无效请求。从设备接收到的“页面请求”消息通过“页面请求组响应”消息进行响应。通常，软件处理程序生成此响应消息。然而，在某些情况下，IOMMU 本身可能会生成响应。对于 IOMMU 生成的“页面请求组响应”消息，PRG 响应 PASID 要求 (PRPR) 位设置为 1 时指示，如果关联的“页面请求”具有 PASID，则 IOMMU 响应消息应包含 PASID。</p>
<blockquote>
<p>支持 PASID 且“PRG 响应 PASID 必需”功能位设置为 1 的功能，如果关联的“页面请求”消息具有 PASID，则期望“页面请求组响应”消息将包含 PASID。如果功能位为 0，则该函数不期望任何“页面请求组响应”消息上有 PASID，并且该函数在接收到带有 PASID 的响应时的行为未定义。 PRPR 位应配置为“需要 PRG 响应 PASID”功能位中保存的值。</p>
</blockquote>
<p>将禁用转换故障 (DTF) 位设置为 1 可禁用报告地址转换过程中遇到的故障。将 DTF 设置为 1 不会禁止为响应故障事务而向设备生成错误响应。将 DTF 设置为 1 不会禁用 IOMMU 报告与地址转换过程无关的故障。 DTF为1时不上报的故障如表11所示。</p>
<blockquote>
<p>当hypervisor识别出可能导致一系列错误（例如由于虚拟机异常终止）的情况时，它可以将 DTF 设置为 1 以禁用故障报告。</p>
</blockquote>
<p>DC.fsc 字段保存第一阶段翻译的上下文。如果 PDTV 位为 1，则该字段保存进程目录表指针 (pdtp)。如果 PDTV 位为 0，则 DC.fsc 字段保持 (iosatp)。</p>
<p>当 DC 与支持多个进程上下文的设备关联时，PDTV 位预计设置为 1，从而通过其内存访问生成有效的 process_id。例如，对于 PCIe，如果请求具有 PASID，则 PASID 将用作 process_id。</p>
<p>当PDTV为1时，DPE位可以设置为1以允许使用0作为process_id的默认值来转换没有有效process_id的请求。当PDTV为0时，DPE位被保留用于未来的标准扩展。</p>
<p>如果capability.AMO_HWAD 为1，则IOMMU 支持GADE 和SADE 位设置为1。当capability.AMO_HWAD 为0 时，这些位被保留。</p>
<p>如果 GADE 为 1，则 IOMMU 以原子方式更新第二阶段 PTE 中的 A 和 D 位。如果 GADE 为 0，则当 A 位为 0 或者内存访问为存储并且 D 位为 0 时，IOMMU 会导致与原始访问类型相对应的Guest页面错误。</p>
<p>如果 SADE 为 1，则 IOMMU 以原子方式更新第一阶段 PTE 中的 A 和 D 位。如果 SADE 为 0，则当 A 位为 0 或内存访问为存储并且 D 位为 0 时，IOMMU 会导致与原始访问类型相对应的页错误。</p>
<p>如果 SBE 为 0，则对 PDT 条目和第一阶段 PTE 的隐式内存访问为小端字节序，否则为大端字节序。 SBE支持的值与fctl.BE字段相同。</p>
<p>SXL 字段控制支持的分页虚拟内存方案，如表 3 中所定义。如果 fctl.GXL 为 1，则 SXL 字段必须为 1；否则，fctl.GXL 为 1。否则，SXL 字段的合法值与 fctl.GXL 字段的合法值相同。</p>
<p>当 SXL 为 1 时，适用以下规则：</p>
<ul>
<li><p>如果第一阶段不是 Bare，则当 IOVA 的第 31 位以外的位设置为 1 时，会发生与原始访问类型相对应的页错误。</p>
</li>
<li><p>如果第二阶段不是 Bare，则如果传入 GPA 将第 33 位以外的位设置为 1，则会发生与原始访问类型相对应的Guest page fault。</p>
</li>
</ul>
<h4 id="IO-管理程序Guest地址转换和保护-iohgatp"><a href="#IO-管理程序Guest地址转换和保护-iohgatp" class="headerlink" title="IO 管理程序Guest地址转换和保护 (iohgatp)"></a>IO 管理程序Guest地址转换和保护 (iohgatp)</h4><p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808110856889-1730797861485-29.png" alt="image-20230808110856889"></p>
<p>图 16. IO 管理程序Guest地址转换和保护 (iohgatp) 字段</p>
<p>iohgatp 字段保存根第二阶段页表的 PPN 和由Guest软上下文 ID (GSCID) 标识的虚拟机，以促进基于每个虚拟机的地址转换栅栏。如果多个设备与具有公共第二阶段页表的 VM 相关联，则hypervisor应在每个 iohgatp 中编程相同的 GSCID。 MODE字段用于选择第二阶段地址转换方案。</p>
<p>第二阶段页表格式由特权规范定义。 fctl.GXL 字段控制支持的Guest physical address地址转换方案，如表 2 中所定义。</p>
<p>iohgatp MODE 字段标识分页虚拟内存方案，其编码如下：</p>
<p>表 2. iohgatp.MODE 字段的编码</p>
<table>
    <tr>
        <th align="center" colspan="3"><font color="red">fctl.GXL=0</font></th>
    </tr>
    <tr>
        <td>Value</td>
        <td>Name</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>0</td>
        <td><font color="red">Bare</font></td>
        <td>没有翻译或保护</td>
    </tr>
    <tr>
        <td>1-7</td>
        <td>-</td>
        <td>保留供标准使用</td>        
    </tr>
    <tr>
        <td>8</td>
        <td><font color="red">Sv39x4</font></td>
        <td>基于页的 41 位虚拟寻址（Sv39 的 2 位扩展）</td> 
    </tr>
    <tr>
        <td>9</td>
        <td><font color="red">Sv48x4</font></td>
        <td>基于页的 50 位虚拟寻址（Sv48 的 2 位扩展）</td>         
    </tr>
    <tr>
        <td>10</td>
        <td><font color="red">Sv57x4</font></td>
        <td>基于页的 59 位虚拟寻址（Sv57 的 2 位扩展）</td>         
    </tr>
    <tr>
        <td>11-15</td>
        <td>-</td>
        <td>保留供标准使用</td>         
    </tr>
    <tr>
        <th align="center" colspan="3"><font color="red">fctl.GXL=1</font></th>
    </tr>
    <tr>
        <td>Value</td>
        <td>Name</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>0</td>
        <td><font color="red">Bare</font></td>
        <td>没有翻译或保护</td>
    </tr>
    <tr>
        <td>1-7</td>
        <td>-</td>
        <td>保留供标准使用</td>        
    </tr>
    <tr>
        <td>8</td>
        <td><font color="red">Sv32x4</font></td>
        <td>基于页的 34 位虚拟寻址（Sv32 的 2 位扩展）</td> 
    </tr> 
       <tr>
        <td>9-15</td>
        <td>-</td>
        <td>保留供标准使用</td>         
    </tr> 
</table>

<p>实现不需要支持 iohgatp 的所有定义模式设置。 IOMMU 仅需要支持集成到系统或其子集中的 HART 中的 MMU 也支持的模式。</p>
<p>iohgatp.PPN 确定的根页表为 16 KiB，并且必须与 16 KiB 边界对齐。</p>
<blockquote>
<p>iohgatp 的 GSCID 字段标识地址空间。如果在两个 DC 引用的第二级页表不相同时在两个 DC 中配置相同的 GSCID，则无法预测 IOMMU 是否使用来自第一页表或第二页表的 PTE。这些是唯一预期的行为。</p>
</blockquote>
<h4 id="翻译属性-ta"><a href="#翻译属性-ta" class="headerlink" title="翻译属性 (ta)"></a>翻译属性 (ta)</h4><p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808135937149-1730797861485-31.png" alt="image-20230808135937149"></p>
<p>图 17. 翻译属性 (ta) 字段</p>
<p>ta 的 PSCID 字段提供标识进程地址空间的进程软上下文 ID。 PSCID 促进基于每个地址空间的地址转换栅栏。如果 DC.tc.PDTV 为 0 并且 iosatp.MODE 字段不是 Bare，则 ta 中的 PSCID 字段用作地址空间 ID。</p>
<p>当DC.tc.PDTV 为 1，ta 中的 PSCID 字段被忽略。</p>
<h4 id="第一阶段上下文-fsc"><a href="#第一阶段上下文-fsc" class="headerlink" title="第一阶段上下文 (fsc)"></a>第一阶段上下文 (fsc)</h4><p>First-Stage context (fsc)</p>
<p>如果 DC.tc.PDTV 为 0，则 DC.fsc 字段保存为第一阶段地址转换和保护提供控制的 iosatp。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808140100389-1730797861485-33.png" alt="image-20230808140100389"></p>
<p>图 18. IO Supervisor 地址转换和保护。 (iosatp) 字段</p>
<p>第一阶段页表格式由特权规范定义。</p>
<p>DC.tc.SXL 字段控制支持的分页虚拟内存方案。</p>
<p>iosatp.MODE 标识分页虚拟内存方案并按照表 3 中的定义进行编码。</p>
<p>iosatp.PPN字段保存第一阶段页表的根页的PPN。</p>
<p>当第二阶段地址转换不是 Bare 时，iosatp.PPN 是 Guest PPN。然后根页的 GPA 由Guest physical addresses转换过程（由 iohgatp 控制）转换为管理程序物理地址。</p>
<p>表 3. iosatp.MODE 字段的编码</p>
<table>
        <tr>
        <th align="center" colspan="3"><font color="red">DC.tc.SXL=0</font></th>
    </tr>
    <tr>
        <td>Value</td>
        <td>Name</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>0</td>
        <td><font color="red">Bare</font></td>
        <td>没有翻译或保护</td>
    </tr>
    <tr>
        <td>1-7</td>
        <td>-</td>
        <td>保留供标准使用</td>        
    </tr>
    <tr>
        <td>8</td>
        <td><font color="red">Sv39</font></td>
        <td>基于页的 39 位虚拟寻址</td> 
    </tr>
    <tr>
        <td>9</td>
        <td><font color="red">Sv48</font></td>
        <td>基于页的 48 位虚拟寻址。</td>         
    </tr>
    <tr>
        <td>10</td>
        <td><font color="red">Sv57</font></td>
        <td>基于页的 57 位虚拟寻址。</td>         
    </tr>
    <tr>
        <td>11-13</td>
        <td>-</td>
        <td>保留供标准使用</td>         
    </tr>
    <tr>
        <td>14-15</td>
        <td>-</td>
        <td>指定用于定制用途 Designated for custom use.</td>         
    </tr>
    <tr>
        <th align="center" colspan="3"><font color="red">DC.tc.SXL=1</font></th>
    </tr>
    <tr>
        <td>Value</td>
        <td>Name</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>0</td>
        <td><font color="red">Bare</font></td>
        <td>没有翻译或保护</td>
    </tr>
    <tr>
        <td>1-7</td>
        <td>-</td>
        <td>保留供标准使用</td>        
    </tr>
    <tr>
        <td>8</td>
        <td><font color="red">Sv32</font></td>
        <td>基于页的 34 位虚拟寻址（Sv32 的 2 位扩展）</td> 
    </tr> 
       <tr>
        <td>9-15</td>
        <td>-</td>
        <td>保留供标准使用</td>         
    </tr> 
</table>

<p>当 DC.tc.PDTV 为 1 时，DC.fsc 字段保存进程目录表指针 (pdtp)。当设备支持由process_id选择的多个进程上下文时，PDT用于确定第一阶段页表和关联的PSCID以进行虚拟地址转换和保护。</p>
<p>pdtp字段保存根PDT的PPN和确定PDT的级别数的MODE字段。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808140627848-1730797861485-35.png" alt="image-20230808140627848"></p>
<p>当第二阶段地址转换不是 Bare 时，pdtp.PPN 字段保存Guest PPN。然后根 PDT 的 GPA 由Guest physical addresses转换过程（由 iohgatp 控制）转换为管理程序物理地址。使用第二阶段页表转换PDT的地址，允许PDT保存在Guest OS分配的内存中，并允许Guest OS直接编辑PDT以关联由第一阶段页表标识的虚拟地址空间带有 process_id。</p>
<p>表 4. pdtp.MODE 字段的编码</p>
<table>
    <tr>
        <td>Value</td>
        <td>Name</td>
        <td>Description</td>
    </tr>
    <tr>	
        <td>0</td>
        <td><font color="red">Bare</font></td>
        <td>没有第一阶段地址转换或保护</td>
    </tr>
    <tr>
        <td>1</td>
        <td><font color="red">PD8</font></td>
        <td>启用 8 位进程 ID。该目录有 1 级，256 个条目。process_id 的第 19:8 位必须为 0。</td>        
    </tr>
    <tr>
        <td>2</td>
        <td><font color="red">PD17</font></td>
        <td>启用 17 位进程 ID。该目录有 2 级。根 PDT 页有 512 个条目，叶级有 256 个条目。 process_id 的位 19:17 必须为 0。</td> 
    </tr>
    <tr>
        <td>3</td>
        <td><font color="red">PD20</font></td>
        <td>启用 20 位进程 ID。该目录有 3 级。根 PDT 有 8 个条目，下一个非叶级别有 512 个条目。叶级有 256 个条目。</td>         
    </tr>
    <tr>
        <td>4-13</td>
        <td>-</td>
        <td>保留供标准使用</td>         
    </tr>
    <tr>
        <td>14-15</td>
        <td>-</td>
        <td>指定用于定制用途 Designated for custom use.</td>         
    </tr>
</table>

<h4 id="MSI-页表指针-msiptp"><a href="#MSI-页表指针-msiptp" class="headerlink" title="MSI 页表指针 (msiptp)"></a>MSI 页表指针 (msiptp)</h4><p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808141606246-1730797861485-37.png" alt="image-20230808141606246"></p>
<p>msiptp.PPN 字段保存根 MSI 页表的 PPN，用于将 MSI 定向到 IMSIC 中的Guest interrupt files。 MSI 页表格式由高级中断架构规范定义。</p>
<p>msiptp.MODE 字段用于选择 MSI 地址转换方案。</p>
<p>表 5. msiptp.MODE 字段的编码</p>
<table>
    <tr>
        <td>Value</td>
        <td>Name</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>0</td>
        <td><font color="red">Off</font></td>
        <td>不执行使用 MSI 地址掩码和模式对虚拟中断文件的访问的识别。</td>
    </tr>
    <tr>
        <td>1</td>
        <td><font color="red">Flat</font></td>
        <td>平面 MSI 页表 Flat MSI page table</td>
    </tr>
    <tr>
        <td>2-13</td>
        <td>-</td>
        <td>保留供标准使用。</td>
    </tr>
    <tr>
        <td>14-15</td>
        <td>-</td>
        <td>指定供定制使用。Designated for custom use.</td>
    </tr>
</table>

<h4 id="MSI-地址掩码-msi-addr-mask-和模式-msi-addr-pattern"><a href="#MSI-地址掩码-msi-addr-mask-和模式-msi-addr-pattern" class="headerlink" title="MSI 地址掩码 (msi_addr_mask) 和模式 (msi_addr_pattern)"></a>MSI 地址掩码 (msi_addr_mask) 和模式 (msi_addr_pattern)</h4><p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808142211835-1730797861485-39.png" alt="image-20230808142211835"></p>
<p>图 21. MSI 地址掩码 (msi_addr_mask) 字段</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808142244388-1730797861485-41.png" alt="image-20230808142244388"></p>
<p>图 22. MSI 地址模式 (msi_addr_pattern) 字段</p>
<p>MSI 地址掩码 (msi_addr_mask) 和模式 (msi_addr_pattern) 字段用于标识相关 VM 的Guest physical address空间中虚拟中断文件的 4 KiB 页。如果目标Guest物理页与所提供的地址掩码中为零的所有位位置中所提供的地址模式相匹配，则由设备进行的传入存储器访问被识别为对虚拟中断文件的访问。详细来说，如果满足以下条件，对Guest physical addresses A 的内存访问将被识别为对虚拟中断文件的内存映射页面的访问：</p>
<p>(A &gt;&gt; 12) &amp; ~msi_addr_mask &#x3D; (msi_addr_pattern &amp; ~msi_addr_mask)</p>
<p>其中 &gt;&gt; 12 表示右移 12 位，与号 (&amp;) 表示按位逻辑与，~msi_addr_mask 是地址掩码的按位逻辑补。</p>
<h3 id="2-1-4-设备上下文配置检查"><a href="#2-1-4-设备上下文配置检查" class="headerlink" title="2.1.4.设备上下文配置检查"></a>2.1.4.设备上下文配置检查</h3><p>如果满足以下任一条件，则 DC.tc.V&#x3D;1 的 DC 被视为配置错误。如果配置错误，则停止并报告“DDT 条目配置错误”（原因 &#x3D; 259）。</p>
<ol>
<li>是否设置了为将来标准使用而保留的任何位或编码。</li>
<li>capability.ATS为0且DC.tc.EN_ATS、或DC.tc.EN_PRI、或DC.tc.PRPR为1</li>
<li>DC.tc.EN_ATS 为 0，DC.tc.T2GPA 为 1</li>
<li>DC.tc.EN_ATS 为 0，DC.tc.EN_PRI 为 1</li>
<li>DC.tc.EN_PRI 为 0，DC.tc.PRPR 为 1 </li>
<li>capability.T2GPA 为 0，DC.tc.T2GPA 为 1 </li>
<li>DC.tc.T2GPA 为 1，DC.iohgatp.MODE 为 Bare</li>
<li>DC.tc.PDTV 为 1 并且 DC.fsc.pdtp.MODE 不是受支持的模式<ol>
<li>capabilities.PD20 为 0，DC.fsc.pdtp.MODE 为 PD20</li>
<li>capabilities.PD17 为 0，DC.fsc.pdtp.MODE 为 PD17</li>
<li>capabilities.PD8   为 0，DC.fsc.pdtp.MODE 为 PD8</li>
</ol>
</li>
<li>DC.tc.PDTV 为 0，并且 DC.fsc.iosatp.MODE 编码不是表 3 确定的有效编码</li>
<li>DC.tc.PDTV 为 0，DC.tc.SXL 为 0 DC.fsc.iosatp.MODE 不是支持的模式之一<ol>
<li>capabilities.Sv39 为 0，DC.fsc.iosatp.MODE 为 Sv39</li>
<li>capabilities.Sv48 为 0，DC.fsc.iosatp.MODE 为 Sv48</li>
<li>capabilities.Sv57 为 0，DC.fsc.iosatp.MODE 为 Sv57</li>
</ol>
</li>
<li>DC.tc.PDTV 为 0，DC.tc.SXL 为 1 DC.fsc.iosatp.MODE 不是支持的模式之一<ol>
<li>capabilities.Sv32 为 0，DC.fsc.iosatp.MODE 为 Sv32</li>
</ol>
</li>
<li>DC.tc.PDTV 为 0，DC.tc.DPE 为 1</li>
<li>根据表 2 确定，DC.iohgatp.MODE 编码不是有效编码</li>
<li>fctl.GXL 为 0 并且 DC.iohgatp.MODE 不是受支持的模式<ol>
<li>capabilities.Sv39x4 为 0，DC.iohgatp.MODE 为 Sv39x4</li>
<li>capabilities.Sv48x4 为 0，DC.iohgatp.MODE 为 Sv48x4</li>
<li>capabilities.Sv57x4 为 0，DC.iohgatp.MODE 为 Sv57x4</li>
</ol>
</li>
<li>fctl.GXL 为 1 并且 DC.iohgatp.MODE 不是受支持的模式<ol>
<li>capabilities.Sv32x4 为 0，DC.iohgatp.MODE 为 Sv32x4</li>
</ol>
</li>
<li>capabilities.MSI_FLAT 为 1 并且 DC.msiptp.MODE 不是 Off 也不是 Flat</li>
<li>DC.iohgatp.MODE 不是 Bare，并且 DC.iohgatp.PPN 确定的根页表未与 16-KiB 边界对齐。</li>
<li>capabilities.AMO_HWAD 为 0，DC.tc.SADE 或 DC.tc.GADE 为 1</li>
<li>capabilities.END 为 0 且 fctl.BE !&#x3D; DC.tc.SBE</li>
<li>DC.tc.SXL 值不是合法值。如果 fctl.GXL 为 1，则 DC.tc.SXL 必须为 1。如果 fctl.GXL 为 0 并且可写，则 DC.tc.SXL 可以为 0 或 1。如果 fctl.GXL 为 0 并且不可写，则DC.tc.SXL 必须为 0。</li>
<li>DC.tc.SBE 值不是合法值。如果 fctl.BE 可写，则 DC.tc.SBE 可以为 0 或 1。如果 fctl.BE 不可写，则 DC.tc.SBE 必须与 fctl.BE 相同。</li>
</ol>
<blockquote>
<p>一些 DC 字段保存主管物理地址或Guest physical address。某些实现可能会验证地址的有效性 - 例如管理程序物理地址不比定位 DC 时由 Capability.PAS 等确定的支持的地址宽。此类实现可能会导致“DDT 条目配置错误”（原因 &#x3D; 259）故障。</p>
<p>其他实现仅在需要访问这些字段引用的数据结构时才检测到此类地址无效。这样的实现可以检测访问过程中的访问冲突故障。</p>
</blockquote>
<h2 id="2-2-进程目录表-PDT"><a href="#2-2-进程目录表-PDT" class="headerlink" title="2.2.进程目录表 (PDT)"></a>2.2.进程目录表 (PDT)</h2><p>PDT 是使用 process_id 的进程目录索引 (PDI) 位进行索引的 1、2 或 3 级基数树。</p>
<p>下图说明了 PDT 基数树。根进程目录页号使用设备上下文的进程目录表指针 (pdtp) 字段来定位。每个非叶 (NL) 条目提供下一级进程目录表的 PPN。叶进程目录表条目保存进程上下文（PC）。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808144243491-1730797861485-45.png" alt="image-20230808144243491"></p>
<p>图 23. 三级、二级和单级进程目录</p>
<h3 id="2-2-1-非叶-PDT-条目"><a href="#2-2-1-非叶-PDT-条目" class="headerlink" title="2.2.1.非叶 PDT 条目"></a>2.2.1.非叶 PDT 条目</h3><p>有效的 (V&#x3D;&#x3D;1) 非叶 PDT 条目保存下一级 PDT 的 PPN。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808144314424-1730797861485-43.png" alt="image-20230808144314424"></p>
<p>图 24. 非叶进程目录表条目</p>
<h3 id="2-2-2-叶-PDT-条目"><a href="#2-2-2-叶-PDT-条目" class="headerlink" title="2.2.2.叶 PDT 条目"></a>2.2.2.叶 PDT 条目</h3><p>叶 PDT 页由 PDI[0] 索引并保存 16 字节进程上下文 (PC)。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808144402797-1730797861485-51.png" alt="image-20230808144402797"></p>
<p>PC 被解释为两个 64 位双字。内存中每个双字的字节顺序（小端字节序或大端字节序）是由 DC.tc.SBE 确定的字节序。 IOMMU 可以按任何顺序读取 PC 字段。</p>
<h3 id="2-2-3-流程上下文字段"><a href="#2-2-3-流程上下文字段" class="headerlink" title="2.2.3.流程上下文字段"></a>2.2.3.流程上下文字段</h3><h4 id="翻译属性-ta-1"><a href="#翻译属性-ta-1" class="headerlink" title="翻译属性 (ta)"></a>翻译属性 (ta)</h4><p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808144517205-1730797861485-47.png" alt="image-20230808144517205"></p>
<p>图 26. 翻译属性 (ta) 字段</p>
<p>V位为1时PC有效；如果为0，则PC中的所有其他位都不关心，可以被软件自由使用。</p>
<p>当 Enable-Supervisory-access (ENS) 为 1 时，使用此 process_id 允许请求管理员权限的事务，否则该事务将被视为不受支持的请求。</p>
<p>当 ENS 为 1 时，SUM（允许管理员用户内存访问）位修改管理员权限事务访问虚拟内存的权限。当 SUM 为 0 时，禁止对 PTE 中 U 位设置为 1 映射的页面进行管理员权限事务。</p>
<p>当 ENS 为 1 时，无论 SUM 的值如何，都不允许以执行意图读取 PTE 中的 U 位设置为 1 映射的页面的管理员权限事务。</p>
<p>当第一阶段地址转换不是Bare时，软件分配的进程软上下文ID（PSCID）用作第一阶段页表所标识的进程的地址空间ID。</p>
<h4 id="第一阶段上下文-fsc-1"><a href="#第一阶段上下文-fsc-1" class="headerlink" title="第一阶段上下文 (fsc)"></a>第一阶段上下文 (fsc)</h4><p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808144611178-1730797861485-49.png" alt="image-20230808144611178"></p>
<p>PC.fsc 字段提供对第一阶段地址转换和保护的控制。</p>
<p>PC.fsc.MODE 用于确定第一阶段分页虚拟内存方案，其编码如表 3 中所定义。DC.tc.SXL 字段控制支持的分页虚拟内存方案。当PC.fsc.MODE不为Bare时，PC.fsc.PPN字段保存第一级页表的根页的PPN。</p>
<p>当第二阶段地址转换不是Bare时，PC.fsc.PPN字段保存第一阶段页表根的Guest PPN。然后，第一阶段页表条目的地址由Guest physical addresses转换过程（由 DC.iohgatp 控制）转换为管理员物理地址。因此，GuestOS可以直接编辑第一阶段页表以限制设备对其存储器的子集的访问并指定设备访问的权限。</p>
<blockquote>
<p>PC.ta.PSCID标识地址空间。如果在两个PC引用的页表不相同时在两个PC中配置相同的PSCID，则无法预测IOMMU是使用来自第一页表还是第二页表的PTE。这些是唯一预期的行为。</p>
</blockquote>
<h3 id="2-2-4-进程上下文配置检查"><a href="#2-2-4-进程上下文配置检查" class="headerlink" title="2.2.4.进程上下文配置检查"></a>2.2.4.进程上下文配置检查</h3><p>如果满足以下任一条件，则 PC.ta.V&#x3D;1 的 PC 被视为配置错误。如果配置错误，则停止并报告“PDT 条目配置错误”（原因 &#x3D; 267）。</p>
<ol>
<li>如果设置了为未来标准使用保留的任何位或编码 </li>
<li>根据表 3 确定，PC.fsc.MODE 编码无效 </li>
<li>DC.tc.SXL 为 0 并且 PC.fsc.MODE 不是 1支持的模式<ol>
<li>capabilities.Sv39 为 0，PC.fsc.MODE 为 Sv39</li>
<li>capabilities.Sv48 为 0，PC.fsc.MODE 为 Sv48 </li>
<li>capabilities.Sv57 为 0，PC.fsc.MODE 为 Sv57</li>
</ol>
</li>
<li>DC.tc.SXL 为 1，PC.fsc.MODE 不是受支持的模式之一<ol>
<li>capabilities.Sv32 为 0，PC.fsc.MODE 为 Sv32</li>
</ol>
</li>
</ol>
<blockquote>
<p>某些 PC 字段保存管理员物理地址或Guest 物理地址。某些实现可能会验证地址的有效性 - 例如管理程序物理地址不比定位 PC 时由 Capability.PAS 等确定的支持的地址宽。此类实现可能会导致“PDT 条目配置错误”（原因 &#x3D; 267）故障。</p>
<p>其他实现仅在需要访问这些字段引用的数据结构时才检测到此类地址无效。这样的实现可以在进行访问的过程中检测访问冲突故障。</p>
</blockquote>
<h2 id="2-3-翻译-IOVA-的流程"><a href="#2-3-翻译-IOVA-的流程" class="headerlink" title="2.3. 翻译 IOVA 的流程"></a>2.3. 翻译 IOVA 的流程</h2><p>转换 IOVA 的进程使用硬件 ID（device_id 和 process_id）来定位设备上下文和进程上下文。设备上下文和进程上下文提供页表的根 PPN、PSCID、GSCID 以及影响地址转换和保护过程的其他控制参数。当实现地址转换缓存（第 2.8 节）时，转换过程可以使用 GSCID 和 PSCID 将缓存的转换与其地址空间相关联。</p>
<p>翻译 IOVA 的过程如下：</p>
<ol>
<li><p>如果 ddtp.iommu_mode &#x3D;&#x3D; Off 则停止并报告“禁止所有入站事务”（原因 &#x3D; 256）。</p>
</li>
<li><p>如果 ddtp.iommu_mode &#x3D;&#x3D; Bare 并且满足以下任何条件，则停止并报告“事务类型不允许”（原因 &#x3D; 260）；否则转至步骤 20，转换后的地址与 IOVA 相同。</p>
<ol>
<li>事务类型是翻译请求（读、写&#x2F;AMO、读执行）或者是 PCIe ATS 翻译请求。</li>
</ol>
</li>
<li><p>如果 features.MSI_FLAT 为 0，则 IOMMU 使用基本格式设备上下文。设DDI[0]为device_id[6:0]，DDI[1]为device_id[15:7]，DDI[2]为device_id[23:16]。</p>
</li>
<li><p>如果 features.MSI_FLAT 为 1，则 IOMMU 使用扩展格式设备上下文。令DDI[0]为device_id[5:0]，DDI[1]为device_id[14:6]，DDI[2]为device_id[23:15]。</p>
</li>
<li><p>如果 device_id 比 IOMMU 模式支持的宽（通过以下检查确定），则停止并报告“事务类型不允许”（原因 &#x3D; 260）。</p>
<ol>
<li>ddtp.iommu_mode 为 2LVL 并且 DDI[2] 不为 0</li>
<li>ddtp.iommu_mode 为 1LVL 并且 DDI[2] 不为 0 或 DDI[1] 不为 0</li>
</ol>
</li>
<li><p>然后使用 device_id 来定位设备上下文 (DC)，如第 2.3.1 节中所指定。</p>
</li>
<li><p>如果满足以下任一条件，则停止并报告“事务类型不允许”（原因 &#x3D; 260）。</p>
<ol>
<li>事务类型是转换请求（读取、写入&#x2F;AMO、读取执行）或者是 PCIe ATS 转换请求且 DC.tc.EN_ATS 为 0。</li>
<li>事务具有有效的 process_id 并且 DC.tc.PDTV 为 0。</li>
<li>事务具有有效的 process_id，DC.tc.PDTV 为 1，并且 process_id 比 pdtp.MODE 支持的更宽。</li>
<li>IOMMU 不支持事务类型。</li>
</ol>
</li>
<li><p>如果请求是翻译请求并且 DC.tc.T2GPA 为 0，则翻译过程完成。转至步骤 20。</p>
</li>
<li><p>如果请求是翻译请求并且 DC.tc.T2GPA 为 1，则 IOVA 是 GPA。使用以下页表信息转至步骤 17：</p>
<ol>
<li>令 A 为 IOVA（IOVA 是 GPA）。</li>
<li>让 iosatp.MODE 为 Bare<ol>
<li>当第一阶段为 Bare 时，不使用 PSCID 值。</li>
</ol>
</li>
<li>令 iohgatp 为 DC.iohgatp 字段中的值</li>
</ol>
</li>
<li><p>如果 DC.tc.PDTV 设置为 0，则使用以下页表信息转至步骤 17：</p>
<ol>
<li>令 iosatp.MODE 为 DC.fsc.MODE 字段中的值</li>
<li>令 iosatp.PPN 为 DC.fsc.PPN 字段中的值</li>
<li>令 PSCID 为 DC.ta.PSCID 字段中的值</li>
<li>令 iohgatp 为 DC.iohgatp 字段中的值</li>
</ol>
</li>
<li><p>如果 DPE 为 1 并且没有与事务关联的 process_id，则让 process_id 为默认值 0。</p>
</li>
<li><p>如果 DPE 为 0 并且没有与事务关联的 process_id，则使用以下页表信息转到步骤 17：</p>
<ol>
<li>让 iosatp.MODE 为 Bare<ol>
<li>当第一阶段为 Bare 时，不使用 PSCID 值。</li>
</ol>
</li>
<li>令 iohgatp 为 DC.iohgatp 字段中的值</li>
</ol>
</li>
<li><p>如果 DC.fsc.pdtp.MODE &#x3D; Bare，则使用以下页表信息转至步骤 17：</p>
<ol>
<li>让 iosatp.MODE 为 Bare<ol>
<li>当第一阶段为 Bare 时，不使用 PSCID 值。</li>
</ol>
</li>
<li>令 iohgatp 为 DC.iohgatp 字段中的值</li>
</ol>
</li>
<li><p>找到第 2.3.2 节中指定的进程上下文 (PC)。</p>
</li>
<li><p>如果满足以下任一条件，则停止并报告“事务类型不允许”（原因 &#x3D; 260）。</p>
<ol>
<li>事务请求管理员权限，但未设置 PC.ta.ENS。</li>
</ol>
</li>
<li><p>使用以下页表信息转至步骤 17：</p>
<ol>
<li>令 iosatp.MODE 为 PC.fsc.MODE 字段中的值</li>
<li>令 iosatp.PPN 为 PC.fsc.PPN 字段中的值</li>
<li>令 PSCID 为 PC.ta.PSCID 字段中的值</li>
<li>令 iohgatp 为 DC.iohgatp 字段中的值</li>
</ol>
</li>
<li><p>使用 RISC-V 特权规范 [3] 的“两级地址转换”部分中指定的过程来确定事务访问的 GPA。如果第一级地址转换过程检测到故障，则停止并报告故障。如果翻译过程成功完成，则令 A 为翻译后的 GPA</p>
</li>
<li><p>如果启用了使用 MSI 页表的 MSI 地址转换（即 DC.msiptp.MODE !&#x3D; Off），则调用第 2.3.3 节中指定的 MSI 地址转换过程。如果 GPA A 未被确定为虚拟中断文件的地址，则该过程继续到步骤 19。如果 MSI 地址转换过程检测到故障，则停止并报告该故障，否则该过程继续到步骤 20。</p>
</li>
<li><p>使用RISC-V特权规范[3]的“两阶段地址转换”部分中指定的第二阶段地址转换过程来转换GPA A以确定事务访问的SPA。如果地址转换过程检测到故障，则停止并报告故障。</p>
</li>
<li><p>翻译过程已完成</p>
</li>
</ol>
<p>当检查第二阶段 PTE 中的 U 位时，该事务被视为不请求管理员权限。</p>
<p>当转换过程报告故障并且请求是未转换请求或转换请求时，IOMMU请求IO桥中止事务。第 7.3 节提供了处理 IO 桥中故障事务的指南。可以使用第 3.2 节中指定的故障&#x2F;事件报告机制和故障记录格式来报告故障。</p>
<p>如果 PCIe ATS 转换请求检测到故障，则 IOMMU 可以提供 PCIe 协议定义的响应，而不是向软件报告故障或导致中止。故障 PCIe ATS 转换请求的处理在第 2.6 节中指定。</p>
<h3 id="2-3-1-定位设备上下文的过程"><a href="#2-3-1-定位设备上下文的过程" class="headerlink" title="2.3.1.定位设备上下文的过程"></a>2.3.1.定位设备上下文的过程</h3><p>使用 device_id 定位事务的设备上下文的过程如下：</p>
<ol>
<li><p>令 a 为 ddtp.PPN x 2^12^，令 i &#x3D; LEVELS - 1。当 ddtp.iommu_mode 为 3LVL 时，LEVELS 为 3。当ddtp.iommu_mode为2LVL时，LEVELS为2。当ddtp.iommu_mode为1LVL时，LEVELS为1。</p>
</li>
<li><p>如果 i &#x3D;&#x3D; 0 则转至步骤 8。</p>
</li>
<li><p>令 ddte 为地址 a + DDI[i] x 8 处的八个字节的值。如果访问 ddte 违反了 PMA 或 PMP 检查，则停止并报告“DDT 条目加载访问错误”（原因 &#x3D; 257）。</p>
</li>
<li><p>如果 ddte 访问检测到数据损坏（也称为中毒数据），则停止并报告“DDT 数据损坏”（原因 &#x3D; 268）。</p>
</li>
<li><p>如果 ddte.V &#x3D;&#x3D; 0，则停止并报告“DDT 条目无效”（原因 &#x3D; 258）。</p>
</li>
<li><p>如果在 ddte 中设置了为将来标准使用保留的任何位或编码，则停止并报告“DDT 条目配置错误”（原因 &#x3D; 259）。</p>
</li>
<li><p>令 i &#x3D; i - 1 并令 a &#x3D; ddte.PPN x 2^12^。转至步骤 2。</p>
</li>
<li><p>令 DC 为地址 a + DDI[0] * DC_SIZE 处的 DC_SIZE 字节的值。如果功能.MSI_FLAT 为 1，则 DC_SIZE 为 64 字节，否则为 32 字节。如果访问 DC 违反了 PMA 或 PMP 检查，则停止并报告“DDT 条目加载访问故障”（原因 &#x3D; 257）。如果 DC 访问检测到数据损坏（也称为中毒数据），则停止并报告“DDT 数据损坏”（原因 &#x3D; 268）。</p>
</li>
<li><p>如果 DC.tc.V &#x3D;&#x3D; 0，则停止并报告“DDT 条目无效”（原因 &#x3D; 258）。</p>
</li>
<li><p>如果根据第 2.1.4 节中概述的规则确定 DC 配置错误，则停止并报告“DDT 条目配置错误”（原因 &#x3D; 259）。</p>
</li>
<li><p>设备上下文已成功定位。</p>
</li>
</ol>
<h3 id="2-3-2-查找进程上下文的进程"><a href="#2-3-2-查找进程上下文的进程" class="headerlink" title="2.3.2.查找进程上下文的进程"></a>2.3.2.查找进程上下文的进程</h3><p>设备上下文提供 PDT 根页面 PPN (pdtp.ppn)。当 DC.iohgatp.mode 不是 Bare 时，pdtp.PPN 以及 pdte.PPN 是Guest 物理地址 (GPA)，必须使用 DC.iohgatp 指向的第二阶段页表将其转换为管理员物理地址 (SPA) 。对 PDT 的内存访问被第二阶段视为隐式读内存访问。</p>
<p>使用 process_id 查找事务的 Process-context 的过程如下：</p>
<ol>
<li><p>令 a 为 pdtp.PPN x 2^12^，并令 i &#x3D; LEVELS - 1。当 pdtp.MODE 为 PD20 时，LEVELS 为 3。当 pdtp.MODE 为 PD17 时，LEVELS 为 2。当 pdtp.MODE 为 PD8 时，LEVELS 为 1。</p>
</li>
<li><p>如果 DC.iohgatp.mode !&#x3D; Bare，则 a 是 GPA。调用进程将 a 转换为 SPA 作为隐式内存访问。如果在第二阶段地址转换过程中发生故障，则停止并报告第二阶段地址转换过程检测到的故障。翻译后的 a 用于后续步骤</p>
</li>
<li><p>如果 i &#x3D;&#x3D; 0，则转至步骤 9。</p>
</li>
<li><p>令 pdte 为地址 a + PDI[i] x 8 处的八个字节的值。如果访问 pdte 违反了 PMA 或 PMP 检查，则停止并报告“PDT 条目加载访问错误”（原因 &#x3D; 265）。</p>
</li>
<li><p>如果 pdte 访问检测到数据损坏（也称为中毒数据），则停止并报告“PDT 数据损坏”（原因 &#x3D; 269）。</p>
</li>
<li><p>如果 pdte.V &#x3D;&#x3D; 0，则停止并报告“PDT 条目无效”（原因 &#x3D; 266）。</p>
</li>
<li><p>如果在 pdte 内设置了为将来标准使用保留的任何位或编码，则停止并报告“PDT 条目配置错误”（原因 &#x3D; 267）。</p>
</li>
<li><p>令 i &#x3D; i - 1 并令 a &#x3D; pdte.PPN x 2^12^。转至步骤 2。</p>
</li>
<li><p>令 PC 为地址 a + PDI[0] x 16 处 16 字节的值。如果访问 PC 违反了 PMA 或 PMP 检查，则停止并报告“PDT 条目加载访问错误”（原因 &#x3D; 265）。如果 PC 访问检测到数据损坏（也称为中毒数据），则停止并报告“PDT 数据损坏”（原因 &#x3D; 269）。</p>
</li>
<li><p>如果 PC.ta.V &#x3D;&#x3D; 0，则停止并报告“PDT 条目无效”（原因 &#x3D; 266）。</p>
</li>
<li><p>如果根据第 2.2.4 节中概述的规则确定 PC 配置错误，则停止并报告“PDT 条目配置错误”（原因 &#x3D; 267）。</p>
</li>
<li><p>进程上下文已成功定位。</p>
</li>
</ol>
<h3 id="2-3-3-转换-MSI-地址的过程"><a href="#2-3-3-转换-MSI-地址的过程" class="headerlink" title="2.3.3.转换 MSI 地址的过程"></a>2.3.3.转换 MSI 地址的过程</h3><p>当 I&#x2F;O 设备由Guest OS直接配置时，来自该设备的 MSI 预计将定位到Guest OS虚拟机内的虚拟 IMSIC，使用对真实机器不合适且不安全的Guest physical address。 IOMMU 必须识别来自 MSI 等设备的某些传入写入，并根据实际机器的需要进行转换。</p>
<p>源自需要转换的单个设备的 MSI 预计已由在一个 RISC-V 虚拟机中运行的单个Guest OS在设备上进行配置。假设VM本身符合RISC-V高级中断架构[2]，则通过写入虚拟IMSIC的中断文件的内存映射寄存器，将MSI发送到VM内的虚拟hart。这些虚拟中断文件中的每一个都在虚拟机的Guest physical address空间中占用一个单独的 4-KiB 页，与真实中断文件在真实机器的物理地址空间中的情况相同。因此，如果写入是针对VM内的虚拟IMSIC的中断文件占用的页面，则对Guest physical addresses的写入可以被识别为虚拟hart的MSI。</p>
<p>当支持 MSI 地址转换时（功能.MSI_FLAT，第 5.3 节），将传入 IOVA 识别为虚拟中断文件的地址并使用 MSI 页表转换该地址的过程如下：</p>
<ol>
<li><p>令 A 为 GPA </p>
</li>
<li><p>令 DC 为设备上下文，使用设备的 device_id 使用第 2.3.1 节中概述的过程进行定位。</p>
</li>
<li><p>确定地址 A 是否是对第 2.1.3.6 节中指定的虚拟中断文件的访问。</p>
</li>
<li><p>如果该地址未被确定为虚拟中断文件的地址，则停止该过程并改为使用常规转换数据结构来进行地址转换。</p>
</li>
<li><p>从 A 中提取中断文件号 I，因为 I &#x3D; extract(A &gt;&gt; 12, DC.msi_addr_mask)。位提取函数 extract(x, y) 丢弃 x 中掩码 y 中相同位置的匹配位为零的所有位，并将 x 中的剩余位连续打包在结果的最低有效端，保持相同的位顺序作为 x 并用零填充结果最高有效端的任何其他位。例如，如果 x 和 y 的位是：</p>
<ul>
<li>x &#x3D; a b c d e f g h </li>
<li>y &#x3D; 1 0 1 0 0 1 1 0 </li>
<li>则 extract(x, y) 的值具有位 0 0 0 0 a c f g。</li>
</ul>
</li>
<li><p>令 m 为 (DC.msiptp.PPN x 2^12^)。</p>
</li>
<li><p>令 msipte 为地址 (m | (I x 16)) 处 16 个字节的值。如果访问 msipte 违反了 PMA 或 PMP 检查，则停止并报告“MSI PTE 加载访问故障”（原因 &#x3D; 261）。</p>
</li>
<li><p>如果 msipte 访问检测到数据损坏（也称为中毒数据），则停止并报告“MSI PT 数据损坏”（原因 &#x3D; 270）。</p>
</li>
<li><p>如果 msipte.V &#x3D;&#x3D; 0，则停止并报告“MSI PTE 无效”（原因 &#x3D; 262）。</p>
</li>
<li><p>如果 msipte.C &#x3D;&#x3D; 1，则解释 PTE 的进一步处理由实现定义。</p>
</li>
<li><p>如果 msipte.C &#x3D;&#x3D; 0，则该过程将在后续步骤中概述。</p>
</li>
<li><p>如果 msipte.M &#x3D;&#x3D; 0 或 msipte.M &#x3D;&#x3D; 2，则停止并报告“MSI PTE 错误配置”（原因 &#x3D; 263）。</p>
</li>
<li><p>如果 msipte.M &#x3D;&#x3D; 3，则 PTE 处于基本翻译模式，翻译过程如下：</p>
<ol>
<li>如果在 msipte 内设置了为未来标准使用保留的任何位或编码，则停止并报告“MSI PTE 错误配置”（原因 &#x3D; 263）。</li>
<li>将转换后的地址计算为 msipte.PPN &lt;&lt; 12 |A[11:0]。</li>
</ol>
</li>
<li><p>如果 msipte.M &#x3D;&#x3D; 1，则 PTE 处于 MRIF 模式，翻译过程如下：</p>
<ol>
<li>如果capabilities.MSI_MRIF &#x3D;&#x3D; 0，则停止并报告“MSI PTE 配置错误”（原因 &#x3D; 263）。</li>
<li>如果在 msipte 内设置了为未来标准使用保留的任何位或编码，则停止并报告“MSI PTE 错误配置”（原因 &#x3D; 263）。</li>
<li>目标 MRIF 的地址为 msipte.MRIF_Address[55:9] * 512。</li>
<li>通知 MSI 的目标地址为 msipte.NPPN &lt;&lt; 12。</li>
<li>令 NID 为 (msipte.N10 &lt;&lt; 10) |msipte.N[9:0]。通知MSI的数据值是11位NID值零扩展至32位。</li>
</ol>
</li>
<li><p>通过此过程确定的与翻译相关的访问权限相当于常规 RISC-V 第二阶段 PTE（R&#x3D;W&#x3D;U&#x3D;1 且 X&#x3D;0）的访问权限。与第二阶段 PTE 类似，当检查 U 位时，该事务被视为不请求管理员权限。</p>
</li>
<li><p>如果事务是未翻译或翻译的读取执行，则停止并报告“指令访问错误”（原因 &#x3D; 1）。</p>
</li>
<li><p>MSI地址转换过程完成。</p>
</li>
</ol>
<blockquote>
<p>在 MRIF 模式下，高级中断架构规范定义了将传入 MSI 存储到目标 MRIF 并生成通知 MSI 的操作。这些操作可以由IOMMU本身执行，或者IOMMU可以响应于转换请求向I&#x2F;O桥提供目的地MRIF地址、通知MSI地址和通知MSI数据值，并且这些操作可以由IOMMU执行。输入&#x2F;输出桥。</p>
</blockquote>
<h2 id="2-4-IOMMU-更新-PTE-访问的-A-和脏的-D-更新"><a href="#2-4-IOMMU-更新-PTE-访问的-A-和脏的-D-更新" class="headerlink" title="2.4. IOMMU 更新 PTE 访问的 (A) 和脏的 (D) 更新"></a>2.4. IOMMU 更新 PTE 访问的 (A) 和脏的 (D) 更新</h2><p>当capability.AMO_HWAD为1时，IOMMU支持原子更新PTE中的A和D位。当启用第二阶段 PTE 中的 A 和 D 位更新 (DC.tc.GADE&#x3D;1) 和&#x2F;或启用第一阶段 PTE 中的 A 和 D 位更新 (DC.tc.SADE&#x3D;1) 时，以下情况规则适用：</p>
<ol>
<li>IOMMU 的 A 和&#x2F;或 D 位更新必须遵循特权规范指定的有效性、权限检查和原子性规则。</li>
<li>在使用 IOMMU 提供的转换地址进行内存访问变得全局可见之前，PTE 更新必须是全局可见的。具体而言，当在 ATS 转换完成中将转换后的地址提供给设备时，在使用转换后的地址从设备进行的存储器访问变得全局可见之前，PTE 更新必须是全局可见的。</li>
</ol>
<blockquote>
<p>A 和 D 位永远不会被 IOMMU 清除。如果监控软件不依赖于访问和&#x2F;或脏位，例如如果它不将内存页交换到辅助存储，或者如果这些页用于映射 I&#x2F;O 空间，则应在 PTE 中将它们设置为 1 以提高性能。</p>
</blockquote>
<h2 id="2-5-虚拟地址转换过程中的错误"><a href="#2-5-虚拟地址转换过程中的错误" class="headerlink" title="2.5. 虚拟地址转换过程中的错误"></a>2.5. 虚拟地址转换过程中的错误</h2><p>在 RISC-V 特权规范 [3] 中指定的两阶段地址转换期间检测到的故障会导致 IOVA 转换过程停止并报告检测到的故障。</p>
<h2 id="2-6-PCIe-ATS-转换请求处理"><a href="#2-6-PCIe-ATS-转换请求处理" class="headerlink" title="2.6. PCIe ATS 转换请求处理"></a>2.6. PCIe ATS 转换请求处理</h2><p>遇到配置错误的 ATS [1] 转换请求会导致对请求者的完成者中止 (CA) 响应。以下原因代码属于此类：</p>
<ul>
<li>指令访问故障（原因&#x3D; 1） </li>
<li>读取访问故障（原因&#x3D; 5） </li>
<li>写入&#x2F;AMO 访问故障（原因&#x3D; 7） </li>
<li>MSI PTE 加载访问故障（原因&#x3D; 261） </li>
<li>MSI PTE 配置错误（原因&#x3D; 263） </li>
<li>PDT 条目加载访问故障（原因 &#x3D; 265） </li>
<li>PDT 条目配置错误（原因 &#x3D; 267）</li>
</ul>
<p>如果存在永久性错误或 ATS 事务被禁用，则会生成不支持的请求 (UR) 响应。以下原因代码属于此类：</p>
<ul>
<li>不允许所有入站事务（原因 &#x3D; 256） </li>
<li>DDT 条目加载访问错误（原因 &#x3D; 257） </li>
<li>DDT 条目无效（原因 &#x3D; 258） </li>
<li>DDT 条目配置错误（原因 &#x3D; 259） </li>
<li>不允许事务类型（原因 &#x3D; 260）</li>
</ul>
<p>当由于以下原因导致转换无法完成时，会生成 R 和 W 位设置为 0 的成功响应。这些错误的故障队列中不会记录任何故障。此类完成返回的翻译地址是未指定的(UNSPECIFIED)。	</p>
<ul>
<li>指令页错误（原因 &#x3D; 12） </li>
<li>读取页错误（原因 &#x3D; 13） </li>
<li>写入&#x2F;AMO 页错误（原因 &#x3D; 15） </li>
<li>指令Guest page fault（原因 &#x3D; 20） </li>
<li>读取Guest page fault（原因 &#x3D; 21） </li>
<li>写入&#x2F;AMO Guest page fault（原因 &#x3D; 23） </li>
<li>PDT 条目无效（原因 &#x3D; 266） </li>
<li>MSI PTE 无效（原因 &#x3D; 262）</li>
</ul>
<p>如果转换请求具有“请求的特权模式”字段设置为 0 的 PASID，或者请求没有 PASID，则该请求不以特权内存为目标。如果指示存储器是否可由用户模式访问的 U 位为 0，则生成 R 和 W 位设置为 0 的成功响应。</p>
<p>如果转换请求的 PASID 的“请求的特权模式”字段设置为 1，则该请求的目标是特权内存。如果指示该页是否可由用户模式访问的 U 位为 1，并且进程上下文的 ta 字段中的 SUM 位为 0，则生成 R 和 W 位设置为 0 的成功响应。</p>
<p>如果转换可以成功完成，但所请求的权限不存在（已请求执行，但无执行权限；未请求无写且无写权限；无读取权限），则返回成功响应，并拒绝权限（R、W或 X) 设置为 0，其他权限位设置为从页表确定的值。仅当同时授予 R 权限时，才会授予 X 权限。仅执行转换与 PCIe ATS 不兼容，因为如果授予执行权限，则 PCIe 需要授予读取权限。</p>
<p>当为 ATS 转换请求生成成功响应时，即使响应指示未授予访问权限或某些权限被拒绝，也不会通过故障&#x2F;事件报告机制向软件报告任何故障记录。</p>
<p>如果使用第 2.1.3.6 节定义的规则将转换请求的地址确定为 MSI 地址，但 MSI PTE 配置为 MRIF 模式，则会生成成功响应，其中 R、W 和 U 位设置为 1。响应中 U 位设置为 1，指示设备只能使用未翻译的请求来访问隐含的 4 KiB 内存范围。</p>
<blockquote>
<p>当 MSI PTE 配置为 MRIF 模式时，具有数据值 D 的 MSI 写入要求 IOMMU 设置 MRIF 中中断标识 D 的中断挂起位。从设备到通过 MRIF 模式 MSI PTE 映射的 GPA 的转换请求不符合接收转换后的地址的条件。这是通过将返回响应的“Untranslated Access Only”(U) 字段设置为 1 来实现的。</p>
</blockquote>
<p>当 ATS 翻译请求生成成功响应时，Priv、N、CXL.io、Global 和 AMA 字段的设置如下：</p>
<ul>
<li><p>如果请求没有PASID，则ATS 转换完成的Priv 字段始终设置为0。当存在 PASID 时，Priv 字段将设置为“请求的权限模式”字段中的值，因为提供的权限对应于请求中权限模式指示的权限。</p>
</li>
<li><p>ATS 转换完成的N 字段始终设置为0。设备可以使用其他方式来确定是否应在转换的请求中设置No-snoop 标志。</p>
</li>
<li><p>如果转换可以成功完成并且请求存在PASID，则全局字段设置为从第一阶段页表确定的值。在所有其他情况下，包括 MSI 地址转换，该字段设置为 0。</p>
</li>
<li><p>如果请求设备不是 CXL 设备，则 CXL.io 设置为 0。</p>
</li>
<li><p>如果请求设备是 CXL 类型 1 或类型 2 设备 ◦ 如果确定地址是 MSI，则 CXL.io 位设置为 1。</p>
</li>
<li><p>否则，如果设备上下文中的 T2GPA 为 1，则 CXL.io 位设置为 1。</p>
</li>
<li><p>否则，如果由 Svpbmt 扩展确定的内存类型为 NC 或 IO，则 CXL.io 位设置为 1。如果内存类型为 PMA，则该位设置的确定为 UNSPECIFIED。如果不支持 Svpbmt 扩展，则该位的设置为未指定。</p>
</li>
<li><p>在所有其他情况下，该位的设置是未指定的。</p>
</li>
<li><p>AMA 字段默认设置为000b。 IOMMU 可以支持特定于实现的方法来提供其他编码。</p>
</li>
</ul>
<blockquote>
<p>IO桥可以基于转换地址的PMA覆盖ATS转换完成中的CXL.io位。其他实现可以提供实现定义的方法，用于确定转换地址的 PMA 以设置 CXL.io 位。</p>
<p>使用设置为 1 的 T2GPA 可能与 CXL 类型 1 或类型 2 设备不兼容，因为它们使用 CXL.cache 协议来实现由响应 PCIe ATS 转换请求而返回的转换地址标记的缓存。不能调用 IOMMU 来转换 CXL.cache 事务中的地址。</p>
</blockquote>
<h2 id="2-7-PCIe-ATS-页面请求处理"><a href="#2-7-PCIe-ATS-页面请求处理" class="headerlink" title="2.7. PCIe ATS 页面请求处理"></a>2.7. PCIe ATS 页面请求处理</h2><p>为了处理“页面请求”或“停止标记”消息 [1]，IOMMU 首先定位设备上下文以确定是否为请求者启用了 ATS 和 PRI。如果启用了 ATS 和 PRI，即EN_ATS 和 EN_PRI 均设置为 1，IOMMU 将消息排队到称为页面请求队列 (PQ) 的内存队列中（请参见第 3.3 节）。在对“页面请求”进行适当处理之后，软件处理程序可以向设备生成“页面请求组响应”消息。</p>
<p>当设备启用 PRI 时，由于队列被禁用、队列已满或 IOMMU 遇到访问故障等错误情况，IOMMU 仍然无法通过 PQ 报告“页面请求”或“停止标记”消息当尝试访问队列内存时。这些错误条件在第 3.3 节中指定。</p>
<p>如果 ddtp.iommu_mode 为 Bare 或 Off，则 IOMMU 无法为请求者找到设备上下文。</p>
<p>如果 EN_PRI 设置为 0，或 EN_ATS 设置为 0，或者 IOMMU 无法找到 DC 来确定 EN_PRI 配置，或者请求无法在 PQ 中排队，则 IOMMU 行为取决于“页面”的类型。要求”。</p>
<ul>
<li><p>如果“页面请求”不需要响应，即消息的“PRG 中的最后请求”字段设置为 0，则此类消息将被静默丢弃。 “停止标记”消息不需要响应，并且总是在发生此类错误时默默地丢弃。</p>
</li>
<li><p>如果“页面请求”需要响应，则IOMMU 本身可以向设备生成“页面请求组响应”消息。</p>
</li>
</ul>
<p>当 IOMMU 生成响应时，响应的状态字段取决于错误原因。</p>
<p>如果遇到以下故障，状态将设置为“响应失败”：</p>
<ul>
<li>ddtp.iommu_mode 关闭 </li>
<li>DDT 条目加载访问故障（原因 &#x3D; 257） </li>
<li>DDT 条目配置错误（原因 &#x3D; 259） </li>
<li>DDT 条目无效（原因 &#x3D; 258） </li>
<li>页面请求队列未启用（pqcsr.pqen &#x3D;&#x3D; 0 或 pqcsr.pqon &#x3D;&#x3D; 0) </li>
<li>页面请求队列遇到内存访问故障 (pqcsr.pqmf &#x3D;&#x3D; 1)</li>
</ul>
<p>如果遇到以下错误，状态将设置为 Invalid Request：</p>
<ul>
<li>ddtp.iommu_mode 为 Bare </li>
<li>EN_PRI 设置为 0</li>
</ul>
<p>如果没有遇到其他错误，但由于页面请求队列已满 (pqt &#x3D;&#x3D; pqh - 1) 或溢出 (pqcsr.pqof &#x3D;&#x3D; 1，“页面请求”无法排队)，则状态设置为成功）。</p>
<blockquote>
<p>当 SR-IOV VF 用作分配单元时，管理程序可以通过将 EN_PRI 设置为 0 来禁用来自虚拟功能之一的页面请求。但是，页面请求接口由 PF 和所有 VF 共享。 IOMMU 协议特定逻辑在其响应中将此情况（原因 &#x3D; 260）分类为非灾难性故障（无效请求），以避免设备中的共享 PRI 对所有 PF&#x2F;VF 禁用。</p>
<p>“停止标记”被编码为具有 PASID 的“页面请求”，但 L、W 和 R 字段分别设置为 1、0 和 0。</p>
</blockquote>
<p>对于状态为“无效请求”或“成功”的 IOMMU 生成的“页面请求组响应”消息，PRG 响应 PASID 要求 (PRPR) 位设置为 1 时指示 IOMMU 响应消息应包含 PASID，如果关联的“页面请求”有一个 PASID。</p>
<p>对于 IOMMU 生成的响应代码设置为响应失败的“页面请求组响应”，如果“页面请求”具有 PASID，则将生成带有 PASID 的响应。</p>
<p>对于以下情况，PCIe ATS“页面请求”消息的故障队列中不会记录任何故障：</p>
<ul>
<li>页面请求队列未启用（pqcsr.pqen &#x3D;&#x3D; 0 或 pqcsr.pqon &#x3D;&#x3D; 0） </li>
<li>页面请求队列遇到内存访问错误（pqcsr.pqmf &#x3D;&#x3D; 1） </li>
<li>“页面请求”无法排队由于页面请求队列已满（pqt &#x3D;&#x3D; pqh - 1）或溢出（pqcsr.pqof &#x3D;&#x3D; 1）。</li>
</ul>
<h2 id="2-8-缓存内存中的数据结构"><a href="#2-8-缓存内存中的数据结构" class="headerlink" title="2.8.缓存内存中的数据结构"></a>2.8.缓存内存中的数据结构</h2><p>为了加速直接内存访问（DMA）转换，IOMMU可以利用转换高速缓存来保存来自设备目录表、进程目录表、第一阶段和第二阶段转换表以及MSI页表的条目。这些缓存统称为 IOMMU 地址转换缓存 (IOATC)。</p>
<p>该规范不允许缓存 V（有效）位清零的第一&#x2F;第二阶段 PTE、V（有效）位清零的非叶 DDT 条目、V（有效）位清零的设备上下文、非叶 DDT 条目。 -V（有效）位清零的叶 PDT 条目、V（有效）位清零的进程上下文或 V 位清零的 MSI PTE。</p>
<p>这些 IOATC 不会观察到通过 RISC-V 硬件或设备 DMA 使用显式加载和存储对内存数据结构进行的修改。软件必须使用 IOMMU 命令使缓存的数据结构条目无效，使用 IOMMU 命令同步 IOMMU 操作以观察内存中数据结构的更新。更简单的实现可能不会为某些或任何内存中数据结构实现 IOATC。 IOMMU命令可以使用一个或多个ID来标记高速缓存的条目以识别特定条目或一组条目。</p>
<p>表 6. 用于标记 IOATC 条目的标识符</p>
<table>
    <tr>
        <th>Data Structure cached <br>缓存的数据结构 </th>
        <th>IDs used to tag entries<br>用于标记条目的 ID </th>
        <th>Invalidation command<br>失效命令 </th>
    </tr>
    <tr>
        <td>设备目录表</td>
        <td><font color="red">device_id</font></td>
        <td>IODIR.INVAL_DDT</td>
    </tr>
    <tr>
        <td>进程目录表</td>
        <td><font color="red">device_id, process_id</font></td>
        <td>IODIR.INVAL_DDT</td>
    </tr>
    <tr>
        <td>第一阶段页表（当第二阶段不是Bare时）</td>
        <td><font color="red">GSCID, PSCID</font>, and IOVA</td>
        <td>IOTINVAL.VMA</td>
    </tr>
    <tr>
        <td>第一阶段页表（第二阶段为Bare时）</td>
        <td><font color="red">PSCID</font>, and IOVA</td>
        <td>IOTINVAL.VMA</td>
    </tr>
    <tr>
        <td>第二阶段页表</td>
        <td><font color="red">GSCID, GPA</font></td>
        <td>IOTINVAL.GVMA</td>
    </tr>
    <tr>
        <td>MSI页表</td>
        <td><font color="red">GSCID, GPA</font></td>
        <td>IOTINVAL.GVMA</td>
    </tr>
</table>

<h2 id="2-9-更新内存数据结构条目"><a href="#2-9-更新内存数据结构条目" class="headerlink" title="2.9.更新内存数据结构条目"></a>2.9.更新内存数据结构条目</h2><p>RISC-V 内存模型要求 hart 的内存访问是单副本原子的。当实现 RV32 时，单副本原子内存访问的大小最多为 32 位。当实现 RV64 时，单副本原子内存访问的大小最多为 64 位。 IOMMU 实现的单副本原子内存访问的大小未指定，但如果系统中的所有 hart 实现 RV32，则要求至少为 32 位；如果系统中的任何 hart 实现，则要求至少为 64 位。系统实现RV64。</p>
<p>IOMMU 数据结构条目有一个 V 位，当设置为 1 时表示该条目有效。</p>
<p>软件可以对 V 位设置为 1 的数据结构条目进行更新。但是，必须遵循下面列出的一些规则。</p>
<ul>
<li><p>软件使用一组宽度小于 IOMMU 支持的最小单副本原子内存访问的存储来更新有效数据结构条目的字段通常是不安全的，因为 IOMMU 在任何时间读取该条目都是合法的。时间，包括只有部分商店生效的时间。</p>
</li>
<li><p>为了使IOMMU 数据结构条目的更新具有原子性，软件必须使用宽度等于IOMMU 支持的最小单副本原子内存访问的单个存储。</p>
</li>
<li><p>如果对某个字段的更新会使该字段与条目的另一个字段不一致，则软件必须首先将 V 字段设置为 0，并使用第 2.8 节中概述的命令使 IOMMU 缓存中可能存在的该条目的任何先前副本无效在更新该条目的其他字段之前。</p>
</li>
<li><p>IOMMU 不需要立即观察条目的软件更新。软件必须使用第 2.8 节中概述的命令来使 IOMMU 缓存中可能存在的该条目的任何先前副本无效，以将条目的更新与 IOMMU 的操作同步。</p>
</li>
</ul>
<p>如果数据结构条目发生更改，IOMMU 可能会使用条目的旧值或条目的新值，并且选择是不可预测的，直到软件使用第 2.8 节中概述的命令使该条目的任何先前副本无效（这些副本可能会被修改）。在 IOMMU 缓存中，以将条目的更新与 IOMMU 的操作同步。这些是唯一预期的行为。</p>
<h2 id="2-10-内存数据结构的字节顺序"><a href="#2-10-内存数据结构的字节顺序" class="headerlink" title="2.10.内存数据结构的字节顺序"></a>2.10.内存数据结构的字节顺序</h2><p>RISC-V 内存模型指定整个地址空间的字节不变性。当支持混合端操作模式时，IO 桥和 IOMMU 必须实现字节不变寻址，以便对给定地址的字节访问在小端和大端操作模式下访问相同的内存位置。</p>
<p>对内存中数据结构的隐式内存访问的字节顺序由 fctl.BE 或 DC.tc.SBE 确定，如下所示：</p>
<p>表 7. 内存访问数据结构的字节顺序</p>
<table>
    <tr>
        <th> Data Structure </th>
        <th> Controlled by </th>
    </tr>
    <tr>
        <td>Device directory table 设备目录表</td>
        <td><font color="red">fctl.BE</font></td>
    </tr>
    <tr>
        <td>Second-stage page table 第二阶段页表</td>
        <td><font color="red">fctl.BE</font></td>
    </tr>
    <tr>
        <td>MSI page table MSI页表</td>
        <td><font color="red">fctl.BE</font></td>
    </tr>
    <tr>
        <td>Process directory Table 进程目录表</td>
        <td><font color="red">DC.tc.SBE</font></td>
    </tr>
    <tr>
        <td>First-stage page table 第一阶段页表</td>
        <td><font color="red">DC.tc.SBE</font></td>
    </tr>
</table>

<blockquote>
<p>第一阶段上下文的 PSCID 字段与 GSCID（当两阶段地址转换处于活动状态时）一起标识地址空间。预计不会在两个 DC 中配置相同的 GSCID 和 PSCID 但具有不同的 SBE，如果这样做，可能会导致 IOMMU 将第一阶段 PTE 解释为大端或小端。这些是唯一预期的行为。</p>
</blockquote>
<blockquote>
<p>当与不共享字节序的 IO 代理共享数据时，软件必须使用适当的软件序列根据需要交换字节，以创建双方同意的数据表示形式。当必须以原子方式访问与此类 IO 代理共享的数据时，软件必须使用 LR&#x2F;SC 序列以非本机字节序格式执行原子操作。</p>
</blockquote>
<h1 id="第-3-章-内存队列接口"><a href="#第-3-章-内存队列接口" class="headerlink" title="第 3 章 内存队列接口"></a>第 3 章 内存队列接口</h1><p>软件和 IOMMU 使用 3 个内存队列数据结构进行交互。</p>
<ul>
<li><p>软件使用命令队列(CQ) 将命令排队到IOMMU。</p>
</li>
<li><p>IOMMU 使用故障&#x2F;事件队列 (FQ) 来引起软件注意故障和事件。</p>
</li>
<li><p>IOMMU 使用页面请求队列(PQ) 来报告从PCIe 设备接收到的“页面请求”消息。如果 IOMMU 支持 PCIe [1] 定义的页面请求接口，则支持此队列。</p>
</li>
</ul>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808162821338-1730797861485-55.png" alt="image-20230808162821338"></p>
<p>图 28. IOMMU 内存中队列</p>
<p>每个队列都是一个循环缓冲区，其头部由队列中数据的使用者控制，尾部由队列中数据的生产者控制。 IOMMU 是 PQ 和 FQ 记录的生成者并控制尾寄存器。 IOMMU 是软件生成到 CQ 中的命令的使用者，并控制头寄存器。尾寄存器保存队列中的索引，生产者将在该队列中写入下一个条目。头寄存器保存队列的索引，消费者将在其中读取下一个条目以进行处理。</p>
<p>如果头部等于尾部，则队列为空。如果尾部是头部减一，则队列已满。当头部和尾部到达循环缓冲区的末尾时，它们会环绕。</p>
<p>数据的生产者必须确保写入队列的数据和尾部更新是有序的，以便观察尾部寄存器更新的消费者也必须观察在由头部和尾部确定的偏移量之间产生到队列中的所有数据。</p>
<blockquote>
<p>所有 RISC-V IOMMU 实现都需要支持位于主内存中的内存队列。支持 I&#x2F;O 内存中的内存队列不是必需的，但本规范并不禁止。</p>
</blockquote>
<h2 id="3-1-命令队列-CQ"><a href="#3-1-命令队列-CQ" class="headerlink" title="3.1.命令队列 (CQ)"></a>3.1.命令队列 (CQ)</h2><p>软件使用命令队列对要由 IOMMU 处理的命令进行排队。每个命令为 16 字节。</p>
<p>该内存队列的基址的 PPN 和队列的大小被配置到称为命令队列基址 (cqb) 的内存映射寄存器中。</p>
<p>命令队列的尾部驻留在软件控制的读&#x2F;写内存映射寄存器中，称为命令队列尾部 (cqt)。 cqt 是软件将写入的下一个命令队列条目的索引。在写入命令之后，软件通过写入命令的数量来推进 cqt。</p>
<p>命令队列的头部驻留在只读内存映射 IOMMU 控制的寄存器中，称为命令队列头部 (cqh)。 cqh 是 IOMMU 接下来应处理的命令队列的索引。读取每个命令后，IOMMU 可能会将 cqh 前进 1。如果 cqh &#x3D;&#x3D; cqt，则命令队列为空。如果 cqt &#x3D;&#x3D; (cqh - 1) 命令队列已满。</p>
<p>当错误位或 cqcsr 中的 fence_w_ip 位为 1 时，如果命令队列中断已启用（即 cqcsr.cie 为 1），则 ipsr 中的命令队列中断挂起 (cip) 位将被设置。</p>
<p>IOMMU 命令被分组为由操作码确定的主要命令组，并且在每个组中，func3 字段指定该命令调用的函数。操作码定义操作数字段的格式。这些字段中的一个或多个字段可以由所调用的特定函数使用。操作码编码 64 至 127 指定供定制使用。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808163130662-1730797861485-53.png" alt="image-20230808163130662"></p>
<p>图 29. IOMMU 命令的格式</p>
<p>这些命令被解释为两个 64 位双字。内存中每个双字的字节顺序（小端字节序或大端字节序）是由 fctl.BE（第 5.4 节）确定的字节序。</p>
<p>定义了以下命令操作码：</p>
<table>
    <tr>
        <th>opcode</th>
        <th>Encoding</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>IOTINVAL</td>
        <td>1</td>
        <td>IOMMU 页表缓存失效命令</td>
    </tr>
    <tr>
        <td>IOFENCE</td>
        <td>2</td>
        <td>IOMMU 命令队列栅栏命令</td>
    </tr>
    <tr>
        <td>IOTDIR</td>
        <td>3</td>
        <td>IOMMU 目录缓存失效命令</td>
    </tr>
    <tr>
        <td>ATS</td>
        <td>4</td>
        <td>IOMMU PCIe [1] ATS 命令</td>
    </tr>
    <tr>
        <td>Reserved</td>
        <td>5-63 </td>
        <td>保留供未来标准使用</td>
    </tr>
    <tr>
        <td>Custom</td>
        <td>64-127 </td>
        <td>指定用于定制用途</td>
    </tr>
</table>

<p>命令操作码 0 到 63 的所有未定义功能均保留供未来标准使用。</p>
<p>如果命令使用保留编码或保留位设置为 1，则该命令被确定为非法。如果根据 IOMMU 功能寄存器确定该命令已定义但未实现，则该命令不受支持。如果命令队列获取并解码了非法或不支持的命令，则命令队列将设置 cqcsr.cmd_ill 位并停止处理命令队列中的命令。要重新启用命令处理软件，应通过向 cmd_ill 位写入 1 来清除该位。</p>
<h3 id="3-1-1-IOMMU-页表缓存失效命令"><a href="#3-1-1-IOMMU-页表缓存失效命令" class="headerlink" title="3.1.1. IOMMU 页表缓存失效命令"></a>3.1.1. IOMMU 页表缓存失效命令</h3><p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808164528522-1730797861485-57.png" alt="image-20230808164528522"></p>
<p>IOMMU 操作会导致对 PDT、第一阶段和第二阶段页表的隐式读取。为了减少此类读取的等待时间，IOMMU可以将来自第一级和&#x2F;或第二级页表的条目缓存在IOMMU地址转换高速缓存（IOATC）中。这些缓存可能不会观察到软件对内存中的这些数据结构执行的修改。</p>
<p>IOMMU 转换表高速缓存无效命令 IOTINVAL.VMA 和 IOTINVAL.GVMA 分别将内存中第一阶段和第二阶段页表数据结构的更新与 IOMMU 的操作同步，并使匹配的 IOATC 条目无效。</p>
<p>GV 操作数指示Guest软上下文 ID (GSCID) 操作数是否有效。 PSCV 操作数指示进程软上下文 ID (PSCID) 操作数是否有效。仅允许 IOTINVAL.VMA 将 PSCV 设置为 1。 AV 操作数指示地址 (ADDR) 操作数是否有效。当 GV 为 0 时，将对与主机相关的翻译（即第二阶段为 Bare 的翻译）进行操作。当 GV 为 0 时，忽略 GSCID 操作数。当 AV 为 0 时，ADDR 操作数被忽略。当 PSCV 操作数为 0 时，忽略 PSCID 操作数。</p>
<p>IOTINVAL.VMA 确保在从 IOMMU 到相应第一阶段页表的所有后续隐式读取之前，IOMMU 观察到之前由 hart 对第一阶段页表进行的存储。</p>
<p>表 9. IOTINVAL.VMA 操作数和运算</p>
<table>
    <tr>
        <th>GV</th>
        <th>AV</th>
        <th>PSCV</th>
        <th>Operation</th>
    </tr>
    <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>使所有主机地址空间的所有地址转换缓存条目无效，包括那些包含全局映射的条目。</td>
    </tr>
    <tr>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>使 PSCID 操作数标识的主机地址空间的所有地址转换缓存条目无效，包含全局映射的条目除外。</td>
    </tr>
    <tr>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>对于所有主机地址空间，使包含第一阶段叶页表条目的所有地址转换高速缓存条目无效，包括那些包含全局映射（对应于 ADDR 操作数中的 IOVA）的条目。</td>
    </tr>
    <tr>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>使包含与 ADDR 操作数中的 IOVA 相对应的第一阶段叶页表条目以及与 PSCID 操作数标识的主机地址空间匹配的所有地址转换缓存条目无效，包含全局映射的条目除外。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>对于与 GSCID 操作数关联的所有 VM 地址空间，使所有地址转换缓存条目无效，包括那些包含全局映射的条目。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>使 PSCID 和 GSCID 操作数标识的 VM 地址空间的所有地址转换缓存条目无效，包含全局映射的条目除外。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>对于与 GSCID 操作数关联的所有 VM 地址空间，使包含第一阶段叶页表条目的所有地址转换缓存条目无效，包括包含全局映射的条目（对应于 ADDR 操作数中的 IOVA）。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>对于由 PSCID 和 GSCID 操作数标识的 VM 地址空间，使包含与 ADDR 操作数中的 IOVA 相对应的第一阶段叶页表条目的所有地址转换缓存条目无效，包含全局映射的条目除外。</td>
    </tr>
</table>

<p>IOTINVAL.GVMA 确保在从 IOMMU 到相应第二阶段页表的所有后续隐式读取之前观察到先前对第二阶段页表进行的存储。使用 IOTINVAL.GVMA 将 PSCV 设置为 1 是非法的。</p>
<p>表 10. IOTINVAL.GVMA 操作数和运算</p>
<table>
    <tr>
        <th>GV</th>
        <th>AV</th>
        <th>Openration</th>
    </tr>
    <tr>
        <td>0</td>
        <td>ignored</td>
        <td>对于所有 VM 地址空间，使从任何级别的第二阶段页表缓存的信息无效。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>0</td>
        <td>使从任何级别的第二阶段页表缓存的信息无效，但仅限于由 GSCID 操作数标识的 VM 地址空间。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>使从与 ADDR 操作数中的Guest physical address相对应的叶第二阶段页表条目中缓存的信息无效，仅适用于标识 GSCID 操作数的 VM 地址空间。</td>
    </tr>
</table>

<blockquote>
<p>从概念上讲，一个实现可能包含两个地址转换缓存：一个将Guest虚拟地址映射到Guest physical addresses，另一个将Guest physical addresses映射到管理程序物理地址。 IOTINVAL.GVMA 不需要使前一个缓存无效，但它必须使后一个缓存中与 IOTINVAL.GVMA 地址和 GSCID 操作数匹配的条目无效。</p>
<p>更常见的是，实现包含地址转换缓存，将Guest虚拟地址直接映射到管理程序物理地址，从而消除了间接级别。对于此类实现，任何其Guest虚拟地址映射到与 IOTINVAL.GVMA 地址和 GSCID 参数匹配的Guest physical addresses的条目都必须失效。以这种方式选择性地使条目无效需要使用Guest physical address标记它们，这是昂贵的，因此常见的技术是使与 GSCID 参数匹配的所有条目无效，而不管地址参数如何。</p>
<p>更简单的实现可以忽略 IOTINVAL.VMA 和&#x2F;或 IOTINVAL.GVMA 的操作数，并始终执行所有地址转换条目的全局无效。</p>
</blockquote>
<blockquote>
<p>该规范的结果是，实现可以使用自包含该地址的最新 IOTINVAL 以来在任何时间都有效的地址的任何转换。特别是，如果修改了叶PTE但未执行包含IOTINVAL，则将使用旧翻译或新翻译，但选择是不可预测的。该行为在其他方面是明确定义的。</p>
<p>在传统的TLB设计中，如果例如在没有首先清除原始非叶PTE的有效位并执行IOTINVAL.VMA或IOTINVAL的情况下将页面升级到更大的页面，则多个条目可以匹配单个地址。 GVMA 适用于 AV&#x3D;0。在这种情况下，适用类似的评论：使用旧的非叶 PTE 还是新的叶 PTE 是不可预测的，但行为是明确定义的。</p>
<p>该规范的另一个结果是，使用一组宽度小于 PTE 宽度的存储来更新 PTE 通常是不安全的，因为实现随时读取 PTE 是合法的，包括仅在某些情况下读取 PTE。部分stores已生效。</p>
</blockquote>
<h3 id="3-1-2-IOMMU-命令队列-Fence-命令"><a href="#3-1-2-IOMMU-命令队列-Fence-命令" class="headerlink" title="3.1.2. IOMMU 命令队列 Fence 命令"></a>3.1.2. IOMMU 命令队列 Fence 命令</h3><p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808170133023-1730797861485-59.png" alt="image-20230808170133023"></p>
<p>IOMMU 按顺序从 CQ 获取命令，但 IOMMU 可能会乱序执行获取的命令。 IOMMU 推进 cqh 并不能保证 IOMMU 获取的命令已被执行或提交。</p>
<p>IOFENCE.C 命令完成（由 cqh 前进超过 CQ 中 IOFENCE.C 命令的索引确定）保证从 CQ 获取的所有先前命令均已完成并提交。</p>
<p>如果 IOFENCE.C 在等待指定超时的先前命令完成时超时，则 cqcsr 第 5.15 节中的 cmd_to 位将设置为发出此条件信号。 cqh 保存超时的 IOFENCE.C 的索引，并且所有先前未指定超时的命令均已完成并提交。</p>
<blockquote>
<p>在此版本的规范中，仅指定 ATS.INVAL 命令具有超时。</p>
</blockquote>
<p>这些命令可用于对连接到 IOMMU 的 I&#x2F;O 设备的存储器访问进行排序，如 IOMMU、其他 RISC-V 硬件以及外部设备或协处理器所见。</p>
<p>PR 位设置为 1 时，可用于请求 IOMMU 确保来自已由 IOMMU 处理的设备的所有先前读取请求都提交到全局排序点，以便所有 RISC- 可以观察到它们。系统中的 V hart 和 IOMMU。</p>
<p>当 PW 位设置为 1 时，可用于请求 IOMMU 确保来自已由 IOMMU 处理的设备的所有先前写请求都提交到全局排序点，以便所有 RISC- 可以观察到它们。系统中的 V hart 和 IOMMU。</p>
<p>当线信号中断 (WSI) 位设置为 1 时，会导致在 IOFENCE.C 完成时从命令队列生成线中断（通过设置 cqcsr.fence_w_ip - 第 5.15 节）。如果 IOMMU 不支持有线中断或尚未启用有线中断（即 fctl.WSI &#x3D;&#x3D; 0），则保留该位。</p>
<blockquote>
<p>软件应确保 IOMMU 处理的所有先前读取和写入均已提交到全局排序点，然后再回收先前可供设备访问的内存。此类内存回收的安全顺序是首先更新页表以禁止从设备访问内存，然后适当地使用 IOTINVAL.VMA 或 IOTINVAL.GVMA 将 IOMMU 与页表的更新同步。</p>
<p>作为同步的一部分，如果回收的内存先前可供设备读取，则请求对所有先前读取进行排序；否则，如果回收的内存先前已可供设备写入，则请求对所有先前的读取和写入进行排序。如果回收的内存将用于保存设备不可见的数据，则可能需要对先前的读取进行排序。</p>
<p>PR 和&#x2F;或 PW 设置为 1 的 IOFENCE.C 仅确保已由 IOMMU 处理的请求提交到全局订购点。如果需要确保观察到来自 IOMMU 尚未处理的设备的所有正在进行的请求，则软件必须执行互连特定的栅栏操作。例如，对于 PCIe，设备响应于从设备存储器读取的完成具有确保 IOMMU 观察到先前发布的写入的属性，因为完成可能不会通过先前发布的写入。</p>
<p>顺序保证是针对对主存储器的访问而做出的。对于对 I&#x2F;O 内存的访问，顺序保证由实现和 I&#x2F;O 协议定义。</p>
<p>更简单的实现可以无条件地全局排序所有先前的存储器访问。</p>
</blockquote>
<p>AV 命令操作数指示 ADDR[63:2] 操作数和 DATA 操作数是否有效。如果 AV&#x3D;1，则当命令完成时，IOMMU 将 DATA 写入内存中 4 字节对齐的地址 ADDR[63:2] * 4 作为 4 字节存储。当 AV 为 0 时，ADDR[63:2] 和 DATA 操作数被忽略。</p>
<blockquote>
<p>软件可以配置ADDR[63:2]命令操作数以指定IMSIC中的seteipnum_le&#x2F;seteipnum_be寄存器的地址，以在IOFENCE.C完成时引起外部中断通知。或者，软件可以将 ADDR[63:2] 编程到存储器位置，并使用 IOFENCE.C 在存储器中设置指示命令完成的标志。</p>
</blockquote>
<h3 id="3-1-3-IOMMU-目录缓存失效命令"><a href="#3-1-3-IOMMU-目录缓存失效命令" class="headerlink" title="3.1.3. IOMMU 目录缓存失效命令"></a>3.1.3. IOMMU 目录缓存失效命令</h3><p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808170506800-1730797861485-61.png" alt="image-20230808170506800"></p>
<p>IOMMU 操作会导致对 DDT 和&#x2F;或 PDT 的隐式读取。为了减少此类读取的延迟，IOMMU可以将来自DDT和&#x2F;或PDT的条目缓存在IOMMU目录缓存中。这些缓存可能不会观察到软件对内存中的这些数据结构执行的修改。</p>
<p>IOMMU DDT 缓存失效命令 IODIR.INVAL_DDT 将 DDT 更新与 IOMMU 的操作同步，并刷新匹配的缓存条目。</p>
<p>IOMMU PDT 缓存失效命令 IODIR.INVAL_PDT 将 PDT 更新与 IOMMU 的操作同步，并刷新匹配的缓存条目。</p>
<p>DV 操作数指示设备 ID (DID) 操作数是否有效。对于 IODIR.INVAL_PDT，DV 操作数必须为 1，否则该命令是非法的。当DV操作数为1时，DID操作数的值不能比ddtp.iommu_mode支持的宽。</p>
<p>IODIR.INVAL_DDT 保证在所有后续从 IOMMU 到 DDT 的隐式读取之前，观察到 RISC-V hart 对 DDT 所做的任何先前存储。如果 DV 为 0，则该命令将使所有设备缓存的所有 DDT 和 PDT 条目无效； DID 操作数被忽略。如果 DV 为 1，则该命令将使由 DID 操作数标识的设备的缓存叶级 DDT 条目和所有关联的 PDT 条目无效。 PID 操作数是为 IODIR.INVAL_DDT 命令保留的。</p>
<p>IODIR.INVAL_PDT 保证在所有后续从 IOMMU 到 PDT 的隐式读取之前，观察到 RISC-V hart 对 PDT 所做的任何先前存储。该命令使指定 PID 和 DID 的缓存叶 PDT 条目无效。 IODIR.INVAL_PDT 的 PID 操作数不得宽于 IOMMU 支持的宽度（请参见第 5.3 节）。</p>
<blockquote>
<p>设备上下文或进程上下文中的某些字段可能是Guest 物理地址。缓存设备上下文或进程上下文时的实现可以在将这些字段转换为管理程序物理地址之后缓存这些字段。</p>
<p>其他实现可以将它们缓存为Guest physical addresses，并在访问这些地址引用的内存之前使用第二阶段页表将它们转换为管理程序物理地址。</p>
<p>如果用于这些转换的第二阶段页表被修改，软件必须发出适当的 IODIR 命令，因为某些实现可能会选择将转换后的管理程序物理地址指针缓存在 IOMMU 目录缓存中。</p>
<p>IOTINVAL 命令对 IOMMU 目录缓存没有影响。</p>
</blockquote>
<h3 id="3-1-4-IOMMU-PCIe-ATS-命令"><a href="#3-1-4-IOMMU-PCIe-ATS-命令" class="headerlink" title="3.1.4. IOMMU PCIe ATS 命令"></a>3.1.4. IOMMU PCIe ATS 命令</h3><p>如果capabilities.ATS 设置为 1，则支持此命令。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808171138932-1730797861485-63.png" alt="image-20230808171138932"></p>
<p>ATS.INVAL 命令指示 IOMMU 向 RID 标识的 PCIe 设备功能发送“无效请求”消息。 “无效请求”消息用于从设备功能中的地址转换缓存中清除地址范围的特定子集。当从设备接收到“无效完成”响应消息或在等待响应时发生协议定义的超时时，ATS.INVAL 命令完成。 IOMMU 可以在等待响应的同时推进 cqh 并从 CQ 获取更多命令。如果发生超时，则会在执行后续 IOFENCE.C 命令时报告。</p>
<blockquote>
<p>需要知道设备上的失效操作是否完成的软件可以使用 IOMMU 命令队列栅栏命令 (IOFENCE.C) 来等待对所有先前“失效请求”消息的响应。在执行并完成所有先前获取的命令之前，保证 IOFENCE.C 不会完成。在请求超时或从设备收到有效响应之前，先前获取的使设备 ATC 无效的 ATS 命令不会完成。</p>
<p>如果IOFENCE.C之前的一个或多个ATS失效命令已经超时，则软件可以使CQ再次运行并重新提交可能已经超时的失效命令。如果在 IOFENCE.C 之前排队的 ATS.INVAL 命令针对多个设备，则软件可能会将这些命令作为 ATS.INVAL 和 IOFENCE.C 对重新提交，以识别导致超时的设备。</p>
</blockquote>
<p>ATS.PRGR 命令指示 IOMMU 向 RID 标识的 PCIe 设备功能发送“页面请求组响应”消息。 “页面请求组响应”消息被系统硬件和&#x2F;或软件用来与设备功能页面请求接口进行通信，以发出“页面请求”完成的信号，或者接口的灾难性故障。</p>
<p>如果 PV 操作数设置为 1，则生成带有 PASID 的消息，其中 PASID 字段设置为 PID 操作数。如果 PV 操作数设置为 0，则忽略 PID 操作数，并且生成不带 PASID 的消息。</p>
<p>命令的 PAYLOAD 操作数用于形成消息正文，其字段由 PCIe 规范 [1] 指定。 PAYLOAD 字段的格式如下：</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808171536592-1730797861485-67.png" alt="image-20230808171536592"></p>
<p>图 30. ATS.INVAL 命令的有效负载</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808171557302-1730797861485-65.png" alt="image-20230808171557302"></p>
<p>图 31. ATS.PRGR 命令的有效负载</p>
<p>如果 DSV 操作数为 1，则 DSEG 操作数指定有效的目标段号。如果 DSV 操作数为 0，则忽略 DSEG 操作数。</p>
<blockquote>
<p>层次结构是 PCI Express I&#x2F;O 互连拓扑，其中配置空间地址（称为总线&#x2F;设备&#x2F;功能编号的元组）是唯一的。在某些情况下，层次结构也称为段，在 Flit 模式下，段编号有时包含在函数的 ID 中</p>
</blockquote>
<h2 id="3-2-故障-事件队列-FQ"><a href="#3-2-故障-事件队列-FQ" class="headerlink" title="3.2.故障&#x2F;事件队列 (FQ)"></a>3.2.故障&#x2F;事件队列 (FQ)</h2><p>故障&#x2F;事件队列是一种内存队列数据结构，用于报告处理事务时引发的事件和故障。每条故障记录为32字节。</p>
<p>该内存队列的基址的 PPN 和队列的大小被配置到称为故障队列基址 (fqb) 的内存映射寄存器中。</p>
<p>故障队列的尾部驻留在 IOMMU 控制的只读内存映射寄存器（称为 fqt）中。 fqt 是 IOMMU 将写入故障队列的下一个故障记录的索引。</p>
<p>写入记录后，IOMMU 将 fqt 加 1。故障队列的头部驻留在称为 fqh 的读&#x2F;写内存映射软件控制寄存器中。 fqh 是 SW 接下来应该处理的故障记录的索引。在处理故障记录之后，软件通过处理的故障记录数量的计数来推进 fqh。如果 fqh &#x3D;&#x3D; fqt，则故障队列为空。如果 fqt &#x3D;&#x3D; (fqh - 1) 则故障队列已满。</p>
<p>故障记录被解释为四个 64 位双字。内存中每个双字的字节顺序（小端字节序或大端字节序）是由 fctl.BE（第 5.4 节）确定的字节序。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808171717824-1730797861485-69.png" alt="image-20230808171717824"></p>
<p>图 32. 故障队列记录</p>
<p>CAUSE 是指示故障&#x2F;事件原因的代码。</p>
<p>表 11. 故障记录 CAUSE 字段编码</p>
<table>
    <tr>
        <th>CAUSE</th>
        <th>Description</th>
        <th>Reported if DTF is 1?</th>
    </tr>
    <tr>
        <td>1</td>
        <td>指令访问错误</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>4</td>
        <td>读取地址未对齐</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>5</td>
        <td>读访问错误</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>6</td>
        <td>写入/AMO 地址未对齐</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>7</td>
        <td>写/AMO 访问故障</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>12</td>
        <td>指令页错误</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>13</td>
        <td>读取页错误</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>15</td>
        <td>写入/AMO 页错误</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>20</td>
        <td>指示Guest page fault</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>21</td>
        <td>读取Guest page fault</td>
        <td>NO</td>
    </tr><tr>
        <td>23</td>
        <td>写入/AMO Guest page fault</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>256</td>
        <td>禁止所有入站交易</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>257</td>
        <td>DDT 条目加载访问故障</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>258</td>
        <td>DDT 条目无效</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>259</td>
        <td>DDT 条目配置错误</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>260</td>
        <td>不允许的交易类型</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>261</td>
        <td>MSI PTE 加载访问故障</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>262</td>
        <td>MSI PTE 无效</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>263</td>
        <td>MSI PTE 配置错误</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>264</td>
        <td>MRIF访问故障</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>265</td>
        <td>PDT 条目加载访问故障</td>
        <td>NO</td>
    </tr>   
    <tr>
        <td>266</td>
        <td>PDT 条目无效</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>267</td>
        <td>PDT 条目配置错误</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>268</td>
        <td>DDT 数据损坏</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>269</td>
        <td>PDT 数据损坏</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>270</td>
        <td>MSI PT 数据损坏</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>271</td>
        <td>MSI MRIF 数据损坏</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>272</td>
        <td>内部数据路径错误</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>273</td>
        <td>IOMMU MSI 写访问故障</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>274</td>
        <td>第一/第二阶段 PT 数据损坏</td>
        <td>NO</td>
    </tr>
</table>

<p>CAUSE 编码 275 到 2047 保留供将来标准使用，编码 2048 到 4095 指定供定制使用。表 11 中未指定的 0 到 275 之间的编码保留供未来标准使用。</p>
<p>如果故障情况阻止定位有效的设备上下文，则假定用于报告此类故障的 DTF 值为 0。</p>
<p>TTYP 字段报告入站事务类型。</p>
<p>表 12. 故障记录 TTYP 字段编码</p>
<table>
    <tr>
        <th>TTYP</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>0</td>
        <td>没有任何。故障不是由入站事务引起的。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>执行事务的未翻译读取</td>
    </tr>
    <tr>
        <td>2</td>
        <td>未翻译的读事务</td>
    </tr>
    <tr>
        <td>3</td>
        <td>未翻译的写入/AMO 事务</td>
    </tr>
    <tr>
        <td>4</td>
        <td>Reserved</td>
    </tr>
    <tr>
        <td>5</td>
        <td>执行事务的翻译读取</td>
    </tr>
    <tr>
        <td>6</td>
        <td>翻译后的读事务</td>
    </tr>
    <tr>
        <td>7</td>
        <td>翻译后的写入/AMO 事务</td>
    </tr>
    <tr>
        <td>8</td>
        <td>PCIe ATS 转换请求</td>
    </tr>
    <tr>
        <td>9</td>
        <td>PCIe 消息请求</td>
    </tr>
    <tr>
        <td>10-31</td>
        <td>Reserved</td>
    </tr>
    <tr>
        <td>32-63</td>
        <td>指定用于定制用途</td>
    </tr>
</table>

<p>如果 TTYP 是具有 IOVA 的事务，则其在 iotval 中报告。如果 TTYP 是 PCIe 消息请求，则消息代码将在 iotval 中报告。如果 TTYP 为 0，则 iotval 和 iotval2 字段中报告的值由 CAUSE 定义。</p>
<blockquote>
<p>IOVA 分为虚拟页号 (VPN) 和页偏移量。尽管 VPN 通过地址转换过程转换为物理页号 (PPN)，但此过程不需要页偏移量。一些实现中的 IO 桥可能不会向 IOMMU 提供 IOVA 的页面偏移部分，并且 IOMMU 可能会将 iotval 中的页面偏移报告为 0。同样，IOMMU 可能会将 iotval2 中的 GPA 的页面偏移报告为 0。</p>
</blockquote>
<p>DID 保存交易的 device_id。如果 PV 为 0，则 PID 和 PRIV 为 0。如果 PV 为 1，则 PID 保存事务的 process_id，如果事务的权限是 Supervisor，则 PRIV 位为 1，否则为 0。DID、PV、PID ，如果 TTYP 为 0，则 PRIV 字段为 0。</p>
<p>如果原因是Guest page fault，则零扩展Guest 物理地址的位 63:2 将在 iotval2[63:2] 中报告。如果 iotval2 的位 0 为 1，则Guest页面错误是由第一阶段地址转换的隐式内存访问引起的。如果 iotval2 的位 0 为 1，并且隐式访问是写入，则 iotval2 的位 1 设置为 1，否则设置为 0。</p>
<blockquote>
<p>iotval2 的位 1 被设置为以下情况：实现支持 A&#x2F;D 位的硬件更新，并且尝试隐式存储器访问来自动更新第一级页表中的 A 和&#x2F;或 D。第一阶段地址转换的所有其他隐式内存访问都将被读取。如果没有实现A&#x2F;D位的硬件更新，则永远不会出现写情况。</p>
<p>当第二阶段不是Bare时，用于读取PDT条目以定位进程上下文的存储器访问是用于第一阶段地址转换的隐式存储器访问。如果Guest page fault是由读取 PDT 条目的隐式内存访问引起的，则 iotval2 的位 0 报告为 1，位 1 报告为 0。</p>
</blockquote>
<p>由于诸如故障队列已满或IOMMU在尝试访问队列存储器时遇到访问故障之类的错误条件，IOMMU可能无法通过故障队列报告故障。内存映射故障控制和状态寄存器 (fqcsr) 保存有关此类故障的信息。如果检测到故障队列已满情况，IOMMU 将在 fqcsr 中设置故障队列溢出 (fqof) 位。如果 IOMMU 在访问故障队列内存时遇到故障，IOMMU 将在 fqcsr 中设置故障队列内存访问故障 (fqmf) 位。当 fqcsr 中设置任一错误位时，IOMMU 会丢弃导致故障的记录以及所有进一步的故障记录。当 fqcsr 中的错误位为 1 或故障队列中产生新的故障记录时，如果启用了来自故障队列的中断，即 fqcsr.fie 为 1，则 ipsr 中的故障中断挂起 (fip) 位将被设置。</p>
<p>IOMMU可以将多个请求识别为已检测到相同的故障。在这种情况下，IOMMU 可以单独报告这些故障中的每一个，或者报告请求子集（包括一个）的故障。</p>
<h2 id="3-3-页面请求队列-PQ"><a href="#3-3-页面请求队列-PQ" class="headerlink" title="3.3.页面请求队列 (PQ)"></a>3.3.页面请求队列 (PQ)</h2><p>页面请求队列是一种内存队列数据结构，用于向软件报告 PCIe ATS“页面请求”和“停止标记”消息[1]。该内存队列的基本 PPN 和队列的大小被配置到称为页面请求队列基数 (pqb) 的内存映射寄存器中。每个页面请求记录为 16 字节。</p>
<p>队列尾部驻留在 IOMMU 控制的只读内存映射寄存器（称为 pqt）中。 pqt 保存队列中的索引，IOMMU 将在该队列中写入下一个页面请求消息。写入消息后，IOMMU 将 pqt 前移 1。</p>
<p>队列的头部驻留在一个软件控制的读&#x2F;写内存映射寄存器中，称为 pqh。 pqh 保存队列中的索引，软件将在该队列中接收下一个页面请求消息。在处理消息之后，软件将 pqh 提高为已处理消息数的计数。</p>
<p>如果 pqh &#x3D;&#x3D; pqt，则页面请求队列为空。</p>
<p>如果 pqt &#x3D;&#x3D; (pqh - 1) 则页面请求队列已满。</p>
<p>由于错误条件（例如队列被禁用、队列已满或 IOMMU 在尝试访问队列内存时遇到访问错误），IOMMU 可能无法通过队列报告“页面请求”消息。内存映射页面请求队列控制和状态寄存器 (pqcsr) 用于保存有关此类故障的信息。在页面队列已满的情况下，页面请求队列溢出 (pqof) 位在 pqcsr 中设置。如果 IOMMU 在访问队列内存时遇到故障，则会在 pqcsr 中设置页面请求队列内存访问故障 (pqmf) 位。当在 pqcsr 中设置任一错误位时，IOMMU 会丢弃所有后续“页面请求”消息，包括导致设置错误位的消息。不需要响应的“页面请求”消息，即“PRG 中的最后请求”字段为 0 的消息，将被默默丢弃。</p>
<p>需要响应的“页面请求”消息，即“PRG 中的最后请求”字段设置为 1 且不是“停止标记”消息的消息，可以由 IOMMU 生成的指定的“页面请求组响应”消息自动完成在第 2.7 节中。</p>
<p>当 pqcsr 中的错误位为 1 或队列中产生新消息时，如果启用了来自页面请求队列的中断，即 pqcsr.pie 为 1，则在 ipsr 中设置页面请求队列中断挂起 (pip) 位。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808181912574-1730797861485-71.png" alt="image-20230808181912574"></p>
<p>图 33. 页面请求队列记录</p>
<p>DID 字段保存消息中的请求者 ID。如果 PV 为 1，则 PID 字段有效，并从消息中报告 PASID。如果消息没有 PASID，则 PRIV 设置为 0，否则它保留来自 TLP 的“请求特权模式”位。如果消息没有 PASID，则 EXEC 位设置为 0，否则报告来自 TLP 的“执行请求”位。所有其他字段均设置为 0。“页面请求”消息的有效负载（消息的字节 0x08 到 0x0F）保存在 PAYLOAD 字段中。如果R和W都为0并且L为1，则消息是“停止标记”。</p>
<p>页请求队列记录被解释为两个 64 位双字。内存中每个双字的字节顺序（小端字节序或大端字节序）是由 fctl.BE（第 5.4 节）确定的字节序。</p>
<p>PAYLOAD 保存消息正文，其字段由 PCIe 规范 [1] 指定。 PAYLOAD 字段的格式如下：</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230808181951178-1730797861485-73.png" alt="image-20230808181951178"></p>
<p>图 34.“页面请求”消息的有效负载</p>
<h1 id="第-4-章-调试支持"><a href="#第-4-章-调试支持" class="headerlink" title="第 4 章 调试支持"></a>第 4 章 调试支持</h1><p>为了支持软件调试，IOMMU可以提供可选的寄存器接口，软件可以使用该接口来请求IOMMU执行地址转换。当 features.DBG 为 1 时，IOMMU 支持此功能。该接口由两组寄存器组成；软件使用翻译请求寄存器来对 IOVA 进行编程，以及将 IOVA（第 2.3 节）翻译为未翻译请求的过程所需的其他输入。如果过程成功完成，则通过翻译响应寄存器报告翻译结果。如果进程由于故障而停止，则故障会在故障队列中正常报告，并且转换响应寄存器会使用故障指示器进行更新。如果确定 IOVA 是虚拟中断文件的 IOVA（第 2.1.3.6 节）并且相应的 MSI PTE 处于 MRIF 模式，则进程停止并报告“事务类型不允许”（原因 &#x3D; 260）故障。</p>
<p>当为此目的调用翻译 IOVA 的过程时，IOMMU 可能会也可能不会在 IOATC 中缓存为翻译过程访问的第一阶段 PTE、第二阶段 PTE、DDT 条目、PDT 条目或 MSI PTE。允许 IOMMU 使用可能已缓存在 IOATC 中的任何 PTE 或目录结构条目。如果 IOMMU 支持，IOMMU 可以更新用于转换过程的 PTE 中的访问 (A) 和&#x2F;或脏 (D) 位。当IOMMU实现HPM时，HPM计数器可以由IOMMU正常更新。为了在 HPM 中计数，这些请求被视为未翻译的请求。</p>
<p>转换请求接口由以下 64 位 WARL 寄存器组成：</p>
<ul>
<li>tr_req_iova（第 5.24 节） </li>
<li>tr_req_ctl（第 5.25 节）</li>
</ul>
<p>转换响应接口由单个 64 位 RO 寄存器 tr_response 组成（第 5.26 节）</p>
<p>要请求转换，首先将所需的 IOVA 写入 tr_req_iova 寄存器，然后写入 tr_req_ctl 寄存器。在 tr_req_ctl 中设置“Go&#x2F;Busy”位以指示寄存器中的有效请求。 Go&#x2F;Busy 位是一个读写粘性 (RWS) 位，一旦设置，就无法通过写入寄存器来清除。当该过程完成时（成功或由于遇到故障），Go&#x2F;Busy 位将被 IOMMU 清除为 0。当 Go&#x2F;Busy 位从 1 变为 0 时，tr_response 寄存器中的响应有效。</p>
<p>如果出现以下情况，则 IOMMU 行为未指定：</p>
<ul>
<li><p>当Go&#x2F;Busy 位为1 时，tr_req_iova 或tr_req_ctl 被修改。</p>
</li>
<li><p>修改IOMMU 配置，例如ddtp.iommu_mode 等。</p>
</li>
</ul>
<p>通过此调试接口完成转换请求的时间未指定，但要求是有限的。如果当通过该寄存器接口发出请求时，IOMMU 正在服务来自 IO 桥的转换请求，则完成请求的时间可能比 IOMMU 空闲时更长。</p>
<blockquote>
<p>调试接口是可选的，但建议实施以帮助软件调试和实施架构合规性测试。</p>
</blockquote>
<h1 id="第-5-章-内存映射寄存器接口"><a href="#第-5-章-内存映射寄存器接口" class="headerlink" title="第 5 章 内存映射寄存器接口"></a>第 5 章 内存映射寄存器接口</h1><p>IOMMU 提供内存映射编程接口。每个 IOMMU 的内存映射寄存器位于物理地址空间自然对齐的 4 KiB 区域（一页）内。</p>
<p>如果地址未与访问大小对齐，或者访问跨越多个寄存器，或者访问大小不是 4 字节或 8 字节，则 IOMMU 的寄存器访问行为是未指定的。对 IOMMU 寄存器的 4 字节访问必须是单副本原子的。对 IOMMU 寄存器的 8 字节访问是否是单副本原子是未指定的，并且这样的访问可能在 IOMMU 内部出现，就像执行了两次单独的 4 字节访问一样。</p>
<blockquote>
<p>8 字节 IOMMU 寄存器的定义方式是，软件可以对寄存器的高半部分和低半部分执行两个独立的 4 字节访问，或者硬件可以对寄存器的高半部分和低半部分执行由 8 字节访问产生的两个独立的 4 字节事务。就副作用而言，寄存器语义在两个软件访问或两个硬件事务之间分别受到尊重。</p>
</blockquote>
<p>IOMMU 寄存器具有小尾数字节顺序（即使对于所有 hart 均为大尾数的系统也是如此）。</p>
<blockquote>
<p>使用 IOMMU 的大端序配置的 hart 预计将实现 Zbb 扩展定义的 REV8 字节反转指令。如果未实现 REV8，则可以使用指令序列来实现字节序转换。</p>
</blockquote>
<p>如果寄存器是可选的（由相应的功能寄存器位为 0 确定），则从该寄存器的内存映射寄存器偏移量读取将返回 0，并且忽略对该偏移量的写入。</p>
<h2 id="5-1-寄存器布局"><a href="#5-1-寄存器布局" class="headerlink" title="5.1.寄存器布局"></a>5.1.寄存器布局</h2><p>表 13. IOMMU 内存映射寄存器布局</p>
<table>
    <tr>
        <th>Offset</th>
        <th>Name</th>
        <th>Size</th>
        <th>Description</th>
        <th>Is Optional?</th>
    </tr>
    <tr>
        <td>0</td>
        <td><font color="red">capabilities</font></td>
        <td>8</td>
        <td>capabilities of the IOMMU</td>
        <td>No</td>
    </tr>
    <tr>
        <td>8</td>
        <td><font color="red">fctl</font></td>
        <td>4</td>
        <td>Features control</td>
        <td>No</td>
    </tr>
    <tr>
        <td>12</td>
        <td>custom</td>
        <td>4</td>
        <td>指定用于定制用途</td>
        <td></td>
    </tr>
    <tr>
        <td>16</td>
        <td><font color="red">ddtp</font></td>
        <td>8</td>
        <td>设备目录表指针</td>
        <td>No</td>
    </tr>
    <tr>
        <td>24</td>
        <td><font color="red">cqb</font></td>
        <td>8</td>
        <td>命令队列基础</td>
        <td>No</td>
    </tr>
    <tr>
        <td>32</td>
        <td><font color="red">cqh</font></td>
        <td>4</td>
        <td>命令队列头</td>
        <td>No</td>
    </tr>
    <tr>
        <td>36</td>
        <td><font color="red">cqt</font></td>
        <td>4</td>
        <td>Command-queue tail</td>
        <td>No</td>
    </tr>
    <tr>
        <td>40</td>
        <td><font color="red">fqb</font></td>
        <td>8</td>
        <td>故障队列库</td>
        <td>No</td>
    </tr>
    <tr>
        <td>48</td>
        <td><font color="red">fqh</font></td>
        <td>4</td>
        <td>故障队列头</td>
        <td>No</td>
    </tr>
    <tr>
        <td>52</td>
        <td><font color="red">fqt</font></td>
        <td>8</td>
        <td>故障队列尾部</td>
        <td>No</td>
    </tr>
    <tr>
        <td>56</td>
        <td><font color="red">pqb</font></td>
        <td>8</td>
        <td>页面请求队列基础</td>
        <td>if capabilities.ATS==0</td>
    </tr>
    <tr>
        <td>64</td>
        <td><font color="red">pqh</font></td>
        <td>4</td>
        <td>页面请求队列头</td>
        <td>if capabilities.ATS==0</td>
    </tr>
    <tr>
        <td>68</td>
        <td><font color="red">pqt</font></td>
        <td>4</td>
        <td>页面请求队列尾部</td>
        <td>if capabilities.ATS==0</td>
    </tr>
    <tr>
        <td>72</td>
        <td><font color="red">cqcsr</font></td>
        <td>4</td>
        <td>命令队列 CSR</td>
        <td>No</td>
    </tr>
    <tr>
        <td>76</td>
        <td><font color="red">fqcsr</font></td>
        <td>4</td>
        <td>故障队列 CSR</td>
        <td>No</td>
    </tr>
    <tr>
        <td>80</td>
        <td><font color="red">pqcsr</font></td>
        <td>4</td>
        <td>页面请求队列 CSR</td>
        <td>if capabilities.ATS==0</td>
    </tr>
    <tr>
        <td>84</td>
        <td><font color="red">ipsr</font></td>
        <td>4</td>
        <td>中断挂起状态寄存器</td>
        <td>No</td>
    </tr>
    <tr>
        <td>88</td>
        <td><font color="red">iocntovf</font></td>
        <td>4</td>
        <td>HPM 计数器溢出</td>
        <td>if capabilities.HPM==0</td>
    </tr>
    <tr>
        <td>92</td>
        <td><font color="red">iocntinh</font></td>
        <td>4</td>
        <td>HPM 计数器抑制</td>
        <td>if capabilities.HPM==0</td>
    </tr>
    <tr>
        <td>96</td>
        <td><font color="red">iohpmcycles</font></td>
        <td>8</td>
        <td>HPM 循环计数器</td>
        <td>if capabilities.HPM==0</td>
    </tr>
    <tr>
        <td>104</td>
        <td><font color="red">iohpmctr1-31 </font></td>
        <td>248</td>
        <td>HPM 事件计数器</td>
        <td>if capabilities.HPM==0</td>
    </tr>
    <tr>
        <td>352</td>
        <td><font color="red">iohpmevt1-31</font></td>
        <td>248</td>
        <td>HPM 事件选择器</td>
        <td>if capabilities.HPM==0</td>
    </tr>
    <tr>
        <td>600 </td>
        <td><font color="red">tr_req_iova</font></td>
        <td>8</td>
        <td>翻译请求 IOVA</td>
        <td>if capabilities.DBG==0</td>
    </tr>
    <tr>
        <td>608</td>
        <td><font color="red">tr_req_ctl</font></td>
        <td>8</td>
        <td>翻译请求控制</td>
        <td>if capabilities.DBG==0</td>
    </tr>
    <tr>
        <td>616 </td>
        <td><font color="red">tr_response</font></td>
        <td>8</td>
        <td>翻译请求响应</td>
        <td>if capabilities.DBG==0</td>
    </tr>
    <tr>
        <td>624</td>
        <td><font>Reserved</font></td>
        <td>64</td>
        <td>保留供将来使用 (WPRI)</td>
        <td></td>
    </tr>
    <tr>
        <td>688 </td>
        <td><font>custom</font></td>
        <td>72</td>
        <td>指定用于定制用途 (WARL)</td>
        <td></td>
    </tr>
    <tr>
        <td>760</td>
        <td><font color="red">icvec</font></td>
        <td>8</td>
        <td>向量寄存器的中断原因</td>
        <td>No</td>
    </tr>
    <tr>
        <td>768</td>
        <td><font color="red">msi_cfg_tbl</font></td>
        <td>256</td>
        <td>MSI 配置表</td>
        <td>if capabilities.IGS==WSI</td>
    </tr>
    <tr>
        <td>1024 </td>
        <td><font>Reserved</font></td>
        <td>3072</td>
        <td>保留供标准使用</td>
        <td>No</td>
    </tr>
</table>

<h2 id="5-2-重置行为"><a href="#5-2-重置行为" class="headerlink" title="5.2.重置行为"></a>5.2.重置行为</h2><p>以下寄存器字段的复位值为 0。</p>
<ul>
<li>cqcsr - cqen、cqie、cqon 和 busy </li>
<li>fqcsr - fqen、fqie、fqon 和 busy </li>
<li>pqcsr - pqen、pqie、pqon 和 busy </li>
<li>tr_req_ctl.Go&#x2F;Busy </li>
<li>ddtp.busy</li>
</ul>
<p>以下寄存器的复位值为0</p>
<ul>
<li>ipsr</li>
</ul>
<p>ddtp.iommu_mode 字段的重置值必须为 Off 或 Bare。</p>
<p>重置后，缓存（第 2.8 节）必须没有有效条目。</p>
<blockquote>
<p>iommu_mode 的重置值建议为 Off。</p>
</blockquote>
<p>对于所有其他寄存器和&#x2F;或字段，复位值均未指定。</p>
<h2 id="5-3-IOMMU能力（capabilities）"><a href="#5-3-IOMMU能力（capabilities）" class="headerlink" title="5.3. IOMMU能力（capabilities）"></a>5.3. IOMMU能力（capabilities）</h2><p>capabilities寄存器是报告 IOMMU 支持的功能的只读寄存器。如果每个字段不为0，则表示 IOMMU 中存在该功能。复位时，寄存器应包含 IOMMU 支持的功能。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810092542280-1730797861485-75.png" alt="image-20230810092542280"></p>
<p>图 35. IOMMU 功能寄存器字段</p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute<br>属性</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>7:0</td>
        <td>version</td>
        <td>RO</td>
        <td>版本字段保存 IOMMU 实现的规范的版本。低半字节用于保存规范的次要版本，高半字节用于保存规范的主要版本。例如，支持 1.0 版规范的实现会报告 0x10。</td>
    </tr>
    <tr>
        <td>8</td>
        <td>Sv32 </td>
        <td>RO</td>
        <td>支持基于页的 32 位虚拟寻址。</td>
    </tr>
    <tr>
        <td>9</td>
        <td>Sv39</td>
        <td>RO</td>
        <td>支持基于页的 39 位虚拟寻址。</td>
    </tr>
    <tr>
        <td>10</td>
        <td>Sv48</td>
        <td>RO</td>
        <td>支持基于页的 48 位虚拟寻址。当设置了 Sv48 时，必须设置 Sv39。</td>
    </tr>
    <tr>
        <td>11 </td>
        <td>Sv57 </td>
        <td>RO</td>
        <td>支持基于页的 57 位虚拟寻址 当设置 Sv57 时，必须设置 Sv48。</td>
    </tr><tr>
        <td>14:12</td>
        <td>reserved</td>
        <td>RO</td>
        <td>保留供标准使用。</td>
    </tr>
    <tr>
        <td>15 </td>
        <td>Svpbmt</td>
        <td>RO</td>
        <td>基于页的内存类型。</td>
    </tr>
    <tr>
        <td>16 </td>
        <td>Sv32x4</td>
        <td>RO</td>
        <td>支持用于第二阶段地址转换的基于页的 34 位虚拟寻址。</td>
    </tr>
    <tr>
        <td>17 </td>
        <td>Sv39x4 </td>
        <td>RO</td>
        <td>支持用于第二阶段地址转换的基于页的 41 位虚拟寻址。</td>
    </tr>
    <tr>
        <td>18 </td>
        <td>Sv48x4 </td>
        <td>RO</td>
        <td>支持用于第二阶段地址转换的基于页的 50 位虚拟寻址。</td>
    </tr><tr>
        <td>19 </td>
        <td>Sv57x4</td>
        <td>RO</td>
        <td>支持用于第二阶段地址转换的基于页的 59 位虚拟寻址。</td>
    </tr><tr>
        <td>20 </td>
        <td>reserved</td>
        <td>RO</td>
        <td>保留供标准使用。</td>
    </tr>
    <tr>
        <td>21 </td>
        <td>AMO_MRIF</td>
        <td>RO</td>
        <td>支持 MRIF 的原子更新。</td>
    </tr>
    <tr>
        <td>22 </td>
        <td>MSI_FLAT</td>
        <td>RO</td>
        <td>支持使用直通模式 MSI PTE 的 MSI 地址转换。</td>
    </tr>
    <tr>
        <td>23  </td>
        <td>MSI_MRIF</td>
        <td>RO</td>
        <td>支持使用 MRIF 模式 MSI PTE 进行 MSI 地址转换。</td>
    </tr>
    <tr>
        <td>24 </td>
        <td>AMO_HWAD</td>
        <td>RO</td>
        <td>支持对 PTE 访问 (A) 和脏 (D) 位进行原子更新。</td>
    </tr><tr>
        <td>25 </td>
        <td>ATS</td>
        <td>RO</td>
        <td>支持 PCIe 地址转换服务 (ATS) 和页面请求接口 (PRI) [1]。</td>
    </tr>
    <tr>
        <td>26 </td>
        <td>T2GPA</td>
        <td>RO</td>
        <td>支持在 ATS 转换完成中返回Guest 物理地址。</td>
    </tr>
    <tr>
        <td>27 </td>
        <td>END</td>
        <td>RO</td>
        <td>当为 0 时，IOMMU 支持一种字节序（小字节序或大字节序）。当为 1 时，IOMMU 支持两种字节序。字节顺序在 fctl 寄存器中定义。</td>
    </tr>
    <tr>
        <td>29:28 </td>
        <td>IGS</td>
        <td>RO</td>
        <td>IOMMU 中断生成支持。<br><table>
            <tr>
                <th>Value</th>
                <th>Name</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>0</td>
                <td>MSI</td>
                <td>IOMMU 仅支持消息信号中断生成。</td>
            </tr>
            <tr>
                <td>1</td>
                <td>WSI</td>
                <td>IOMMU 仅支持线信号中断生成。</td>
            </tr>
            <tr>
                <td>2</td>
                <td>BOTH</td>
                <td>IOMMU 支持 MSI 和 WSI 生成。中断产生方法必须在fctl寄存器中定义。</td>
            </tr>
            <tr>
                <td>3</td>
                <td>0</td>
                <td>保留供标准使用。</td>
            </tr>
            </table></td>
    </tr>
    <tr>
        <td>30 </td>
        <td>HPM</td>
        <td>RO</td>
        <td>IOMMU 实现硬件性能监视器。</td>
    </tr>
    <tr>
        <td>31 </td>
        <td>DBG</td>
        <td>RO</td>
        <td>IOMMU 支持翻译请求接口。</td>
    </tr>
    <tr>
        <td>37:32 </td>
        <td>PAS</td>
        <td>RO</td>
        <td>IOMMU 支持的物理地址大小。</td>
    </tr>
    <tr>
        <td>38 </td>
        <td>END</td>
        <td>RO</td>
        <td>支持 8 位 process_id 的一级 PDT。</td>
    </tr>
    <tr>
        <td>39 </td>
        <td>END</td>
        <td>RO</td>
        <td>支持 17 位 process_id 的两级 PDT。</td>
    </tr>
    <tr>
        <td>40 </td>
        <td>END</td>
        <td>RO</td>
        <td>支持 20 位 process_id 的三级 PDT。</td>
    </tr>
    <tr>
        <td>55:41 </td>
        <td>reserved</td>
        <td>RO</td>
        <td>保留供标准使用。</td>
    </tr>
    <tr>
        <td>63:56 </td>
        <td>END</td>
        <td>RO</td>
        <td>指定用于定制用途。</td>
    </tr>
</table>

<p>当 HPM 为 1 时，iohpmcycles 和 iohpmctr1 寄存器必须存在并且至少为 32 位宽。</p>
<p>必须支持至少一种从 IOMMU 生成中断的方法（MSI 或 WSI）。</p>
<p>IOMMU 实现必须支持 NAPOT 转换连续性的 Svnapot 标准扩展。</p>
<blockquote>
<p>管理程序可以提供软件模拟的 IOMMU，以允许Guest管理第一阶段页表，以对Guest控制的设备访问的内存进行细粒度控制。</p>
<p>向Guest提供此类模拟 IOMMU 的管理程序可以保留对第二阶段地址转换的控制，并清除模拟功能寄存器的 SvNx4 字段。</p>
<p>向Guest提供此类模拟 IOMMU 的hypervisor可以保留对 MSI 页表的控制，该页表用于将 MSI 定向到 IMSIC 中的Guest中断文件或内存驻留中断文件，并清除模拟的 MSI_FLAT 和 MSI_MRIF 字段。能力寄存器。</p>
<p>AMO_HWAD&#x2F;AMO_MRIF 位不表示支持设备启动的原子内存操作。必须通过其他方式发现对设备启动的原子内存操作的支持。</p>
<p>IOMMU 旨在提供高度模块化和可扩展的功能集，允许实现仅包含应用程序所需的确切功能集。此外，实现可以将自己的自定义扩展添加到 IOMMU。</p>
<p>IOMMU 必须支持系统中任何 hart 支持的所有虚拟内存扩展。</p>
<p>RISC-V 平台规范可能要求一组 IOMMU 功能，这些功能必须由符合这些规范的实现提供。</p>
</blockquote>
<h2 id="5-4-功能控制寄存器-fctl"><a href="#5-4-功能控制寄存器-fctl" class="headerlink" title="5.4.功能控制寄存器 (fctl)"></a>5.4.功能控制寄存器 (fctl)</h2><p>该寄存器在任何实现中都必须可读。一种实现方式可以允许寄存器中的一个或多个字段是可写的，以支持启用或禁用由该字段控制的特征。</p>
<p>如果软件在 IOMMU 未关闭时启用或禁用某项功能（即当 ddtp.iommu_mode !&#x3D; Off 时），则 IOMMU 行为是未指定的。</p>
<p>如果软件在启用 IOMMU 内存队列时启用或禁用某个功能（即cqcsr.cqon&#x2F;cqen &#x3D;&#x3D; 1、fqcsr.fqon&#x2F;cqen &#x3D;&#x3D; 1 或 pqcsr.pqon&#x2F;pqen &#x3D;&#x3D; 1) 则 IOMMU 行为未指定。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810095452159-1730797861485-77.png" alt="image-20230810095452159"></p>
<p>图 36. 功能控制寄存器字段</p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>0</td>
        <td>BE</td>
        <td>WARL</td>
        <td>当为 0 时，IOMMU 访问内存驻留数据结构（如表 7 中指定），并且对内存队列的访问作为小端访问执行，当为 1 时作为大端访问执行。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>WSI</td>
        <td>WARL</td>
        <td>当为 1 时，IOMMU 中断作为有线信号中断发出信号，否则它们作为消息信号中断发出信号。</td>
    </tr>
    <tr>
        <td>2</td>
        <td>GXL</td>
        <td>WARL</td>
        <td>控制可用于Guest physical addresses的地址转换方案，如表 2 中所定义。</td>
    </tr>
    <tr>
        <td>15:3 </td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用。</td>
    </tr>
    <tr>
        <td>31:16</td>
        <td>custom</td>
        <td>WPRI</td>
        <td>指定用于定制用途。</td>
    </tr>
</table>

<h2 id="5-5-设备目录表指针-ddtp"><a href="#5-5-设备目录表指针-ddtp" class="headerlink" title="5.5.设备目录表指针 (ddtp)"></a>5.5.设备目录表指针 (ddtp)</h2><p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810100136084-1730797861485-79.png" alt="image-20230810100136084"></p>
<p>图 37. 设备目录表指针寄存器字段</p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>3:0</td>
        <td>iommu_mode</td>
        <td>WARL</td>
        <td>IOMMU 可以配置为以下模式：<br><table>
            <tr>
                    <th>Value</th>
                    <th>Name</th>
                    <th>Description</th>
            </tr>
            <tr>
                    <td>0</td>
                    <td>Off</td>
                    <td>IOMMU 不允许任何入站内存事务</td>
            </tr>
            <tr>
                    <td>1</td>
                    <td>Bare</td>
                    <td>没有翻译或保护。<br>所有入站内存访问都会通过。</td>
            </tr>
            <tr>
                    <td>2</td>
                    <td>1LVL </td>
                    <td>一级设备目录表</td>
            </tr>
            <tr>
                    <td>3</td>
                    <td>2LVL </td>
                    <td>两级设备目录表</td>
            </tr>
            <tr>
                    <td>4</td>
                    <td>3LVL </td>
                    <td>三级设备目录表</td>
            </tr>
            <tr>
                    <td>5-13</td>
                    <td>reserved</td>
                    <td>保留供标准使用。</td>
            </tr>
            <tr>
                    <td>14-15</td>
                    <td>custom</td>
                    <td>指定用于定制用途。</td>
            </tr>
            </table></td>
    </tr>
    <tr>
        <td>4</td>
        <td>busy</td>
        <td>RO</td>
        <td>	对 ddtp 的写入可能需要 IOMMU 执行许多可能与写入不同步发生的操作。当 ddtp 观察到写入时，繁忙位设置为 1。当繁忙位为 1 时，对 ddtp 的附加写入行为未指定。一些实现可以忽略第二写入，而其他实现可以执行由第二写入确定的动作。在写入 ddtp 之前，软件必须验证 busy 位是否为 0。<br><br>	如果 busy 位读取为 0，则 IOMMU 已完成与先前写入 ddtp 相关的操作。<br><br>	可以同步完成这些操作的 IOMMU 可以将该位硬连线为 0。</td>
    </tr>
    <tr>
        <td>9:5 </td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用</td>
    </tr>
    <tr>
        <td>53:10</td>
        <td>PPN</td>
        <td>WARL</td>
        <td>保存设备目录表根页面的 PPN。</td>
    </tr>
    <tr>
        <td>63:54</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用</td>
    </tr>
</table>

<p>如果 capabilities.MSI_FLAT 为 1，则设备上下文大小为 64 字节，否则为 32 字节。</p>
<p>当 iommu_mode 为 Bare 或 Off 时，PPN 字段为 don-care。在裸模式下，仅允许未翻译的请求。不支持已转换请求、转换请求和 PCIe 消息事务。</p>
<p>所有 IOMMU 必须支持关闭和裸机模式。 IOMMU 允许支持目录表级别和设备上下文宽度的子集。至少必须支持其中一种模式。</p>
<p>当 iommu_mode 字段值更改为 Off 时，IOMMU 保证来自连接到 IOMMU 的设备的正在进行的事务将使用适用于 iommu_mode 字段旧值的配置进行处理，并且来自已处理的设备的所有事务和先前请求由 IOMMU 处理后提交给全局订购点，以便平台中的所有 RISC-V 硬件、设备和 IOMMU 都可以观察到它们。</p>
<p>当 iommu_mode 的先前值不是 Off 或 Bare 时，将 iommu_mode 写入 1LVL、2LVL 或 3LVL 的 IOMMU 行为未指定。要更改 DDT 级别，IOMMU 必须首先转换为裸或关闭状态。</p>
<p>当 IOMMU 转换为 Bare of Off 状态时，IOMMU 可以保留从内存数据结构（例如页表、DDT、PDT 等）缓存的信息。软件必须使用适当的失效命令来使缓存条目失效。</p>
<blockquote>
<p>在RV32中，仅需要写入寄存器的低位32位（22位PPN和4位iommu_mode）。</p>
</blockquote>
<h2 id="5-6-命令队列库-cqb"><a href="#5-6-命令队列库-cqb" class="headerlink" title="5.6.命令队列库 (cqb)"></a>5.6.命令队列库 (cqb)</h2><p>该 64 位寄存器 (RW) 保存命令队列根页的 PPN 和队列中的条目数。每个命令为 16 字节。</p>
<p>当 cqcsr.busy 或 cqon 位为 1 时，IOMMU 写入 cqb 的行为未指定。软件推荐的更改 cqb 的顺序是首先通过清除 cqen 来禁用命令队列，并等待 cqcsr.busy 和 cqon 都为 0，然后再更改 cqb。写入 cqb 后，cqt 中的位 31:cqb.LOG2SZ 的状态为 0，并且 cqt 中的位 cqb.LOG2SZ-1:0 假定为有效但未指定的值。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810102950921-1730797861485-81.png" alt="image-20230810102950921"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>4:0</td>
        <td>LOG2SZ-1</td>
        <td>WARL</td>
        <td>LOG2SZ-1 字段将命令队列中的条目数保存为以 2 减 1 为底的日志。值 0 表示队列有 2 个条目。每个 IOMMU 命令都是 16 字节。如果命令队列有 256 个或更少的条目，则队列的基地址始终与 4-KiB 对齐。如果命令队列的条目超过 256 个，则命令队列基地址必须自然对齐到 2 <sup>LOG2SZ</sup> x 16。</td>
    </tr>
    <tr>
        <td>9:5</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用</td>
    </tr>
    <tr>
        <td>53:10</td>
        <td>PPN </td>
        <td>WARL</td>
        <td>保存内存中命令队列根页面的 PPN，软件使用该 PPN 将命令排队到 IOMMU。如果 PPN 确定的基地址未按要求对齐，则队列中的所有条目对于 IOMMU 来说均显示为“未指定”，并且 IOMMU 可以计算并用于访问队列中的条目的任何地址也是“未指定”的。</td>
    </tr>
    <tr>
        <td>63:54 </td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用。</td>
</tr></table>

<blockquote>
<p>在RV32中，仅需要写入寄存器的低32位（22位PPN和5位LOG2SZ-1）。</p>
</blockquote>
<h2 id="5-7-命令队列头-cqh"><a href="#5-7-命令队列头-cqh" class="headerlink" title="5.7.命令队列头 (cqh)"></a>5.7.命令队列头 (cqh)</h2><p>这个 32 位寄存器 (RO) 保存命令队列的索引，IOMMU 将在其中获取下一个命令。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810103454277-1730797861485-83.png" alt="image-20230810103454277"></p>
<p>图 39. 命令队列头寄存器字段</p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>31:0</td>
        <td>index</td>
        <td>RO</td>
        <td>将索引保存到命令队列中，IOMMU 将从该索引获取下一个命令</td>
    </tr>
</table>

<h2 id="5-8-命令队列尾部-cqt"><a href="#5-8-命令队列尾部-cqt" class="headerlink" title="5.8.命令队列尾部 (cqt)"></a>5.8.命令队列尾部 (cqt)</h2><p>该 32 位寄存器 (RW) 保存命令队列的索引，软件在其中对 IOMMU 的下一个命令进行排队。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810103620004-1730797861485-85.png" alt="image-20230810103620004"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>31:0</td>
        <td>index</td>
        <td>WARL</td>
        <td>将索引保存到命令队列中，软件在其中对 IOMMU 的下一个命令进行排队。仅 LOG2SZ-1:0 位可写。</td>
    </tr>
</table>

<h2 id="5-9-故障队列库-fqb"><a href="#5-9-故障队列库-fqb" class="headerlink" title="5.9.故障队列库 (fqb)"></a>5.9.故障队列库 (fqb)</h2><p>该 64 位寄存器 (RW) 保存故障队列根页的 PPN 和队列中的条目数。每条故障记录为32字节。</p>
<p>当 fqcsr.busy 或 fqon 位为 1 时，IOMMU 写入 fqb 的行为未指定。软件推荐的更改 fqb 的顺序是首先通过清除 fqen 来禁用故障队列，并等待 fqcsr.busy 和 fqon 都为 0，然后再更改 fqb。写入 fqb 后，fqh 中的位 31:fqb.LOG2SZ 的状态为 0，并且 fqh 中的位 fqb.LOG2SZ-1:0 假定为有效但未指定的值。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810103710738-1730797861485-87.png" alt="image-20230810103710738"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>4:0</td>
        <td>LOG2SZ-1</td>
        <td>WARL</td>
        <td>LOG2SZ-1 字段以 log-to-base-2 减 1 的形式保存故障队列中的条目数。值 0 表示队列有 2 个条目。每条故障记录为32字节。如果故障队列有 128 个或更少的条目，则队列的基地址始终与 4-KiB 对齐。如果故障队列的条目超过 128 个，则故障队列基地址必须自然对齐到 2 <sup>LOG2SZ</sup> x 32。</td>
    </tr>
    <tr>
        <td>9:5</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用</td>
    </tr>
    <tr>
        <td>53:10</td>
        <td>PPN </td>
        <td>WARL</td>
        <td>保存 IOMMU 用于对故障记录进行排队的内存中故障队列的根页面的 PPN。如果 PPN 确定的基地址未按要求对齐，则队列中的所有条目对于 IOMMU 来说均显示为“未指定”，并且 IOMMU 可以计算并用于访问队列中的条目的任何地址也是“未指定”的。</td>
    </tr>
    <tr>
        <td>63:54 </td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用。</td>
</tr></table>

<blockquote>
<p>在RV32中，仅需要写入寄存器的低32位（22位PPN和5位LOG2SZ-1）。</p>
</blockquote>
<h2 id="5-10-故障队列头-fqh"><a href="#5-10-故障队列头-fqh" class="headerlink" title="5.10.故障队列头 (fqh)"></a>5.10.故障队列头 (fqh)</h2><p>这个 32 位寄存器 (RW) 保存故障队列的索引，软件将在其中获取下一个故障记录。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810103957689-1730797861485-89.png" alt="image-20230810103957689"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>31:0</td>
        <td>index</td>
        <td>WARL</td>
        <td>将索引保存到故障队列中，软件从中读取下一条故障记录。仅 LOG2SZ-1:0 位可写。</td>
    </tr>
</table>

<h2 id="5-11-故障队列尾部-fqt"><a href="#5-11-故障队列尾部-fqt" class="headerlink" title="5.11.故障队列尾部 (fqt)"></a>5.11.故障队列尾部 (fqt)</h2><p>该 32 位寄存器 (RO) 保存故障队列的索引，IOMMU 在该故障队列中对下一个故障记录进行排队。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810104044100-1730797861485-91.png" alt="image-20230810104044100"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>31:0</td>
        <td>index</td>
        <td>RO</td>
        <td>将索引保存到故障队列中，IOMMU 在其中写入下一个故障记录。</td>
    </tr>
</table>

<h2 id="5-12-页面请求队列基础-pqb"><a href="#5-12-页面请求队列基础-pqb" class="headerlink" title="5.12.页面请求队列基础 (pqb)"></a>5.12.页面请求队列基础 (pqb)</h2><p>该 64 位寄存器 (WARL) 保存页面请求队列根页面的 PPN 和队列中的条目数。每个“页面请求”消息有 16 个字节。</p>
<p>当 pqcsr.busy 或 pqon 位为 1 时，IOMMU 写入 pqb 的行为未指定。软件推荐的更改 pqb 的顺序是首先通过清除 pqen 来禁用页面请求队列，并等待 pqcsr.busy 和 pqon 都为 0，然后再更改 pqb。写入 pqb 后，pqh 中的位 31:pqb.LOG2SZ 的状态为 0，并且 pqh 中的位 pqb.LOG2SZ-1:0 假定为有效但未指定的值。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810104141756-1730797861485-93.png" alt="image-20230810104141756"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>4:0</td>
        <td>LOG2SZ-1</td>
        <td>WARL</td>
        <td>LOG2SZ-1 字段以 log-to-base-2 减 1 的形式保存页面请求队列中的条目数。值 0 表示队列有 2 个条目。每个页面请求都是 16 字节。如果页面请求队列有 256 个或更少的条目，则队列的基地址始终与 4-KiB 对齐。如果页面请求队列有超过 256 个条目，则页面请求队列基地址必须自然对齐到 2 <sup>LOG2SZ</sup> x 16。</td>
    </tr>
    <tr>
        <td>9:5</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用</td>
    </tr>
    <tr>
        <td>53:10</td>
        <td>PPN </td>
        <td>WARL</td>
        <td>保存 IOMMU 用于对“页面请求”消息进行排队的内存中页面请求队列的根页面的 PPN。如果 PPN 确定的基地址未按要求对齐，则队列中的所有条目对于 IOMMU 来说均显示为“未指定”，并且 IOMMU 可以计算并用于访问队列中的条目的任何地址也是“未指定”的。</td>
    </tr>
    <tr>
        <td>63:54 </td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用。</td>
</tr></table>

<blockquote>
<p>在RV32中，仅需要写入寄存器的低32位（22位PPN和5位LOG2SZ-1）。</p>
</blockquote>
<h2 id="5-13-页面请求队列头-pqh"><a href="#5-13-页面请求队列头-pqh" class="headerlink" title="5.13.页面请求队列头 (pqh)"></a>5.13.页面请求队列头 (pqh)</h2><p>这个 32 位寄存器 (RW) 保存页面请求队列的索引，软件将在其中获取下一个页面请求。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810104538319-1730797861486-97.png" alt="image-20230810104538319"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>31:0</td>
        <td>index</td>
        <td>RO</td>
        <td>将索引保存到页面请求队列中，软件从中读取下一个“页面请求”消息。仅 LOG2SZ-1:0 位可写。</td>
    </tr>
</table>

<h2 id="5-14-页面请求队列尾部-pqt"><a href="#5-14-页面请求队列尾部-pqt" class="headerlink" title="5.14.页面请求队列尾部 (pqt)"></a>5.14.页面请求队列尾部 (pqt)</h2><p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810104642099-1730797861485-95.png" alt="image-20230810104642099"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>31:0</td>
        <td>index</td>
        <td>RO</td>
        <td>将索引保存到页面请求队列中，IOMMU 在其中写入下一个“页面请求”消息。</td>
    </tr>
</table>

<h2 id="5-15-命令队列-CSR-cqcsr"><a href="#5-15-命令队列-CSR-cqcsr" class="headerlink" title="5.15.命令队列 CSR (cqcsr)"></a>5.15.命令队列 CSR (cqcsr)</h2><p>该 32 位寄存器（RW）用于控制操作并报告命令队列的状态。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810104747844-1730797861486-99.png" alt="image-20230810104747844"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>0</td>
        <td>cqen</td>
        <td>RW</td>
        <td>命令队列启用位设置为 1 时启用命令队列。<br>将 cqen 从 0 更改为 1 将 cqh 寄存器和 cqcsr 位 cmd_ill、cmd_to、cqmf、fence_w_ip 设置为 0。将 cqen 设置为 1 后，命令队列可能需要一些时间才能激活。在此延迟期间，busy 位为 1 . 当命令队列处于活动状态时，cqon 位读取 1。<br>当 cqen 从 1 更改为 0 时，命令队列可能保持活动状态（忙断言），直到处理已从命令队列获取的命令和/或存在来自命令队列的未完成的隐式加载。当命令队列关闭时，cqon 位读取 0<br>当 cqon 位读取为 0 时，IOMMU 保证不会对命令队列进行隐式内存访问，并且命令队列不会对队列内存生成新的隐式负载。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>cie</td>
        <td>RW</td>
        <td>命令队列中断使能位设置为 1 时，允许从命令队列生成中断。</td>
    </tr>
    <tr>
        <td>7:2</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用</td>
    </tr>
    <tr>
        <td>8</td>
        <td>cqmf</td>
        <td>RW1C </td>
        <td>如果命令队列访问导致内存故障，则命令队列内存故障位将设置为 1，并且命令队列将停止，直到该位被清除。要重新启用命令处理，软件应通过写入 1 来清除该位。</td>
    </tr>
    <tr>
        <td>9</td>
        <td>cmd_to</td>
        <td>RW1C</td>
        <td>如果命令的执行导致超时（例如，使设备 ATC 无效的命令可能会在等待完成时超时），则命令队列会设置 cmd_to 位并停止命令队列的处理。要重新启用命令处理，软件应通过写入 1 来清除该位。</td>
    </tr>
    <tr>
        <td>10</td>
        <td>cmd_ill </td>
        <td>RW1C  </td>
        <td>如果命令队列获取并解码了非法或不支持的命令，则命令队列将设置 cmd_ill 位并停止对命令队列的处理。要重新启用命令处理软件，应通过写入 1 来清除该位。</td>
    </tr>
    <tr>
        <td>11</td>
        <td>fence_w_ip</td>
        <td>RW1C</td>
        <td>仅支持线路信号中断的 IOMMU 设置 fence_w_ip 位以指示 IOFENCE.C 命令的完成。<br>要在 IOFENCE.C 完成时重新启用中断，软件应通过写入 1 来清除该位。如果 IOMMU 不支持线信号中断或未启用线信号中断（即 fctl.WSI == 0）则保留该位。</td>
    </tr>
    <tr>
        <td>15:12</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用。</td>
    </tr>
    <tr>
        <td>16</td>
        <td>cqon</td>
        <td>RO</td>
        <td>如果 cqon 为 1，则命令队列处于活动状态。</td>
    </tr>
    <tr>
        <td>17</td>
        <td>busy</td>
        <td>RO</td>
        <td>对 cqcsr 的写入可能需要 IOMMU 执行许多可能与写入不同步发生的操作。当 cqcsr 观察到写入时，繁忙位设置为 1。<br>当繁忙位为 1 时，对 cqcsr 的附加写入行为未指定。一些实现可以忽略第二写入，而其他实现可以执行由第二写入确定的动作。<br>在写入 cqcsr 之前，软件必须验证繁忙位是否为 0。<br>可以同步完成这些操作的 IOMMU 可以将该位硬连线为 0。</td>
    </tr>
    <tr>
        <td>27:18</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用。</td>
    </tr>
    <tr>
        <td>31:28</td>
        <td>custom</td>
        <td>WPRI</td>
        <td>指定用于定制用途。</td>
    </tr>
</table>

<p>当cqcsr中的cmd_ill或cqmf为1时，cqh引用CQ中导致错误的命令。</p>
<p>先前的命令可能已完成、超时或被 IOMMU 中止执行。</p>
<blockquote>
<p>如果软件在 cmd_ill 或 cqmf 错误后使 CQ 再次运行，则软件应重新提交自上次成功完成 IOFENCE.C 以来提交的命令。</p>
</blockquote>
<p>当 IOFENCE.C 命令检测到指定超时的一个或多个先前命令已超时，但 IOFENCE.C 之前的所有其他命令已完成时，cmd_to 位被设置。当 cmd_to 为 1 时，cqh 引用检测到超时的 IOFENCE.C 命令。</p>
<blockquote>
<p>命令队列为空并不意味着从命令队列获取的所有命令都已完成。当请求禁用命令队列时，实现可以完成已获取的命令或中止这些命令的执行。如果需要，在关闭命令队列之前，软件必须使用 IOFENCE.C 命令等待所有先前的命令被提交。</p>
</blockquote>
<h2 id="5-16-故障队列-CSR-fqcsr"><a href="#5-16-故障队列-CSR-fqcsr" class="headerlink" title="5.16.故障队列 CSR (fqcsr)"></a>5.16.故障队列 CSR (fqcsr)</h2><p>该 32 位寄存器 (RW) 用于控制操作并报告故障队列的状态。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810111531824-1730797861486-101.png" alt="image-20230810111531824"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>0</td>
        <td>fqen</td>
        <td>RW</td>
        <td>故障队列启用位设置为 1 时启用故障队列。<br>将 fqen 从 0 更改为 1 将 fqt 寄存器以及 fqcsr 位 fqof 和 fqmf 设置为 0。将 fqen 设置为 1 后，故障队列可能需要一些时间才能激活。在此延迟期间，busy 位为 1。当故障发生时队列处于活动状态，fqon 位读取 1。<br>当 fqen 从 1 更改为 0 时，故障队列可能会保持活动状态（处于繁忙状态），直到完成进行中的故障记录。当故障队列关闭时，fqon 位读取 0。<br>当 fqon 读取 0 时，IOMMU 保证不存在对正在进行的故障队列的正在进行的隐式写入，并且不会将新的故障记录写入故障队列。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>fie</td>
        <td>RW</td>
        <td>当故障队列中断使能位设置为 1 时，可以从故障队列生成中断。</td>
    </tr>
    <tr>
        <td>7:2</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用</td>
    </tr>
    <tr>
        <td>8</td>
        <td>fqmf</td>
        <td>RW1C </td>
        <td>如果 IOMMU 在将故障记录存储到故障队列时遇到访问故障，则 fqmf 位设置为 1。尝试写入的故障记录将被丢弃，并且不会生成更多故障记录，直到软件通过向该位写入 1 来清除该位。</td>
    </tr>
    <tr>
        <td>9</td>
        <td>fqof</td>
        <td>RW1C</td>
        <td>如果 IOMMU 需要对故障记录进行排队但故障队列已满（即 fqt == fqh 1），则故障队列溢出位设置为 1。<br>故障记录被丢弃，并且不再生成故障记录，直到软件通过向该位写入 1 来清除 fqof。</td>
    </tr>
    <tr>
        <td>15:10</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用。</td>
    </tr>
    <tr>
        <td>16</td>
        <td>fqon</td>
        <td>RO</td>
        <td>如果 fqon 读取 1，则故障队列处于活动状态。td>
    </td></tr>
    <tr>
        <td>17</td>
        <td>busy</td>
        <td>RO</td>
        <td>写入 fqcsr 可能需要 IOMMU 执行许多可能与写入不同步发生的操作。当 fqcsr 观察到写入时，繁忙位设置为 1。当繁忙位为 1 时，对 fqcsr 的其他写入行为未指定。一些实现可以忽略第二写入，而其他实现可以执行由第二写入确定的动作。<br>在写入 fqcsr 之前，软件应确保 busy 位为 0。<br>可以同步完成控制的 IOMMU 可以将该位硬连线为 0。</td>
    </tr>
    <tr>
        <td>27:18</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用。</td>
    </tr>
    <tr>
        <td>31:28</td>
        <td>custom</td>
        <td>WPRI</td>
        <td>指定用于定制用途。</td>
    </tr>
</table>

<h2 id="5-17-页面请求队列-CSR-pqcsr"><a href="#5-17-页面请求队列-CSR-pqcsr" class="headerlink" title="5.17.页面请求队列 CSR (pqcsr)"></a>5.17.页面请求队列 CSR (pqcsr)</h2><p>该 32 位寄存器 (RW) 用于控制操作并报告页面请求队列的状态。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810112737105-1730797861486-103.png" alt="image-20230810112737105"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>0</td>
        <td>pqen</td>
        <td>RW</td>
        <td>当页面请求启用位设置为 1 时，启用页面请求队列。<br>将 pqen 从 0 更改为 1，将 pqh 寄存器以及 pqcsr 位 pqmf 和 pqof 设置为 0。将 pqen 设置为 1 后，页面请求队列可能需要一些时间才能激活。在此延迟期间，busy 位为 1。当页面请求队列处于活动状态时，pqon 位读取为 1。<br>当 pqen 从 1 更改为 0 时，页面请求队列可能会保持活动状态（处于繁忙状态），直到完成进行中的页面请求写入。当页面请求队列关闭时，pqon 位读数为 0。<br>当 pqon 读取 0 时，IOMMU 保证不存在对队列存储器的较旧的正在进行的隐式写入，并且不会对队列存储器生成进一步的隐式写入。<br>IOMMU 可以响应当页面请求队列关闭或正在关闭的过程中接收到的“页面请求”消息，如第 2.7 节中所指定。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>pie</td>
        <td>RW</td>
        <td>当页面请求队列中断启用位设置为 1 时，启用从页面请求队列生成中断。</td>
    </tr>
    <tr>
        <td>7:2</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用</td>
    </tr>
    <tr>
        <td>8</td>
        <td>pqmf</td>
        <td>RW1C </td>
        <td>如果 IOMMU 在将“页面请求”消息存储到页面请求队列时遇到访问错误，则 pqmf 位设置为 1。<br>导致 pqmf 或 pqof 错误的“页面请求”消息以及所有后续“页面请求”消息都将被丢弃，直到软件通过向其写入 1 来清除 pqof 和/或 pqmf 位。<br>IOMMU 可以响应导致 pqof 或 pqmf 位被设置的“页面请求”消息，以及当这些位为 1 时接收到的所有后续“页面请求”消息（如第 2.7 节中指定）。</td>
    </tr>
    <tr>
        <td>9</td>
        <td>pqof</td>
        <td>RW1C</td>
        <td>如果页面请求队列溢出，即 IOMMU 需要对“页面请求”消息进行排队，但页面请求队列已满（即 pqt == pqh - 1），则页面请求队列溢出位设置为 1。<br>导致 pqmf 或 pqof 错误的“页面请求”消息以及所有后续“页面请求”消息都将被丢弃，直到软件通过向其写入 1 来清除 pqof 和/或 pqmf 位。<br>IOMMU 可以响应导致 pqof 或 pqmf 位被设置的“页面请求”消息，以及当这些位为 1 时接收到的所有后续“页面请求”消息（如第 2.7 节中指定）。</td>
    </tr>
    <tr>
        <td>15:10</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用。</td>
    </tr>
    <tr>
        <td>16</td>
        <td>pqon</td>
        <td>RO</td>
        <td>当 pqon 读取 1 时，页面请求处于活动状态。</td><td>
    </td></tr>
    <tr>
        <td>17</td>
        <td>busy</td>
        <td>RO</td>
        <td>对 pqcsr 的写入可能需要 IOMMU 执行许多可能与写入不同步发生的操作。当 pqcsr 观察到写入时，繁忙位设置为 1。<br>当繁忙位为 1 时，对 pqcsr 的附加写入行为未指定。一些实现可以忽略第二写入，而其他实现可以执行由第二写入确定的动作。在写入 pqcsr 之前，软件应确保繁忙位为 0。<br>可以同步完成控制的 IOMMU 可以将该位硬连线为 0</td>
    </tr>
    <tr>
        <td>27:18</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用。</td>
    </tr>
    <tr>
        <td>31:28</td>
        <td>custom</td>
        <td>WPRI</td>
        <td>指定用于定制用途。</td>
    </tr>
</table>

<h2 id="5-18-中断挂起状态寄存器-ipsr"><a href="#5-18-中断挂起状态寄存器-ipsr" class="headerlink" title="5.18.中断挂起状态寄存器 (ipsr)"></a>5.18.中断挂起状态寄存器 (ipsr)</h2><p>该 32 位寄存器 (RW1C) 报告需要软件服务的待处理中断。寄存器中的每个中断挂起位对应于 IOMMU 中的一个中断源。寄存器中的中断挂起位一旦设置为 1，就会保持为 1，直到软件通过写入 1 来清除该中断挂起位。</p>
<p>当 fctl.WSI 为 1 时，中断挂起位驱动相应 icvec 字段选择的线来发出中断信号。</p>
<p>当 fctl.WSI 为 0 时，IOMMU 使用消息发出中断信号。 MSI 具有边缘语义，当中断挂起位从 0 转换为 1 时，会生成中断消息。消息的地址和数据从与中断挂起位对应的 icvec 字段选择的 msi_cfg_tbl 条目中获取。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810114211456-1730797861486-105.png" alt="image-20230810114211456"></p>
<p>表 14. 中断挂起状态寄存器字段</p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>0</td>
        <td>cip</td>
        <td>RW1C</td>
        <td>当如果 cqcsr.cie 为 1 并且以下任一条件为真，则命令队列中断挂起位设置为 1： <br>• cqcsr.fence_w_ip 为 1。<br>• cqcsr.cmd_ill 为 1。<br>• cqcsr.cmd_to 为 1。<br>• cqcsr.cqmf 为 1。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>fip</td>
        <td>RW1C </td>
        <td>如果 fqcsr.fie 为 1 并且以下任一条件为真，则故障队列中断挂起位设置为 1： <br>• fqcsr.fqof 为 1。<br>• fqcsr.fqmf 为 1。<br>• FQ 中产生了一条新记录。</td>
    </tr>
    <tr>
        <td>2</td>
        <td>pmip</td>
        <td>RW1C </td>
        <td>当 iohpmcycles 或任何 iohpmctr1-31 寄存器中的 OF 位从 0 转换为 1 时，性能监控中断挂起设置为 1。</td>
    </tr>
    <tr>
        <td>3</td>
        <td>pip</td>
        <td>RW1C</td>
        <td>如果 pqcsr.pie 为 1 并且以下任一条件成立，则 page-request-queue-interrupt-pending 将设置为 1： <br>• pqcsr.pqof 为 1。<br>• pqcsr.pqmf 为 1。<br>• PQ 中产生一条新消息。</td>
    </tr>
    <tr>
        <td>7:4</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用</td>
    </tr>
    <tr>
        <td>15:8</td>
        <td>custom</td>
        <td>WPRI</td>
        <td>指定用于定制用途。</td>
    </tr>
    <tr>
        <td>31:16</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用。</td>
    </tr>
</table>

<p>如果 ipsr 中的某个位为 1，则向该位写入 1 会将该位从 1 转换为 0。如果设置该位的条件仍然存在（请参阅[IPSR_FIELDS]），或者如果在该位被清除后发生，则该位再次从 0→1 转换。</p>
<h2 id="5-19-性能监控计数器溢出状态-iocountovf"><a href="#5-19-性能监控计数器溢出状态-iocountovf" class="headerlink" title="5.19.性能监控计数器溢出状态 (iocountovf)"></a>5.19.性能监控计数器溢出状态 (iocountovf)</h2><p>性能监控计数器溢出状态是一个 32 位只读寄存器，其中包含 iohpmevt1-31 寄存器中 OF 位的影子副本 - 其中 iocntovf 位 X 对应于 iohpmevtX，位 0 对应于 iohpmcycles 的 OF 位。</p>
<p>该寄存器使溢出中断处理程序软件能够快速、轻松地确定哪些计数器已溢出。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810114833875-1730797861486-107.png" alt="image-20230810114833875"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>0</td>
        <td>CY</td>
        <td>RO</td>
        <td>iohpmcycles.OF 的影子</td>
    </tr>
    <tr>
        <td>31:1</td>
        <td>HPM</td>
        <td>RO</td>
        <td>iohpmevt[1-31].OF 的影子</td>
    </tr>
</table>

<h2 id="5-20-性能监控计数器禁止-iocountinh"><a href="#5-20-性能监控计数器禁止-iocountinh" class="headerlink" title="5.20.性能监控计数器禁止 (iocountinh)"></a>5.20.性能监控计数器禁止 (iocountinh)</h2><p>性能监控计数器禁止是一个 32 位 WARL 寄存器，其中包含禁止相应计数器计数的位。位 X 设置时禁止在 iohpmctrX 中计数，位 0 禁止在 iohpmcycles 中计数。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810133156252-1730797861486-109.png" alt="image-20230810133156252"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>0</td>
        <td>CY</td>
        <td>RW</td>
        <td>设置后，iohpmcycles 计数器将被禁止计数。</td>
    </tr>
    <tr>
        <td>31:1</td>
        <td>HPM</td>
        <td>WARL</td>
        <td>当位 X 被设置时，iohpmctrX 中的事件计数被禁止。</td>
    </tr>
</table>

<p>当不需要 iohpmcycles 计数器时，最好有条件地禁止它以减少能耗。提供单个寄存器来禁止所有计数器允许a)一个或多个计数器被原子地编程以用于计数的事件b)一个或多个计数器被原子地采样。</p>
<h2 id="5-21-性能监控周期计数器-iohpmcycles"><a href="#5-21-性能监控周期计数器-iohpmcycles" class="headerlink" title="5.21.性能监控周期计数器 (iohpmcycles)"></a>5.21.性能监控周期计数器 (iohpmcycles)</h2><p>该 64 位寄存器是一个自由运行的时钟周期计数器。没有关联的 iohpmevt0。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810133334134-1730797861486-111.png" alt="image-20230810133334134"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>62:0</td>
        <td>counter</td>
        <td>WARL</td>
        <td>循环计数器值。</td>
    </tr>
    <tr>
        <td>63</td>
        <td>OF</td>
        <td>RW</td>
        <td>溢出</td>
    </tr>
</table>

<p>OF 位在 iohpmcycles 计数器溢出时置位，并保持置位状态直至被软件清零。</p>
<p>由于iohpmcycles值是无符号值，因此溢出被定义为无符号溢出。请注意，溢出后不会丢失信息，因为计数器会回绕并在粘性 OF 位保持设置状态时继续计数。</p>
<p>如果当 OF 位为零时 iohpmcycles 计数器溢出，则通过将 ipsr.pmip 位设置为 1 来生成 HPM 计数器溢出中断。如果 OF 位已经为 1，则不会生成中断请求。因此，OF 位还用作 iohpmcycles 的计数溢出中断禁用。</p>
<h2 id="5-22-性能监控事件计数器-iohpmctr1-31"><a href="#5-22-性能监控事件计数器-iohpmctr1-31" class="headerlink" title="5.22.性能监控事件计数器 (iohpmctr1-31)"></a>5.22.性能监控事件计数器 (iohpmctr1-31)</h2><p>这些寄存器是 64 位 WARL 计数器寄存器。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810133536491-1730797861486-113.png" alt="image-20230810133536491"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>63:0</td>
        <td>counter</td>
        <td>WARL</td>
        <td>事件计数器值。</td>
    </tr>
</table>

<h2 id="5-23-性能监控事件选择器-iohpmevt1-31"><a href="#5-23-性能监控事件选择器-iohpmevt1-31" class="headerlink" title="5.23.性能监控事件选择器 (iohpmevt1-31)"></a>5.23.性能监控事件选择器 (iohpmevt1-31)</h2><p>这些性能监控事件寄存器是 64 位 RW 寄存器。当 IOMMU 处理的事务引发一个被编程为在计数器中计数的事件时，计数器就会递增。除了匹配事件之外，还可以使用基于device_id、process_id、GSCID和PSCID的附加过滤器对事件选择器进行编程，使得计数器基于与这些附加过滤器匹配的事务有条件地递增。当使用这种基于device_id的过滤时，匹配可以被配置为精确匹配或部分匹配。部分匹配允许计数器对具有一系列 ID 的事务进行计数。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810133642271-1730797861486-117.png" alt="image-20230810133642271"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>14:0</td>
        <td>eventID</td>
        <td>WARL</td>
        <td>指示要计数的事件。值 0 表示不计算任何事件。<br>编码 1 到 16383 保留用于表 17 中定义的标准事件。<br>编码 16384 至 32767 指定供自定义使用。<br>当 eventID 更改（包括更改为 0）时，计数器将保留其值。</td>
    </tr>
    <tr>
        <td>15</td>
        <td>DMASK</td>
        <td>RW </td>
        <td>当设置为 1 时，将对事务执行 DID_GSCID 的部分匹配。 DID_GSCID 的低位一直到第一个低位 0 位（包括 0 位位置本身）都被屏蔽。</td>
    </tr>
    <tr>
        <td>35:16 </td>
        <td>PID_PSCID </td>
        <td>RW </td>
        <td>如果 IDT 为 0，则为 process_id；如果 IDT 为 1，则为 PSCID</td>
    </tr>
    <tr>
        <td>59:36 </td>
        <td>DID_GSCID </td>
        <td>RW</td>
        <td>如果 IDT 为 0，则为 device_id；如果 IDT 为 1，则为 GSCID。</td>
    </tr>
    <tr>
        <td>60</td>
        <td>DID_GSCID</td>
        <td>RW</td>
        <td>如果设置，则仅对具有匹配 process_id 或 PSCID（基于过滤器 ID 类型）的事务进行计数。</td>
    </tr>
    <tr>
        <td>61</td>
        <td>DV_GSCV </td>
        <td>RW</td>
        <td>如果设置，则仅对具有匹配 device_id 或 GSCID（基于过滤器 ID 类型）的事务进行计数。</td>
    </tr>
    <tr>
        <td>62</td>
        <td>IDT</td>
        <td>RW</td>
        <td>过滤 ID 类型：此字段指示要过滤的 ID 类型。当为 0 时，DID_GSCID 字段保存 device_id，PID_PSCID 字段保存 process_id。当为 1 时，DID_GSCID 字段保存 GSCID，PID_PSCID 字段保存 PSCID。</td>
    </tr>
    <tr>
        <td>63</td>
        <td>OF</td>
        <td>RW</td>
        <td>溢出状态或中断禁用</td>
    </tr>
</table>

<p>下表总结了支持按 ID 过滤的事件的过滤选项。</p>
<p>表 15. 过滤选项</p>
<table>
    <tr>
        <th>IDT</th>
        <th>DV_GSCV</th>
        <th>PV_PSCV </th>
        <th>Operation</th>
    </tr>
    <tr>
        <td>0/1 </td>
        <td>0</td>
        <td>0</td>
        <td>计数器递增。没有基于 ID 的过滤。</td>
    </tr>
    <tr>
        <td>0</td>
        <td>0</td>
        <td>1 </td>
        <td>如果事务具有有效的 process_id，并且 process_id 与 PID_PSCID 匹配，则计数器会递增。</td>
    </tr>
    <tr>
        <td>0 </td>
        <td>1 </td>
        <td>0 </td>
        <td>如果 device_id 与 DID_GSCID 匹配，则计数器递增。</td>
    </tr>
    <tr>
        <td>0 </td>
        <td>1 </td>
        <td>1 </td>
        <td>如果事务具有有效的 process_id，且 device_id 与 DID_GSCID 匹配并且 process_id 与 PID_PSCID 匹配，则计数器会递增。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>如果事务具有有效的 PSCID，并且该进程的 PSCID 与 PID_PSCID 匹配，则计数器会递增。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1 </td>
        <td>0</td>
        <td>如果 GSCID 有效且与 DID_GSCID 匹配，则计数器递增。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>如果 GSCID 有效且与 DID_GSCID 匹配且 PSCID 有效且与 PID_PSCID 匹配，则计数器递增。</td>
    </tr>
</table>

<p>当选择按 device_id 或 GSCID 进行过滤并且事件支持基于 ID 的过滤时，DMASK 字段可用于配置部分匹配。当 DMASK 设置为 1 时，将对事务执行 DID_GSCID 的部分匹配。 DID_GSCID 的低位一直到第一个低位 0 位（包括 0 位位置本身）都被屏蔽。</p>
<p>以下示例说明了 DMASK 的使用以及按 device_id 进行过滤。</p>
<p>表 16. IDT 设置为基于 device_id 的过滤的 DMASK</p>
<table>
    <tr>
        <th>DMASK</th>
        <th>DID_GSCID </th>
        <th>Comment</th>
    </tr>
    <tr>
        <td>0</td>
        <td>yyyyyyyy yyyyyyyy yyyyyyyy </td>
        <td>一个特定的 <br>One specific seg:bus:dev:func</td>
    </tr>
    <tr>
        <td>1</td>
        <td>yyyyyyyy yyyyyyyy yyyyy011 </td>
        <td>seg:bus:dev - any func</td>
    </tr>
    <tr>
        <td>1</td>
        <td>yyyyyyyy yyyyyyyy 01111111  </td>
        <td>seg:bus - any dev:func</td>
    </tr>
    <tr>
        <td>1</td>
        <td>yyyyyyyy 01111111 11111111 </td>
        <td>seg - any bus:dev:func</td>
</tr></table>

<p>下表列出了可统计的标准事件：</p>
<table>
    <tr>
        <th>eventID</th>
        <th>Event counted </th>
        <th>IDT settings supported</th>
    </tr>
    <tr>
        <td>0</td>
        <td>不计 </td>
        <td> </td>
    </tr>
    <tr>
        <td>1</td>
        <td>未翻译的请求 </td>
        <td>0</td>
    </tr>
    <tr>
        <td>2</td>
        <td>翻译后的请求  </td>
        <td>0</td>
    </tr>
    <tr>
        <td>3</td>
        <td>ATS 翻译请求</td>
        <td>0</td>
    </tr>
    <tr>
        <td>4</td>
        <td>TLB未命中 </td>
        <td>0/1</td>
    </tr>
    <tr>
        <td>5</td>
        <td>设备目录遍历 </td>
        <td>0</td>
    </tr>
    <tr>
        <td>6</td>
        <td>进程目录遍历  </td>
        <td>0</td>
    </tr>
    <tr>
        <td>7</td>
        <td>第一阶段页表遍历</td>
        <td>0/1</td>
    </tr>
    <tr>
        <td>8</td>
        <td>第二阶段页表遍历  </td>
        <td>0</td>
    </tr>
    <tr>
        <td>9 - 16383</td>
        <td>为未来标准保留</td>
        <td>-</td>
    </tr>
</table>

<p>当事件不支持编程的 IDT 设置时，相关计数器不会递增。</p>
<p>OF 位在相应的 iohpmctr1-31 计数器溢出时置位，并保持置位状态直至被软件清零。由于iohpmctr1-31值是无符号值，因此溢出被定义为无符号溢出。请注意，溢出后不会丢失信息，因为计数器会回绕并在粘性 OF 位保持设置状态时继续计数。</p>
<p>如果当关联的 OF 位为零时 iohpmctr1-31 计数器溢出，则通过将 ipsr.pmip 位设置为 1 来生成 HPM 计数器溢出中断。如果 OF 位已经为 1，则不会生成中断请求。因此，OF 位还用作相关 iohpmctr1-31 的计数溢出中断禁用。</p>
<blockquote>
<p>没有单独的溢出状态和溢出中断使能位。实际上，启用溢出中断生成（通过清除 OF 位）是与将计数器初始化为起始值一起完成的。一旦计数器溢出，必须重新初始化计数器和 OF 位，然后才能生成另一个溢出中断。</p>
</blockquote>
<blockquote>
<p>在 RV32 中，对 iohpmevt1-31 的内存映射写入仅修改寄存器的一个 32 位部分。以下序列可用于更新寄存器，而不会由于寄存器的中间值而对事件进行虚假计数：</p>
<ul>
<li>写入低位 32 位以将 eventID 设置为 0。</li>
<li>将新的所需值写入高位32 位。</li>
<li>将新的所需值写入低位32 位，包括eventID 字段的值。</li>
</ul>
<p>或者，计数器可以首先被禁止，使得在更新期间没有事件计数，并且在寄存器已经被编程有期望值之后去除禁止。</p>
</blockquote>
<blockquote>
<p>如果功能.HPM 为 1，则除了周期计数器之外，还需要至少一个可编程事件计数器才能符合此规范。可以以时间复用方式使用一个计数器来对事件进行采样，但是这样的分析可能需要更长的时间才能完成。与 CPU MMU 不同，IOMMU 服务于多个 IO 流，并且性能分析师可以使用 HPM 来同时分析这些流中的一个或多个。通常，性能分析师可能需要四个可编程计数器来对 IO 流的事件进行计数。为了支持至少两个 IO 流的并发分析，建议支持七个可编程计数器。</p>
</blockquote>
<h2 id="5-24-翻译请求-IOVA-tr-req-iova"><a href="#5-24-翻译请求-IOVA-tr-req-iova" class="headerlink" title="5.24.翻译请求 IOVA (tr_req_iova)"></a>5.24.翻译请求 IOVA (tr_req_iova)</h2><p>tr_req_iova 是一个 64 位寄存器，用于实现调试转换请求接口。</p>
<p>当 capabilities.DBG &#x3D;&#x3D; 1 时，该寄存器存在</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810141126482-1730797861486-115.png" alt="image-20230810141126482"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>11:0</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用</td>
    </tr>
    <tr>
        <td>63:12</td>
        <td>vpn</td>
        <td>WARL</td>
        <td>IOVA 虚拟页号</td>
    </tr>
</table>

<h2 id="5-25-翻译请求控制-tr-req-ctl"><a href="#5-25-翻译请求控制-tr-req-ctl" class="headerlink" title="5.25.翻译请求控制 (tr_req_ctl)"></a>5.25.翻译请求控制 (tr_req_ctl)</h2><p>tr_req_ctl 是一个 64 位 WARL 寄存器，用于实现调试转换请求接口。当 features.DBG &#x3D;&#x3D; 1 时，该寄存器出现。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810141313111-1730797861486-119.png" alt="image-20230810141313111"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>0</td>
        <td>Go/Busy</td>
        <td>RW1S</td>
        <td>该位设置为指示 tr_req_iova/tr_req_ctl 寄存器中已设置有效请求以供 IOMMU 进行转换。<br>IOMMU 通过将该位清除为 0 来指示所请求的转换已完成。完成后，转换结果将保存在 tr_response 寄存器中。</td>
    </tr>
    <tr>
        <td>1</td>
        <td>Priv</td>
        <td>WARL</td>
        <td>如果设置为 1，则请求特权模式访问，否则不请求特权模式访问。</td>
    </tr>
    <tr>
        <td>2</td>
        <td>Exe</td>
        <td>WARL</td>
        <td>如果设置为 1，则请求执行权限，否则不请求执行权限。</td>
    </tr>
    <tr>
        <td>3</td>
        <td>NW</td>
        <td>WARL </td>
        <td>如果设置为 1，则请求读取权限。如果设置为 0，则请求读取和写入权限。</td>
    </tr>
    <tr>
        <td>11:4</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用。</td>
    </tr>
    <tr>
        <td>31:12 </td>
        <td>PID </td>
        <td>WARL </td>
        <td>如果 PV 为 1，则此字段提供此转换请求的 process_id 输入。如果 PV 为 0，则不使用该字段。</td>
    </tr>
    <tr>
        <td>32</td>
        <td>PV</td>
        <td>WARL</td>
        <td>如果设置为 1，则寄存器的 PID 字段有效，并为此转换请求提供 process_id。如果设置为 0，则不使用 PID 字段，并且 process_id 对于该转换请求无效。</td>
    </tr>
    <tr>
        <td>35:33</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用。</td>
    </tr>
    <tr>
        <td>39:36 </td>
        <td>custom</td>
        <td>WPRI</td>
        <td>指定用于定制用途</td>
    </tr>
    <tr>
        <td>63:40 </td>
        <td>DID</td>
        <td>WARL</td>
        <td>此字段提供此转换请求的 device_id。</td>
    </tr>
</table>

<h2 id="5-26-翻译响应-tr-response"><a href="#5-26-翻译响应-tr-response" class="headerlink" title="5.26.翻译响应 (tr_response)"></a>5.26.翻译响应 (tr_response)</h2><p>tr_response 是一个 64 位 RO 寄存器，用于保存使用转换请求接口请求的转换结果。当 features.DBG &#x3D;&#x3D; 1 时，该寄存器出现。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810142124127-1730797861486-121.png" alt="image-20230810142124127"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>0</td>
        <td>fault</td>
        <td>RO</td>
        <td>如果转换 IOVA 的过程检测到故障，则故障字段设置为 1。可以通过故障队列报告检测到的故障。</td>
    </tr>
    <tr>
        <td>6:1</td>
        <td>reserved</td>
        <td>RO</td>
        <td>保留供标准使用</td>
    </tr>
    <tr>
        <td>8:7</td>
        <td>PBMT</td>
        <td>RO</td>
        <td>使用用于转换的第一阶段和/或第二阶段页表中的PBMT字段来确定用于转换的存储器类型。如果故障字段为 1，则该字段的值是未指定的。</td>
    </tr>
    <tr>
        <td>9 </td>
        <td>S</td>
        <td>RO </td>
        <td>翻译范围大小字段，当设置为 1 时，表示翻译适用于大于 4 KiB 的范围，并且翻译范围的大小在 PPN 字段中进行编码。如果故障字段为 1，则该字段的值为 UNSPECIFIED。</td>
    </tr>
    <tr>
        <td>53:10</td>
        <td>PPN</td>
        <td>RO</td>
        <td>如果故障位为 0，则该字段提供由 tr_req_iova 中的 vpn 转换结果确定的 PPN。<br>如果故障位为 1，则该字段的值为 UNSPECIFIED。<br>如果 S 位为 0，则转换的大小为 4 KiB - 一页。<br>如果 S 位为 1，则转换会产生超级页面，并且超级页面的大小在 PPN 本身中进行编码。如果从位位置 0 扫描到位位置 43，即位置 X 处值为 0 的第一位，则超级页大小为 2 <sup>X+1</sup> * 4 KiB。<br>如果 X 不为 0，则位置 0 到 X-1 处的所有位均编码为值 1。<br>表 18. PPN 中超级页面大小的编码示例<br><table>
            <tr>
                <th>PPN</th>
                <th>S</th>
                <th>Size</th>
            </tr>
            <tr>
                <td>yyyy….yyyy yyyy yyyy </td>
                <td> 0 </td>
                <td> 4 KiB</td>
            </tr>
            <tr>
                <td>yyyy….yyyy yyyy 0111 </td>
                <td> 1 </td>
                <td> 64 KiB</td>
            </tr>
            <tr>
                <td>yyyy….yyy0 1111 1111 </td>
                <td> 1 </td>
                <td> 2 MiB</td>
            </tr>
            <tr>
                <td>yyyy….yy01 1111 1111 </td>
                <td> 1 </td>
                <td> 4 MiB</td>
            </tr>
            </table></td>
    </tr>
    <tr>
        <td>59:54 </td>
        <td>reserved </td>
        <td>RO </td>
        <td>指定用于定制用途</td>
    </tr>
    <tr>
        <td>63:60</td>
        <td>custom</td>
        <td>RO</td>
        <td>保留供标准使用</td>
    </tr>
</table>

<blockquote>
<p>IOMMU 实现不需要报告超级页面转换或支持报告所有可能的超级页面大小。允许实现报告与所请求的 VPN 相对应的 4 KiB 转换或报告小于页表中配置的超级页面大小的转换大小。</p>
</blockquote>
<h2 id="5-27-中断原因到向量寄存器-icvec"><a href="#5-27-中断原因到向量寄存器-icvec" class="headerlink" title="5.27.中断原因到向量寄存器 (icvec)"></a>5.27.中断原因到向量寄存器 (icvec)</h2><p>中断原因到向量寄存器将原因映射到向量。所有原因都可以映射到相同的向量，或者可以给一个原因一个唯一的向量。</p>
<p>使用向量：</p>
<ol>
<li><p>通过生成中断作为 MSI 的 IOMMU，索引 MSI 配置表 (msi_cfg_tbl) 以确定要生成的 MSI。如果capabilities.IGS=&#x3D;MSI 或capabilities.IGS=&#x3D;BOTH，则 IOMMU 能够生成作为 MSI 的中断。当capabilities.IGS=&#x3D;BOTH时，IOMMU可以配置为通过将fctl.WSI设置为0来生成MSI中断。</p>
</li>
<li><p>由生成 WSI 的 IOMMU 来确定发出中断信号的线路。如果capabilities.IGS=&#x3D;WSI 或 capabilities.IGS=&#x3D;BOTH，则 IOMMU 能够生成线信号中断。当capabilities.IGS=&#x3D;BOTH时，IOMMU可以配置为通过将fctl.WSI设置为1来生成线信号中断。</p>
</li>
</ol>
<p>如果实现仅支持单个向量，则该寄存器的所有位可以硬连线为 0 (WARL)。同样，如果仅支持两个向量，则每个原因只有位 0 是可写的。</p>
<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810143715581-1730797861486-123.png" alt="image-20230810143715581"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>3:0</td>
        <td>civ</td>
        <td>WARL</td>
        <td>命令队列中断向量 (civ) 是分配给命令队列中断的向量编号。</td>
    </tr>
    <tr>
        <td>7:4 </td>
        <td>fiv</td>
        <td>WARL</td>
        <td>故障队列中断向量 (fiv) 是分配给故障队列中断的向量号。</td>
    </tr>
    <tr>
        <td>11:8</td>
        <td>pmiv</td>
        <td>WARL</td>
        <td>性能监控中断向量 (pmiv) 是分配给性能监控中断的向量号。</td>
    </tr>
    <tr>
        <td>15:12</td>
        <td>piv</td>
        <td>WARL </td>
        <td>页请求队列中断向量 (piv) 是分配给页请求队列中断的向量号。</td>
    </tr>
    <tr>
        <td>31:16</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用。</td>
    </tr>
    <tr>
        <td>63:32 </td>
        <td>custom</td>
        <td>WPRI</td>
        <td>指定用于定制用途</td>
    </tr>
</table>

<h2 id="5-28-MSI-配置表-msi-cfg-tbl"><a href="#5-28-MSI-配置表-msi-cfg-tbl" class="headerlink" title="5.28. MSI 配置表 (msi_cfg_tbl)"></a>5.28. MSI 配置表 (msi_cfg_tbl)</h2><p>支持生成 IOMMU 发起的中断（即，capability.IGS &#x3D;&#x3D; MSI 或capability.IGS &#x3D;&#x3D; BOTH）作为 MSI 的 IOMMU 实现了 MSI 配置表，该配置表由来自 icvec 的向量索引以确定 MSI 表条目。中断向量 x 的每个 MSI 表条目具有三个寄存器 msi_addr_x、msi_data_x 和 msi_vec_ctl_x。如果capabilities.IGS &#x3D;&#x3D; WSI，这些寄存器硬连线为0。</p>
<p>如果使用 msi_addr_x 在 MSI 写入中检测到访问故障，则 IOMMU 会报告“IOMMU MSI 写入访问故障”（原因 273）故障，并将 TTYP 设置为 0，并将 iotval 设置为 msi_addr_x 的值。</p>
<p>表 19. MSI 配置表结构</p>
<table>
    <tr>
        <th>bit 63</th>
        <th align="right">bit 0</th>
        <th>Byte Offset</th>
    </tr>
    <tr>
        <td align="center" colspan="2">Entry 0:Message address</td>
        <td>+000h</td>
    </tr>
    <tr>
        <td align="center">Entry 0:Vector Control</td>
        <td align="center">Entry 0:Message Data</td>
        <td>+008h</td>
    </tr>
    <tr>
        <td align="center" colspan="2">Entry 1:Message address</td>
        <td>+010h</td>
    </tr>
    <tr>
        <td align="center">Entry 1:Vector Control</td>
        <td align="center">Entry 1:Message Data</td>
        <td>+018h</td>
    </tr>
    <tr>
        <td align="center" colspan="2">……</td>
        <td>+020h</td>
    </tr>
</table>


<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810145214359-1730797861486-125.png" alt="image-20230810145214359"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>1:0</td>
        <td>0</td>
        <td>RO</td>
        <td>固定为 0</td>
    </tr>
    <tr>
        <td>55:2 </td>
        <td>ADDR</td>
        <td>WARL</td>
        <td>保存 4 字节对齐的 MSI 地址。</td>
    </tr>
    <tr>
        <td>63:56</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用。</td>
    </tr>
</table>

<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810145359660-1730797861486-127.png" alt="image-20230810145359660"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>31:0</td>
        <td>data</td>
        <td>WARL</td>
        <td>保存MSI数据</td>
    </tr>
</table>


<p><img src="/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/image-20230810145641174-1730797861486-129.png" alt="image-20230810145641174"></p>
<table>
    <tr>
        <th>Bits</th>
        <th>Field</th>
        <th>Attribute</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>0</td>
        <td>M</td>
        <td>RW</td>
        <td>当屏蔽位M为1时，对应的中断向量被屏蔽，并且禁止IOMMU发送相关消息。如果相应的掩码位清除为 0，则稍后会生成该向量的待处理消息。</td>
    </tr>
    <tr>
        <td>31:0</td>
        <td>reserved</td>
        <td>WPRI</td>
        <td>保留供标准使用</td>
    </tr>
</table>

<h1 id="第-6-章-软件指南"><a href="#第-6-章-软件指南" class="headerlink" title="第 6 章 软件指南"></a>第 6 章 软件指南</h1><p>本节为软件开发人员提供有关使用 IOMMU 接口的正确和预期顺序的指南。如果不遵循这些准则，IOMMU 的行为是由实现定义的。</p>
<h2 id="6-1-读写IOMMU寄存器"><a href="#6-1-读写IOMMU寄存器" class="headerlink" title="6.1.读写IOMMU寄存器"></a>6.1.读写IOMMU寄存器</h2><p>对IOMMU 寄存器的读或写访问必须遵循以下规则：</p>
<ul>
<li>访问的地址必须与访问的大小对齐。</li>
<li>访问不得跨越多个寄存器。</li>
<li>可以使用32 位或64 位访问来访问64 位宽的寄存器。</li>
<li>32 位宽的寄存器只能使用32 位访问进行访问。</li>
</ul>
<h2 id="6-2-初始化指南"><a href="#6-2-初始化指南" class="headerlink" title="6.2.初始化指南"></a>6.2.初始化指南</h2><p>初始化 IOMMU 的指导原则如下： </p>
<ol>
<li><p>读取功能寄存器以发现 IOMMU 的功能。</p>
</li>
<li><p>如果不支持capabilities.version，则停止并报告失败。</p>
</li>
<li><p>读取功能控制寄存器（fctl）。</p>
</li>
<li><p>如果需要大端内存访问且capabilities.END字段为0（即只有一种端序）并且fctl.BE为0（即小端序），则停止并报告失败。</p>
</li>
<li><p>如果需要大端内存访问且capabilities.END字段为1（即支持两个endianness），则如果该字段尚未为1，则将fctl.BE设置为1（例如big-endia）。</p>
</li>
<li><p>如果 IOMMU 初始化是有线信号中断并且capabilities.IGS 不是 WSI，则停止并报告故障。。</p>
</li>
<li><p>如果 IOMMU 初始化是有线信号中断并且capabilities.IGS  是both，当 fctl.WSI 未为 1，则将其设置为 1。</p>
</li>
<li><p>如果不支持其他所需功能（例如虚拟寻址模式、MSI 转换等），则停止并报告失败。</p>
</li>
<li><p>icvec寄存器用于为每个中断原因编程一个中断向量。通过向每个字段写入0xF并读回可写位的数量，确定IOMMU支持的矢量数量。如果可写比特的数量是N，则支持的向量的数量是2^N^。对于每个原因C，将向量V与该原因相关联。V是一个介于0和（2^N^-1）之间的数字。</p>
</li>
<li><p>如果IOMMU被配置为使用有线中断，那么每个向量V对应于连接到平台级中断控制器（例如APLIC）的中断线路。使用由诸如设备树之类的配置机制提供的配置信息来确定要为每个这样的线路编程的中断控制器配置寄存器，并对中断控制器进行编程。</p>
</li>
<li><p>如果IOMMU被配置为使用MSI，那么每个向量V都是MSI_cfg_tbl的索引。对于每个矢量V，分配一个MSI地址a和一个中断标识D。用值a配置MSI_adr_V寄存器，用值D配置MSI_data_V寄存器。在MSI_vec_ctl_V寄存器中适当配置中断掩码M。</p>
</li>
<li><p>要对命令队列进行编程，首先确定命令队列中所需的条目数N。命令队列中的条目数必须是2的幂。<br>分配一个N x 16字节大小的内存缓冲区，该缓冲区自然与4-KiB或N x 16个字节中的较大者对齐。设k&#x3D;log<del>2</del>（N），B为所分配内存缓冲区的物理页码（PPN）。按如下方式对命令队列寄存器进行编程：</p>
<ul>
<li><p>temp_cqb_var.PPN &#x3D; B </p>
</li>
<li><p>temp_cqb_var.LOG2SZ-1 &#x3D; (k - 1) </p>
</li>
<li><p>cqb &#x3D; temp_cqb_var </p>
</li>
<li><p>cqt &#x3D; 0 </p>
</li>
<li><p>cqcsr.cqen &#x3D; 1 </p>
</li>
<li><p>Poll on cqcsr.cqon until it reads 1</p>
</li>
</ul>
</li>
<li><p>要对故障队列进行编程，首先确定故障队列中所需的条目数N。故障队列中的条目数始终是2的幂。分配一个N x 32字节大小的内存缓冲区，该缓冲区自然与4-KiB或N x 32个字节中的较大者对齐。设k&#x3D;log2（N），B为所分配的内存缓冲区的PPN。对故障队列寄存器进行编程，如下所示：</p>
<ul>
<li><p>temp_fqb_var.PPN &#x3D; B </p>
</li>
<li><p>temp_fqb_var.LOG2SZ-1 &#x3D; (k - 1) </p>
</li>
<li><p>fqb &#x3D; temp_fqb_var </p>
</li>
<li><p>fqh &#x3D; 0 </p>
</li>
<li><p>fqcsr.fqen &#x3D; 1 </p>
</li>
<li><p>Poll on fqcsr.fqon until it reads 1</p>
</li>
</ul>
</li>
<li><p>要对页面请求队列进行编程，首先确定页面请求队列中所需的条目数N。页面请求队列中的条目数总是2的幂。<br>分配一个N x 16字节大小的缓冲区，该缓冲区自然与4-KiB或N x 16个字节中的较大者对齐。设k&#x3D;log2（N），B为所分配的内存缓冲区的PPN。对页面请求队列寄存器进行编程，如下所示：</p>
<ul>
<li><p>temp_pqb_var.PPN &#x3D; B </p>
</li>
<li><p>temp_pqb_var.LOG2SZ-1 &#x3D; (k - 1) </p>
</li>
<li><p>pqb &#x3D; temp_pqb_var </p>
</li>
<li><p>pqh &#x3D; 0 </p>
</li>
<li><p>pqcsr.pqen &#x3D; 1 </p>
</li>
<li><p>Poll on pqcsr.pqon until it reads 1</p>
</li>
</ul>
</li>
<li><p>要对DDT指针进行编程，首先确定支持的device_id宽度Dw和设备上下文数据结构的格式。如果capabilities.MSI为0，则IOMMU使用基本格式设备上下文，否则使用扩展格式设备上下文。分配一页（4 KiB）内存用作DDT的根表。将分配的内存初始化为所有0。设B为已分配内存的PPN。根据Dw和IOMMU设备上下文格式确定DDT的模式M，如下所示：</p>
<ol>
<li>通过写入合法值并读取该值以查看该值是否被保留，来确定ddtp.iommu_mode支持的值。如果支持的模式不支持所需的Dw，则停止并报告故障。</li>
<li>如果使用扩展格式设备上下文，则<ul>
<li>a.如果Dw小于或等于6位并且支持1LVL，则M＝1LVL </li>
<li>b.如果Dw小于或等于15位并且支持2LVL, 则M＝2LVL</li>
<li>c.如果Dw小于或等于24位并且支持3LVL，则M＝3LVL</li>
</ul>
</li>
<li>如果使用基本格式设备上下文，则<ul>
<li>a. 如果Dw小于或等于7位并且支持1LVL，则M＝1LVL </li>
<li>b. 如果Dw小于或等于16位并且支持2LVL，则M＝2LVL </li>
<li>c. 如果Dw小于或等于24位并且支持3LVL，则M＝3LVL</li>
</ul>
</li>
</ol>
<p>按如下方式编程ddtp寄存器：</p>
<p>temp_ddtp_var.iommu_mode&#x3D;M<br>temp_ddtp_var.PPN&#x3D;B<br>ddtp&#x3D;temp_ddtp_var</p>
</li>
</ol>
<p>IOMMU被初始化，并且现在可以用IOMMU范围内的设备的设备上下文来配置IOMMU。</p>
<h2 id="6-3-无效指南"><a href="#6-3-无效指南" class="headerlink" title="6.3.无效指南"></a>6.3.无效指南</h2><p>本节为软件提供有关修改 IOMMU 内存中数据结构时通过 CQ 发送到 IOMMU 的无效命令的指南。软件必须在更新全局可见后执行失效操作。 FENCE 指令提供的存储排序以及原子指令上的获取&#x2F;释放位还对与 IOMMU 观察到的那些存储关联的数据结构更新进行排序。</p>
<p>软件可以使用IOFENCE.C命令来确保从CQ获取的所有先前命令已经完成并提交。 PR 和&#x2F;或 PW 位可以在 IOFENCE.C 命令中设置为 1，以请求所有先前已由 IOMMU 处理的读和&#x2F;或写请求作为全局排序点的一部分提交到全局排序点。 IOFENCE.C 命令。</p>
<h3 id="6-3-1-更改设备目录表条目"><a href="#6-3-1-更改设备目录表条目" class="headerlink" title="6.3.1.更改设备目录表条目"></a>6.3.1.更改设备目录表条目</h3><p>如果软件更改了叶级 DDT 条目（即 device_id &#x3D; D 的设备的设备上下文 (DC)），则必须执行以下失效操作：</p>
<ul>
<li>IODIR.INVAL_DDT，DV&#x3D;1 且 DID&#x3D;D </li>
<li>如果 DC.tc.PDTV&#x3D;&#x3D;1，则 IODIR.INVAL_PDT，DV&#x3D;1、PV&#x3D;0 和 DID&#x3D;D</li>
<li>如果 DC.iohgatp.MODE !&#x3D; Bare </li>
<li>IOTINVAL.VMA，GV&#x3D;1、AV&#x3D;PSCV&#x3D;0 和 GSCID&#x3D;DC.iohgatp.GSCID </li>
<li>IOTINVAL.GVMA，GV&#x3D;1、AV&#x3D;0 和 GSCID&#x3D;DC .iohgatp.GSCID</li>
<li>else </li>
<li>if DC.tc.PDTV&#x3D;&#x3D;1 || DC.tc.PDTV &#x3D;&#x3D; 0 &amp;&amp; DC.fsc.MODE &#x3D;&#x3D; Bare<br>-  IOTINVAL.VMA，GV&#x3D;AV&#x3D;PSCV&#x3D;0 </li>
<li>else<br>-  IOTINVAL.VMA，GV&#x3D;AV&#x3D;0 且 PSCV&#x3D;1，且 PSCID&#x3D;DC .ta.PSCID</li>
</ul>
<p>如果软件更改非叶级 DDT 条目，则必须执行以下无效操作：</p>
<p> • IODIR.INVAL_DDT，DV&#x3D;0 </p>
<p>在 DDT 条目更改和 IOMMU 处理使缓存条目无效的无效命令之间， IOMMU 可以使用条目的旧值或新值。</p>
<h3 id="6-3-2-更改进程目录表条目"><a href="#6-3-2-更改进程目录表条目" class="headerlink" title="6.3.2.更改进程目录表条目"></a>6.3.2.更改进程目录表条目</h3><p>如果软件更改叶级 PDT 条目（即进程上下文 (PC)，对于 device_id&#x3D;D 和 process_id&#x3D;P），则必须执行以下失效操作：</p>
<ul>
<li>IODIR.INVAL_PDT，DV&#x3D;1、PV&#x3D;1、DID &#x3D;D 且 PID&#x3D;P </li>
<li>if   DC.iohgatp.MODE !&#x3D; Bare </li>
<li>IOTINVAL.VMA，GV&#x3D;1、AV&#x3D;0、PV&#x3D;1、GSCID&#x3D;DC.iohgatp.GSCID 和 PSCID&#x3D;PC.PSCID </li>
<li>else </li>
<li>IOTINVAL.VMA，其中 GV&#x3D;0、AV&#x3D;0、PV&#x3D;1 和 PSCID&#x3D;PC.PSCID</li>
</ul>
<p>在 PDT 条目更改与 IOMMU 处理使缓存条目无效的无效命令之间，IOMMU 可以使用条目的旧值或新值。</p>
<h3 id="6-3-3-更改-MSI-页表条目"><a href="#6-3-3-更改-MSI-页表条目" class="headerlink" title="6.3.3.更改 MSI 页表条目"></a>6.3.3.更改 MSI 页表条目</h3><p>如果软件更改了由对应于未翻译的 MSI 地址 A 的中断文件号 I 标识的 MSI 页表条目，则必须执行以下失效操作：</p>
<ul>
<li>IOTINVAL.GVMA，GV&#x3D;AV&#x3D;1、ADDR[63:12]&#x3D;A[63:12] 和 GSCID&#x3D;DC.iohgatp.GSCID</li>
</ul>
<p>要使 MSI 页表中的所有缓存条目失效，必须执行以下失效操作：</p>
<ul>
<li>IOTINVAL.GVMA，GV&#x3D;1、AV&#x3D;0 和 GSCID&#x3D;DC.iohgatp.GSCID</li>
</ul>
<p>在对 MSI PTE 的更改与 IOMMU 处理使缓存的 PTE 无效的无效命令之间，IOMMU 可以使用旧的 PTE 值或新的 PTE 值。 PW&#x3D;1 的 IOFENCE.C 命令可用于确保之前由 IOMMU 处理的所有先前写入（包括 MSI 写入）都提交到全局排序点，以便所有 RISC-V 都可以观察到它们系统中的 Hart 和 IOMMU。</p>
<h3 id="6-3-4-更改第二阶段页表项"><a href="#6-3-4-更改第二阶段页表项" class="headerlink" title="6.3.4.更改第二阶段页表项"></a>6.3.4.更改第二阶段页表项</h3><p>如果软件更改了 VM 的叶第二阶段页表条目，且该更改会影响 Guest-PPN G 的转换，则必须执行以下失效操作： </p>
<ul>
<li>IOTINVAL.GVMA，其中 GV&#x3D;AV&#x3D;1、GSCID&#x3D;DC.iohgatp .GSCID 和 ADDR[63:12]&#x3D;G</li>
</ul>
<p>如果软件更改了 VM 的非叶第二阶段页表条目，则必须执行以下失效操作： </p>
<ul>
<li>IOTINVAL.GVMA，其中 GV&#x3D;1、AV&#x3D;0、 GSCID&#x3D;DC.iohgatp.GSCID</li>
</ul>
<p>DC 具有保存 Guest-PPN 的字段。实现可以将这些字段转换为supervisor-PPN，作为缓存DC的一部分。如果第二阶段页表更新影响 DC 中保存的 Guest-PPN 的转换，则软件必须使用 IODIR.INVAL_DDT（DV&#x3D;1 且 DID 设置为相应的 device_id）使所有此类缓存的 DC 无效。或者，DV&#x3D;0 的 IODIR.INVAL_DDT 可用于使所有缓存的 DC 无效。</p>
<p>在对第二阶段PTE的改变和IOMMU处理使缓存的PTE无效的无效命令之间，IOMMU可以使用旧的PTE值或新的PTE值。</p>
<h3 id="6-3-5-更改第一阶段页表项"><a href="#6-3-5-更改第一阶段页表项" class="headerlink" title="6.3.5.更改第一阶段页表项"></a>6.3.5.更改第一阶段页表项</h3><p>DC可以配置有第一级页表（当DC.tc.PDTV&#x3D;0时）或使用进程目录表中的process_id选择的第一级页表的目录（当DC.tc.PDTV&#x3D;1时） ）。</p>
<p>当对第一阶段页表进行更改且第二阶段为裸时，软件必须使用 GV&#x3D;0 的 IOTINVAL.VMA 以及适用于表 9 中指定的修改的 AV 和 PSCV 操作数来执行失效。</p>
<p>当对第一阶段页表进行更改且第二阶段不是 Bare 时，软件必须使用 GV&#x3D;1、GSCID&#x3D;DC.iohgatp.GSCID 以及适用于以下情况的 IOTINVAL.VMA 执行失效操作：修改如表9所示。</p>
<p>在对第一阶段PTE的改变和IOMMU处理使缓存的PTE无效的无效命令之间，IOMMU可以使用旧的PTE值或新的PTE值。</p>
<h3 id="6-3-6-已访问-A-脏-D-位更新和页面升级"><a href="#6-3-6-已访问-A-脏-D-位更新和页面升级" class="headerlink" title="6.3.6.已访问 (A)&#x2F;脏 (D) 位更新和页面升级"></a>6.3.6.已访问 (A)&#x2F;脏 (D) 位更新和页面升级</h3><p>当 IOMMU 支持硬件管理的 A 和 D 位更新时，如果软件清除第一阶段和&#x2F;或第二阶段 PTE 中的 A 和&#x2F;或 D 位，则软件必须使 IOMMU 缓存的相应 PTE 条目无效。如果不执行此类失效，则 IOMMU 在处理使用此类条目的后续事务时可能不会设置这些位。</p>
<p>当软件将第一阶段 PT 和&#x2F;或第二阶段 PT 中的页面升级为超级页面而没有首先清除原始非叶 PTE 的有效位并使 IOMMU 中缓存的转换无效时，IOMMU 可能会缓存多个匹配单个地址的条目。 IOMMU 可以使用旧的非叶 PTE 或新的非叶 PTE，但行为在其他方面已明确定义。</p>
<p>当提升和&#x2F;或降级页面大小时，软件必须确保原始 PTE 和新 PTE 具有相同的权限和内存类型属性，并且使用原始 PTE 或新 PTE 进行转换而确定的物理地址对于任何页面都是相同的。给定输入。 IOMMU 支持的唯一 PTE 更新（无需首先清除原始 PTE 中的 V 位并执行适当的 IOTINVAL 命令）是执行页面大小提升或降级。如果以这种方式更改其他属性，则 IOMMU 的行为是实现定义的。</p>
<h3 id="6-3-7-设备地址转换缓存失效"><a href="#6-3-7-设备地址转换缓存失效" class="headerlink" title="6.3.7.设备地址转换缓存失效"></a>6.3.7.设备地址转换缓存失效</h3><p>当第一阶段和&#x2F;或第二阶段页表被修改时，可能需要对可能已经缓存了来自修改的页表的翻译的设备中的DevATC进行无效化。此类页表的失效需要使用 ATS.INVAL 命令生成 ATS 失效。软件必须按照 PCIe ATS 规范 [1] 中定义的规则指定有效负载。</p>
<p>如果软件以超过平均 DevATC 服务速率的速率生成 ATS 无效请求，则设备可能会触发流量控制机制来限制速率。这样做的副作用是拥塞扩散到其他通道和链路，这可能导致性能下降。支持 ATS 的设备会通过 ATS 功能结构的队列深度字段发布在引起背压之前可以缓冲的最大失效数量。当使用 PCIe SR-IOV 虚拟化设备时，该队列深度在设备的所有 VF 之间共享。软件必须将排队的未完成 ATS 失效数量限制为设备公布的限制。</p>
<p>RID字段用于指定ATS失效请求消息目的地的路由ID。可以通过设置PV&#x3D;1并在PID中指定PASID来执行PASID特定无效。当 IOMMU 支持多个段时，RID 必须通过目标段号进行限定，方法是使用 DSEG 中提供的段号设置 DSV&#x3D;1。</p>
<p>当设备启用 ATS 协议时，除了向 DevATC 提供翻译之外，IOMMU 仍可以在其 IOATC 中缓存翻译。即使在设备的设备上下文中启用了 ATS，软件也不得跳过 IOMMU 转换缓存失效。由于来自DevATC的转换请求可以由来自IOATC的IOMMU来满足，所以为了确保正确的操作，软件必须首先使IOATC无效，然后再将无效发送到DevATC。</p>
<h3 id="6-3-8-缓存无效条目"><a href="#6-3-8-缓存无效条目" class="headerlink" title="6.3.8.缓存无效条目"></a>6.3.8.缓存无效条目</h3><p>该规范不允许缓存 V（有效）位清零的第一&#x2F;第二阶段 PTE、V（有效）位清零的非叶 DDT 条目、V（有效）位清零的设备上下文、非叶 DDT 条目。 -V（有效）位清零的叶 PDT 条目、V（有效）位清零的进程上下文或 V 位清零的 MSI PTE。</p>
<p>当将这些条目中的 V 位从 0 更改为 1 时，软件不需要执行失效操作。</p>
<h2 id="6-4-重新配置-PMA"><a href="#6-4-重新配置-PMA" class="headerlink" title="6.4.重新配置 PMA"></a>6.4.重新配置 PMA</h2><p>当平台支持 PMA 动态重新配置时，通常会提供可以正确配置平台的机器模式驱动程序。在某些可能涉及平台特定操作的平台中，如果 IOMMU 必须参与这些操作，则机器模式驱动程序将使用 IOMMU 中的平台特定操作来执行此类重新配置。</p>
<h2 id="6-5-处理-IOMMU-中断的指南"><a href="#6-5-处理-IOMMU-中断的指南" class="headerlink" title="6.5.处理 IOMMU 中断的指南"></a>6.5.处理 IOMMU 中断的指南</h2><p>IOMMU可以从CQ、FQ、PQ或HPM生成中断。每个中断源可以配置有唯一的向量，或者向量可以在一个或多个中断源之间共享。中断可以作为 MSI 或有线信号中断来传递。中断处理程序可以执行以下操作：</p>
<ol>
<li><p>读取 ipsr 寄存器以确定待处理中断的源 </p>
</li>
<li><p>如果 ipsr.cip 位置 1，则有一个来自 CQ 的待处理中断。</p>
<ol>
<li><p>读取 cqcsr 寄存器。</p>
</li>
<li><p>通过检查 cmd_to、cmd_ill 和 cqmf 位的状态来确定错误是否导致中断，如果是，则确定错误的原因。如果设置了这些位中的任何一个，则 CQ 遇到错误并且命令处理将暂时禁用。</p>
</li>
<li><p>如果发生错误，请纠正错误原因，并通过向 cqcsr 中已纠正错误对应的位写入 1 来清除这些位。</p>
<ol>
<li>清除 cqcsr 中的所有错误指示位将重新启用命令处理。</li>
</ol>
</li>
<li><p>IOFENCE.C 命令完成后，支持有线中断的 IOMMU 可能会被请求从命令队列生成中断。该原因由 fence_w_ip 位指示。请注意，当 fence_w_ip 设置为 1 时，命令处理不会停止。软件处理程序可以通过向该位写入 1 来清除该位，从而在 IOFENCE.C 完成时重新启用来自 CQ 的中断。</p>
</li>
<li><p>通过向该位写入 1 来清除 ipsr.cip。</p>
</li>
</ol>
</li>
<li><p>如果 ipsr.fip 位被置位，则来自 FQ 的中断正在等待处理。</p>
<ol>
<li><p>读取 fqcsr 寄存器。</p>
</li>
<li><p>通过检查 fqmf 和 fqof 位的状态来确定错误是否导致中断，如果是，则确定错误的原因。如果设置了这些位中的任何一个，则 FQ 遇到错误并且故障&#x2F;事件报告将暂时禁用。</p>
</li>
<li><p>如果发生错误，请纠正错误原因，并通过向 fqcsr 中已纠正错误对应的位写入 1 来清除这些位。</p>
<ol>
<li>清除 cqcsr 中的所有错误指示位将重新启用故障&#x2F;事件报告。</li>
</ol>
</li>
<li><p>通过向该位写入 1 来清除 ipsr.fip。</p>
</li>
<li><p>读取 fqt 和 fqh 寄存器。</p>
</li>
<li><p>如果 fqt 的值不等于 fqh 的值，则 FQ 不为空，并且包含需要处理的故障&#x2F;事件报告。</p>
</li>
<li><p>处理需要处理的未决故障&#x2F;事件报告，并通过将 fqh 前进处理的记录数来将其从 FQ 中删除。</p>
</li>
</ol>
</li>
<li><p>如果 ipsr.pip 位被置位，则 PQ 中的中断正在等待处理</p>
<ol>
<li><p>读取“pqcsr”寄存器。</p>
</li>
<li><p>通过检查 pqmf 和 pqof 位的状态来确定错误是否导致中断，如果是，则确定错误的原因。如果设置了这些位中的任何一个，则 PQ 遇到错误，并且“页面请求”报告将暂时禁用。</p>
</li>
<li><p>如果发生错误，请纠正错误原因，并通过向 pqcsr 中已纠正错误对应的位写入 1 来清除这些位。</p>
<ol>
<li>清除 pqcsr 中的所有错误指示位将重新启用“页面请求”报告。</li>
</ol>
</li>
<li><p>通过向该位写入 1 来清除 ipsr.pip。</p>
</li>
<li><p>读取 pqt 和 pqh 寄存器。</p>
</li>
<li><p>如果pqt的值不等于pqh的值，则PQ不为空并且包含需要处理的“页面请求”消息。</p>
</li>
<li><p>处理需要处理的未决“页面请求”消息，并通过将 pqh 前进已处理的记录数来将其从 PQ 中删除。</p>
<ol>
<li>当发生 PQ 溢出情况时，由于“页面请求”消息被丢弃，软件可能会观察到不完整的页面请求组。如果消息中的“PRG 中的最后一个请求”标志设置为 1，IOMMU 可能会自动响应（参见第 2.7 节）此类组中丢弃的“页面请求”。软件应该忽略并且不为这些不完整的组提供服务。</li>
<li>在 PQ 溢出时，对“PRG 中的最后一个请求”设置为 1 的“页面请求”的自动响应预计会导致设备重试 ATS 转换请求。然而，由于 IOMMU 生成的响应并未实际解决导致设备最初发送“页面请求”的条件，因此这可能会导致设备再次发送“页面请求”消息。如果通过在 PQ 中创建空间来纠正溢出情况，这些重试的消息现在可以存储在 PQ 中。</li>
</ol>
</li>
</ol>
</li>
<li><p>如果 ipsr.pmip 位被置位，则 HPM 的中断正在等待处理。</p>
<ol>
<li>通过向该位写入 1 来清除 ipsr.pmip。</li>
<li>处理性能监控计数器溢出。</li>
</ol>
</li>
</ol>
<h2 id="6-6-启用和禁用-ATS-和-或-PRI-的指南"><a href="#6-6-启用和禁用-ATS-和-或-PRI-的指南" class="headerlink" title="6.6.启用和禁用 ATS 和&#x2F;或 PRI 的指南"></a>6.6.启用和禁用 ATS 和&#x2F;或 PRI 的指南</h2><p>要启用 ATS 和&#x2F;或 PRI：</p>
<ol>
<li><p>将设备置于空闲状态，以便设备不生成任何事务。</p>
</li>
<li><p>如果设备的设备上下文已经有效，则首先将设备上下文标记为无效，并向 IOMMU 排队命令以使所有缓存的第一&#x2F;第二阶段页表条目、DDT 条目、MSI PT 条目（如果需要） ) 和 PDT 条目（如果需要）。</p>
</li>
<li><p>对设备上下文进行编程，将 EN_ATS 设置为 1，如果需要，将 T2GPA 字段设置为 1。如果需要，将 EN_PRI 设置为 1。如果 EN_PRI 设置为 1，则根据需要将 PRPR 设置为 1。</p>
</li>
<li><p>将设备上下文标记为有效。</p>
</li>
<li><p>启用设备以使用 ATS，并根据需要启用 PRI。</p>
</li>
</ol>
<p>要禁用 ATS 和&#x2F;或 PRI：</p>
<ol>
<li><p>将设备置于空闲状态，以便设备不生成任何事务。</p>
</li>
<li><p>在设备上禁用 ATS 和&#x2F;或 PRI 3. 在设备上下文中将 EN_ATS 和&#x2F;或 EN_PRI 设置为 0。如果 EN_ATS 设置为 0，则将 EN_PRI 和 T2GPA 设置为 0。如果 EN_PRI 设置为 0，则将 PRPR 设置为 0。</p>
</li>
<li><p>向 IOMMU 发送队列命令，使所有缓存的第一&#x2F;第二阶段页表条目、DDT 条目、MSI PT 条目（如果需要）和 PDT 条目（如果需要）无效。</p>
</li>
<li><p>将命令排队到 IOMMU，以通过生成无效请求消息来使 DevATC 无效。</p>
</li>
<li><p>启用设备中的 DMA 操作。</p>
</li>
</ol>
<h1 id="第-7-章-硬件指南"><a href="#第-7-章-硬件指南" class="headerlink" title="第 7 章  硬件指南"></a>第 7 章  硬件指南</h1><p>本节为平台中 IOMMU 的系统&#x2F;硬件集成商提供指南</p>
<h2 id="7-1-将-IOMMU-集成为-PCIe-设备"><a href="#7-1-将-IOMMU-集成为-PCIe-设备" class="headerlink" title="7.1.将 IOMMU 集成为 PCIe 设备"></a>7.1.将 IOMMU 集成为 PCIe 设备</h2><p>IOMMU 本身可以构建为 PCIe 设备，并且可以作为具有 PCIe 定义的基类 08h、子类 06h 和编程接口 00h [4] 的专用 PCIe 功能来发现。</p>
<p>此类 IOMMU 必须将本规范中定义的 IOMMU 寄存器映射为 PCIe BAR 映射寄存器。</p>
<p>IOMMU 可以支持 MSI 或 MSI-X 或两者。当支持 MSI-X 时，MSI-X 功能块必须指向 BAR 映射寄存器中的 msi_cfg_tbl，以便系统软件可以为 IOMMU 支持的每个消息配置 MSI 地址和数据对。 MSI-X PBA可以位于IOMMU的相同BAR或另一个BAR中。建议 IOMMU 支持 MSI-X 功能。</p>
<h2 id="7-2-PMA-和-PMP-的故障"><a href="#7-2-PMA-和-PMP-的故障" class="headerlink" title="7.2. PMA 和 PMP 的故障"></a>7.2. PMA 和 PMP 的故障</h2><p>IO桥可以对来自IO设备的存储器访问或由IOMMU隐式生成的存储器访问调用PMA和&#x2F;或PMP检查器以访问存储器内数据结构。当内存访问违反 PMA 检查或违反 PMP 检查时，IO 桥可能会中止内存访问（如第 7.3 节中指定）。</p>
<h2 id="7-3-中止处理"><a href="#7-3-中止处理" class="headerlink" title="7.3.中止处理"></a>7.3.中止处理</h2><p>如果中止的事务是 IOMMU 发起的隐式内存访问，则 IO 桥会向 IOMMU 本身发出此类访问错误信号。这种信令的细节是由实现定义的。</p>
<p>如果中止的事务是写入，则 IO 桥可能会丢弃该写入；如何丢弃写入的详细信息是实现定义的。如果 IO 协议需要写入事务的响应（例如 AXI），则 IO 桥可以生成 IO 协议定义的响应（例如 BRESP 上的 SLVERR - 写入响应通道）。例如，对于 PCIe，写入事务会被发布，并且当写入事务被丢弃时不会返回任何响应。</p>
<p>如果错误事务是读取，则设备期望完成。 IO桥可以为设备提供完成。此类完成中的数据（如果返回）是实现定义的；通常它是一个固定值，例如全0或全1。完成时可能会向设备返回一个状态代码以指示这种情况。例如，对于 AXI，完成状态由 RRESP（读数据通道）上的 SLVERR 提供。例如，对于PCIe，完成状态字段可以被设置为“不支持的请求”(UR)或“完成中止”(CA)。</p>
<h2 id="7-4-可靠性、可用性和可维护性-RAS"><a href="#7-4-可靠性、可用性和可维护性-RAS" class="headerlink" title="7.4.可靠性、可用性和可维护性 (RAS)"></a>7.4.可靠性、可用性和可维护性 (RAS)</h2><p>IOMMU可以支持RAS架构，该架构指定用于启用错误检测、记录检测到的错误（包括其严重性、性质和位置）以及配置向错误处理程序报告错误的方法的方法。</p>
<p>某些错误（例如 IOATC 中的错误）可以通过在检测到错误时重新加载缓存的内存中数据结构来纠正。此类错误预计不会影响 IOMMU 的功能。</p>
<p>某些错误可能会破坏 IOMMU 的关键内部状态，并且此类错误可能会导致 IOMMU 进入故障状态。这种状态的示例可以包括诸如ddtp、cqb等的寄存器。在进入这种失败状态时，IOMMU可以请求IO桥中止所有传入事务。</p>
<p>某些错误（例如在 IOMMU 的内部数据路径内发生的损坏）可能无法纠正，但此类错误的影响可能包含在 IOMMU 正在处理的事务中。</p>
<p>作为处理事务的一部分，IOMMU 可能需要从内存数据结构（例如 DDT、PDT 或第一&#x2F;第二阶段页表）读取数据。数据的提供者（存储器控制器或高速缓存）可以检测到所请求的数据具有不可纠正的错误，并发出数据已损坏的信号并将错误推迟到IOMMU。这种将损坏数据的处理推迟给数据消费者的技术通常也称为数据中毒。此类错误的影响可能包含在导致访问损坏数据的事务中。</p>
<p>在错误影响正在处理的事务但允许 IOMMU 继续提供服务的情况下，IOMMU 可以中止（参见第 7.3 节）事务并通过在 FQ 中排队故障记录来报告故障。例如，对于 PCIe，“Completer Abort (CA)”响应适合中止事务。以下原因代码用于报告此类错误事务：</p>
<ul>
<li>DDT 数据损坏（原因&#x3D; 268） </li>
<li>PDT 数据损坏（原因&#x3D; 269） </li>
<li>MSI PT 数据损坏（原因&#x3D; 270） </li>
<li>MSI MRIF 数据损坏（原因&#x3D; 271） </li>
<li>内部数据路径错误（原因&#x3D; 272） </li>
<li>第一&#x2F;第二阶段 PT 数据损坏（原因 &#x3D; 274）</li>
</ul>
<p>如果IO桥不能与阻止IOMMU访问内存中数据结构的其他错误唯一地发信号通知此类延迟错误，则IOMMU可以将此类错误报告为访问错误，而不是使用有区别的数据损坏原因代码。</p>
<h1 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h1><p>[1] “PCI Express® Base Specification Revision 6.0.” [Online]. Available: pcisig.com&#x2F;pci-express-6.0specification.</p>
<p>[2] “RISC-V Advanced Interrupt Architecture.” [Online]. Available: github.com&#x2F;riscv&#x2F;riscv-aia.</p>
<p>[3] “RISC-V Instruction Set Manual, Volume II: Privileged Architecture.” [Online]. Available: github.com&#x2F;riscv&#x2F;riscv-isa-manual.</p>
<p>[4] “PCI Code and ID Assignment Specification Revision 1.1.” [Online]. Available: pcisig.com&#x2F;sites&#x2F; default&#x2F;files&#x2F;files&#x2F;PCI_Code-ID_r_1_11__v24_Jan_2019.pdf.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/RISC-V/" rel="tag"># RISC-V</a>
              <a href="/tags/IOMMU/" rel="tag"># IOMMU</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/11/06/RISC-V_aclint/" rel="prev" title="RISC-V aclint">
                  <i class="fa fa-angle-left"></i> RISC-V aclint
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/07/12/CentOS7-install-samba/" rel="next" title="CentOS7-install-samba">
                  CentOS7-install-samba <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Wu JInlin</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"http://example.com/2023/12/06/RISC-V_IOMMU_%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83/"}</script>
  <script src="/js/third-party/quicklink.js"></script>

</body>
</html>
