<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/312127.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/312127.svg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="RISC-V 特权架构 spec的翻译，基于20211203版本">
<meta property="og:type" content="article">
<meta property="og:title" content="RISC-V 特权架构">
<meta property="og:url" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/index.html">
<meta property="og:site_name" content="WJL">
<meta property="og:description" content="RISC-V 特权架构 spec的翻译，基于20211203版本">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724085739408-1730798006986-1.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724090901625-1730798006986-2.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724091442469-1730798006986-3.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724091545998-1730798006986-4.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724092947472-1730798006986-5.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724093027371-1730798006986-6.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724093049447-1730798006986-7.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724093108718-1730798006986-10.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724093212114-1730798006986-8.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724093306572-1730798006986-9.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724095308359-1730798006986-11.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724095400413-1730798006986-12.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724095635409-1730798006986-13.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724100248717-1730798006986-15.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724101023176-1730798006986-14.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724101123366-1730798006986-16.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724101211800-1730798006986-17.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724101231546-1730798006986-18.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724104043893-1730798006986-19.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724104307345-1730798006986-20.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724104704315-1730798006986-21.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724104727948-1730798006986-22.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230606151855672-1730798006986-23.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230606152947876-1730798006986-24.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230607104406917-1730798006986-25.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724105913319-1730798006986-26.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724110030556-1730798006986-28.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724110058282-1730798006986-27.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724110205914-1730798006986-29.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230607150308306-1730798006986-30.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230607144159954-1730798006986-32.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230607102401144-1730798006986-31.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230607102449479-1730798006986-34.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230607144256709-1730798006986-33.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20240827100909450-1730798006986-36.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230607135602251-1730798006986-35.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724110523238-1730798006986-37.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724111119669-1730798006986-38.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724111155038-1730798006986-39.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724111239448-1730798006987-41.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724112537554-1730798006986-40.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724112643225-1730798006987-42.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724114215950-1730798006987-43.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724114320849-1730798006987-44.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724114425454-1730798006987-45.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724134008936-1730798006987-46.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724140045917-1730798006987-47.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724141910461-1730798006987-48.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724141918708-1730798006987-49.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724141945653-1730798006987-50.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724141953635-1730798006987-51.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724142012022-1730798006987-52.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724142103189-1730798006987-53.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724142124344-1730798006987-54.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724143935161-1730798006987-55.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724145322312-1730798006987-56.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724145344664-1730798006987-57.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724145729075-1730798006987-58.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724145759373-1730798006987-59.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724145934050-1730798006987-60.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724160610101-1730798006987-61.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724161315934-1730798006987-62.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724161406984-1730798006987-63.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724161617963-1730798006987-64.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724161653067-1730798006987-65.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724162139046-1730798006987-66.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724162609386-1730798006987-68.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724164250374-1730798006987-67.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724164311147-1730798006987-69.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724164338249-1730798006987-70.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724171650493-1730798006987-71.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724172731223-1730798006987-72.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724183615160-1730798006987-73.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230725085323917-1730798006987-74.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230725085727616-1730798006987-75.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230725090209390-1730798006987-76.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230725091626425-1730798006987-77.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230725091639381-1730798006987-78.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230725091909928-1730798006987-79.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619102536443-1730798006987-80.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619104021864-1730798006987-81.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619111427150-1730798006987-82.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619111621452-1730798006988-83.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619112857447-1730798006988-84.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619112917408-1730798006988-85.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619112933217-1730798006988-86.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619133330589-1730798006988-87.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619133352813-1730798006988-88.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619133843695-1730798006988-89.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619134725508-1730798006988-90.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619135337569-1730798006988-91.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619135943653-1730798006988-92.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619140918185-1730798006988-93.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619140944661-1730798006988-94.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619141019050-1730798006988-95.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619141250391-1730798006988-96.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619141328875-1730798006988-97.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230719160026932-1730798006988-99.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619155804871-1730798006988-98.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619160157312-1730798006988-100.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619160224321-1730798006988-101.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619160338892-1730798006988-102.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619160640694-1730798006988-103.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619161552863-1730798006988-104.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619161636601-1730798006988-105.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619161708479-1730798006988-107.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619161742529-1730798006988-106.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619161821642-1730798006988-108.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619162256524-1730798006988-109.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619162926132-1730798006988-110.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619164229777-1730798006988-111.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619164410329-1730798006988-112.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619165141590-1730798006988-113.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619171652730-1730798006988-114.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619171747318-1730798006988-115.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619171852916-1730798006988-116.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619172226512-1730798006988-117.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619172242100-1730798006988-118.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619172306796-1730798006988-119.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619172325999-1730798006988-120.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620093251053-1730798006988-121.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620095034291-1730798006988-122.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620095148326-1730798006988-123.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620095233766-1730798006988-124.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620095311698-1730798006988-125.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620100733821-1730798006988-127.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620100753539-1730798006988-126.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620100839882-1730798007010-130.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620101004942-1730798006988-129.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620101027513-1730798006988-128.png">
<meta property="og:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230725092356016-1730798007010-131.png">
<meta property="article:published_time" content="2023-11-06T05:52:39.000Z">
<meta property="article:modified_time" content="2024-11-15T03:24:28.126Z">
<meta property="article:author" content="Wu JInlin">
<meta property="article:tag" content="RISC-V">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724085739408-1730798006986-1.png">


<link rel="canonical" href="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/","path":"2023/11/06/RISC-V特权架构/","title":"RISC-V 特权架构"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>RISC-V 特权架构 | WJL</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">WJL</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Fighting forgetfulness</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RISC-V-%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84"><span class="nav-text">RISC-V 特权架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Preface"><span class="nav-text">Preface</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="nav-text">1. 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-RISC-V-%E7%89%B9%E6%9D%83%E8%BD%AF%E4%BB%B6%E5%A0%86%E6%A0%88%E6%9C%AF%E8%AF%AD"><span class="nav-text">1.1 RISC-V 特权软件堆栈术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E6%9D%83%E9%99%90%E7%BA%A7%E5%88%AB"><span class="nav-text">1.2 权限级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.3 调试模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E6%8E%A7%E5%88%B6%E5%92%8C%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8-CSR"><span class="nav-text">2. 控制和状态寄存器 (CSR)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-CSR-%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E7%BA%A6%E5%AE%9A"><span class="nav-text">2.1 CSR 地址映射约定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-CSR%E5%88%97%E8%A1%A8"><span class="nav-text">2.2  CSR列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-CSR%E5%AD%97%E6%AE%B5%E8%A7%84%E6%A0%BC"><span class="nav-text">2.3 CSR字段规格</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E7%95%99%E5%86%99%E4%BF%9D%E7%95%99%E5%80%BC%EF%BC%8C%E8%AF%BB%E5%BF%BD%E7%95%A5%E5%80%BC-WPRI"><span class="nav-text">保留写保留值，读忽略值(WPRI)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E5%86%99-%E5%8F%AA%E8%AF%BB%E5%90%88%E6%B3%95%E5%80%BC-WLRL"><span class="nav-text">只写&#x2F;只读合法值(WLRL)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E4%BB%BB%E6%84%8F%E5%80%BC%EF%BC%8C%E8%AF%BB%E5%8F%96%E5%90%88%E6%B3%95%E5%80%BC-WARL"><span class="nav-text">写入任意值，读取合法值(WARL)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-CSR%E5%AD%97%E6%AE%B5%E8%B0%83%E6%95%B4"><span class="nav-text">2.4 CSR字段调整</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-CSR%E9%9A%90%E5%BC%8F%E8%AF%BB%E5%8F%96"><span class="nav-text">2.5 CSR隐式读取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-CSR%E4%BD%8D%E5%AE%BD%E8%B0%83%E6%95%B4"><span class="nav-text">2.6 CSR位宽调整</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E6%9C%BA%E5%99%A8%E7%BA%A7ISA%EF%BC%8C%E7%89%88%E6%9C%AC1-12"><span class="nav-text">3. 机器级ISA，版本1.12</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1%E6%9C%BA%E5%99%A8%E7%BA%A7CSR"><span class="nav-text">3.1机器级CSR</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E6%9C%BA%E5%99%A8ISA%E5%AF%84%E5%AD%98%E5%99%A8-misa"><span class="nav-text">3.1.1 机器ISA寄存器 (misa)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E6%9C%BA%E5%99%A8Vendor-ID-%E5%AF%84%E5%AD%98%E5%99%A8-mvendorid"><span class="nav-text">3.1.2 机器Vendor ID 寄存器 (mvendorid)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-%E6%9C%BA%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84ID%E5%AF%84%E5%AD%98%E5%99%A8-marchid"><span class="nav-text">3.1.3 机器体系结构ID寄存器 (marchid )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-%E6%9C%BA%E5%99%A8%E5%AE%9E%E7%8E%B0ID%E5%AF%84%E5%AD%98%E5%99%A8-mimpid"><span class="nav-text">3.1.4 机器实现ID寄存器 (mimpid)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-5-Hart-ID-%E5%AF%84%E5%AD%98%E5%99%A8-mhartid"><span class="nav-text">3.1.5 Hart ID 寄存器(mhartid)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-6-%E6%9C%BA%E5%99%A8%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8-mstatus%E5%92%8Cmstatush"><span class="nav-text">3.1.6 机器状态寄存器(mstatus和mstatush)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-6-1-mstatus%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E7%89%B9%E6%9D%83%E5%92%8C%E5%85%A8%E5%B1%80%E4%B8%AD%E6%96%AD%E4%BD%BF%E8%83%BD%E5%A0%86%E6%A0%88"><span class="nav-text">3.1.6.1 mstatus寄存器中的特权和全局中断使能堆栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-6-2-mstatus%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84Base-ISA%E6%8E%A7%E5%88%B6"><span class="nav-text">3.1.6.2 mstatus寄存器中的Base ISA控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-6-3-mstatus%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%89%B9%E6%9D%83"><span class="nav-text">3.1.6.3 mstatus寄存器中的内存特权</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-6-4-mstatus%E5%92%8Cmstatush%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E7%AB%AF%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">3.1.6.4 mstatus和mstatush寄存器的端序控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-6-5-mstatus-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9F%E5%8C%96%E6%94%AF%E6%8C%81"><span class="nav-text">3.1.6.5 mstatus 寄存器中的虚拟化支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-6-6-mstatus-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8A%B6%E6%80%81"><span class="nav-text">3.1.6.6 mstatus 寄存器中的扩展上下文状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-7-%E6%9C%BA%E5%99%A8%E9%99%B7%E9%98%B1%E5%90%91%E9%87%8F%E5%9F%BA%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88mtvec%EF%BC%89"><span class="nav-text">3.1.7 机器陷阱向量基地址寄存器（mtvec）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-8-%E6%9C%BA%E5%99%A8%E9%99%B7%E9%98%B1%E5%A7%94%E6%89%98%E5%AF%84%E5%AD%98%E5%99%A8-medeleg-and-mideleg"><span class="nav-text">3.1.8  机器陷阱委托寄存器  (medeleg and mideleg)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-9-%E6%9C%BA%E5%99%A8%E4%B8%AD%E6%96%AD%E4%BD%BF%E8%83%BD%E6%8C%82%E8%B5%B7%E5%AF%84%E5%AD%98%E5%99%A8-mip-and-mie"><span class="nav-text">3.1.9 机器中断使能挂起寄存器  (mip and mie)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-10-%E7%A1%AC%E4%BB%B6%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7-mcycle-and-minstret"><span class="nav-text">3.1.10 硬件性能监控 (mcycle and minstret )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-11-%E6%9C%BA%E5%99%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E4%BD%BF%E8%83%BD%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88mcounteren%EF%BC%89"><span class="nav-text">3.1.11 机器计数器使能寄存器（mcounteren）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-12-%E6%9C%BA%E5%99%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E7%A6%81%E6%AD%A2-CSR-mcountinhibit"><span class="nav-text">3.1.12 机器计数器禁止 CSR (mcountinhibit)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-13-%E6%9C%BA%E5%99%A8%E6%9A%82%E7%94%A8%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8-mscratch"><span class="nav-text">3.1.13  机器暂用控制寄存器  (mscratch)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-14-%E6%9C%BA%E5%99%A8%E5%BC%82%E5%B8%B8%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-mepc"><span class="nav-text">3.1.14 机器异常程序计数器  (mepc)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-15-%E6%9C%BA%E5%99%A8%E5%8E%9F%E5%9B%A0%E5%AF%84%E5%AD%98%E5%99%A8-mcause"><span class="nav-text">3.1.15  机器原因寄存器 (mcause)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-16-%E6%9C%BA%E5%99%A8%E9%99%B7%E9%98%B1%E5%80%BC%E5%AF%84%E5%AD%98%E5%99%A8-mtval"><span class="nav-text">3.1.16 机器陷阱值寄存器  (mtval)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-17-%E6%9C%BA%E5%99%A8%E9%85%8D%E7%BD%AE%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88mconfigptr%EF%BC%89"><span class="nav-text">3.1.17 机器配置指针寄存器（mconfigptr）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-18-%E6%9C%BA%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88menvcfg-%E5%92%8C-menvcfgh%EF%BC%89"><span class="nav-text">3.1.18 机器环境配置寄存器（menvcfg 和 menvcfgh）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-19-%E6%9C%BA%E5%99%A8%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88mseccfg%EF%BC%89"><span class="nav-text">3.1.19 机器安全配置寄存器（mseccfg）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%9C%BA%E5%99%A8%E7%BA%A7%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">3.2 机器级内存映射寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E6%9C%BA%E5%99%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88mtime-%E5%92%8C-mtimecmp%EF%BC%89"><span class="nav-text">3.2.1 机器定时器寄存器（mtime 和 mtimecmp）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%9C%BA%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4"><span class="nav-text">3.3 机器模式特权指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E7%8E%AF%E5%A2%83%E8%B0%83%E7%94%A8%E5%92%8C%E6%96%AD%E7%82%B9"><span class="nav-text">3.3.1 环境调用和断点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E9%99%B7%E9%98%B1%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="nav-text">3.3.2 陷阱返回指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-%E7%AD%89%E5%BE%85%E4%B8%AD%E6%96%AD"><span class="nav-text">3.3.3 等待中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4"><span class="nav-text">3.3.4 自定义系统指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E5%A4%8D%E4%BD%8D"><span class="nav-text">3.4 复位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E4%B8%8D%E5%8F%AF%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD"><span class="nav-text">3.5 不可屏蔽中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%B1%9E%E6%80%A7"><span class="nav-text">3.6 物理内存属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1-%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E-I-O-%E4%B8%8E%E7%A9%BA%E9%97%B2%E5%8C%BA%E5%9F%9F"><span class="nav-text">3.6.1 主内存与 I&#x2F;O 与空闲区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-%E6%94%AF%E6%8C%81%E7%9A%84%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B-PMA"><span class="nav-text">3.6.2 支持的访问类型 PMA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-3-%E5%8E%9F%E5%AD%90%E6%80%A7PMA"><span class="nav-text">3.6.3 原子性PMA</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3-1-AMO-PMA"><span class="nav-text">3.6.3.1 AMO PMA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3-2-%E5%8F%AF%E9%A2%84%E8%AE%A2%E6%80%A7-PMA"><span class="nav-text">3.6.3.2 可预订性 PMA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3-3-%E5%AF%B9%E9%BD%90"><span class="nav-text">3.6.3.3 对齐</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-4-%E5%86%85%E5%AD%98%E6%8E%92%E5%BA%8F-PMA"><span class="nav-text">3.6.4 内存排序 PMA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-5-PMA-%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%8F%AF%E7%BC%93%E5%AD%98%E6%80%A7"><span class="nav-text">3.6.5 PMA 的一致性和可缓存性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-6-%E5%B9%82%E7%AD%89%E6%80%A7PMA"><span class="nav-text">3.6.6 幂等性PMA</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="nav-text">3.7 物理内存保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-1-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4-CSR"><span class="nav-text">3.7.1 物理内存保护 CSR</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%8C%B9%E9%85%8D-Address-Matching"><span class="nav-text">地址匹配  Address Matching</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E5%AE%9A%E5%92%8C%E7%89%B9%E6%9D%83%E6%A8%A1%E5%BC%8F-Locking-and-Privilege-Mode"><span class="nav-text">锁定和特权模式 Locking and Privilege Mode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E5%8C%B9%E9%85%8D%E9%80%BB%E8%BE%91-Priority-and-Matching-Logic"><span class="nav-text">优先级和匹配逻辑 Priority and Matching Logic</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-2-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%88%86%E9%A1%B5"><span class="nav-text">3.7.2 物理内存保护和分页</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Supervisor-ISA%EF%BC%8C%E7%89%88%E6%9C%AC-1-12"><span class="nav-text">4. Supervisor ISA，版本 1.12</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Supervisor-CSR"><span class="nav-text">4.1 Supervisor CSR</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-Supervisor%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88sstatus%EF%BC%89"><span class="nav-text">4.1.1 Supervisor状态寄存器（sstatus）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-1-sstatus-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC-ISA-%E6%8E%A7%E5%88%B6"><span class="nav-text">4.1.1.1 sstatus 寄存器中的基本 ISA 控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-2-sstatus-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%9D%83%E9%99%90"><span class="nav-text">4.1.1.2 sstatus 寄存器中的内存权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-3-sstatus-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">4.1.1.3 sstatus 寄存器中的字节顺序控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-Supervisor%E9%99%B7%E9%98%B1%E5%90%91%E9%87%8F%E5%9F%BA%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88stvec%EF%BC%89"><span class="nav-text">4.1.2 Supervisor陷阱向量基地址寄存器（stvec）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-3-Supervisor%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88sip-%E5%92%8C-sie%EF%BC%89"><span class="nav-text">4.1.3 Supervisor中断寄存器（sip 和 sie）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-4-Supervisor%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E6%80%A7%E8%83%BD%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-text">4.1.4 Supervisor定时器和性能计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-5-%E8%AE%A1%E6%95%B0%E5%99%A8%E4%BD%BF%E8%83%BD%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88scounteren%EF%BC%89"><span class="nav-text">4.1.5 计数器使能寄存器（scounteren）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-6-Supervisor%E6%9A%82%E5%AD%98%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88sscratch%EF%BC%89"><span class="nav-text">4.1.6 Supervisor暂存寄存器（sscratch）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-7-Supervisor%E5%BC%82%E5%B8%B8%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88sepc%EF%BC%89"><span class="nav-text">4.1.7 Supervisor异常程序计数器（sepc）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-8-Supervisor%E5%8E%9F%E5%9B%A0%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88scause%EF%BC%89"><span class="nav-text">4.1.8 Supervisor原因寄存器（scause）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-9-Supervisor%E9%99%B7%E9%98%B1%E5%80%BC%E5%AF%84%E5%AD%98%E5%99%A8-stval"><span class="nav-text">4.1.9 Supervisor陷阱值寄存器 (stval)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-10-Supervisor%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88senvcfg%EF%BC%89"><span class="nav-text">4.1.10 Supervisor环境配置寄存器（senvcfg）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-11-Supervisor%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BF%9D%E6%8A%A4%E5%AF%84%E5%AD%98%E5%99%A8-satp"><span class="nav-text">4.1.11 Supervisor地址转换和保护寄存器 (satp)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-Supervisor-%E6%8C%87%E4%BB%A4"><span class="nav-text">4.2 Supervisor 指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-Supervisor%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86Fence%E6%8C%87%E4%BB%A4"><span class="nav-text">4.2.1 Supervisor内存管理Fence指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-Sv32%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%A1%B5%E9%9D%A2%E7%9A%8432%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="nav-text">4.3 Sv32：基于页面的32位虚拟内存系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-%E5%AF%BB%E5%9D%80%E5%92%8C%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="nav-text">4.3.1 寻址和内存保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="nav-text">4.3.2 虚拟地址转换过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-Sv39%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%A1%B5%E9%9D%A2%E7%9A%8439%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="nav-text">4.4 Sv39：基于页面的39位虚拟内存系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-%E5%AF%BB%E5%9D%80%E5%92%8C%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="nav-text">4.4.1 寻址和内存保护</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-Sv48%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%A1%B5%E9%9D%A2%E7%9A%8448%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="nav-text">4.5 Sv48：基于页面的48位虚拟内存系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-%E5%AF%BB%E5%9D%80%E5%92%8C%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="nav-text">4.5.1 寻址和内存保护</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-Sv57%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%A1%B5%E9%9D%A2%E7%9A%8457%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="nav-text">4.6 Sv57：基于页面的57位虚拟内存系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-1-%E5%AF%BB%E5%9D%80%E5%92%8C%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="nav-text">4.6.1 寻址和内存保护</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-NAPOT-%E7%BF%BB%E8%AF%91%E8%BF%9E%E7%BB%AD%E6%80%A7%E7%9A%84%E2%80%9CSvnapot%E2%80%9D%E6%A0%87%E5%87%86%E6%89%A9%E5%B1%95%EF%BC%8C%E7%89%88%E6%9C%AC-1-0"><span class="nav-text">5. NAPOT 翻译连续性的“Svnapot”标准扩展，版本 1.0</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E2%80%9CSvpbmt%E2%80%9D%E5%9F%BA%E4%BA%8E%E9%A1%B5%E7%9A%84%E5%86%85%E5%AD%98%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A0%87%E5%87%86%E6%89%A9%E5%B1%95%EF%BC%8C%E7%89%88%E6%9C%AC-1-0"><span class="nav-text">6. “Svpbmt”基于页的内存类型的标准扩展，版本 1.0</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E7%BB%86%E7%B2%92%E5%BA%A6%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E7%9A%84%E2%80%9CSvinval%E2%80%9D%E6%A0%87%E5%87%86%E6%89%A9%E5%B1%95%EF%BC%8C%E7%89%88%E6%9C%AC-1-0"><span class="nav-text">7. 细粒度地址转换缓存失效的“Svinval”标准扩展，版本 1.0</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-Hypervisor%E6%89%A9%E5%B1%95%EF%BC%8C%E7%89%88%E6%9C%AC-1-0"><span class="nav-text">8.  Hypervisor扩展，版本 1.0</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E7%89%B9%E6%9D%83%E6%A8%A1%E5%BC%8F"><span class="nav-text">8.1 特权模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-Hypervisor-and-Virtual-Supervisor-CSRs"><span class="nav-text">8.2 Hypervisor and Virtual Supervisor CSRs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-Hypervisor-%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8-hstatus"><span class="nav-text">8.2.1 Hypervisor 状态寄存器(hstatus)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-2-Hypervisor-Trap-%E5%A7%94%E6%89%98%E5%AF%84%E5%AD%98%E5%99%A8-hedeleg%E5%92%8Chideleg"><span class="nav-text">8.2.2 Hypervisor Trap 委托寄存器(hedeleg和hideleg)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-3-Hypervisor-%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8-hvip%E3%80%81hip%E3%80%81hie"><span class="nav-text">8.2.3 Hypervisor 中断寄存器(hvip、hip、hie)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-4-Hypervisor-Guest-%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8-hgeip-and-hgeie"><span class="nav-text">8.2.4 Hypervisor Guest 外部中断寄存器 (hgeip and hgeie)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-5-Hypervisor-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AF%84%E5%AD%98%E5%99%A8-henvcfg-and-henvcfgh"><span class="nav-text">8.2.5 Hypervisor 环境配置寄存器(henvcfg and henvcfgh)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-6-Hypervisor-%E8%AE%A1%E6%95%B0%E5%99%A8%E5%90%AF%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8-hcounteren"><span class="nav-text">8.2.6 Hypervisor 计数器启用寄存器 (hcounteren)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-7-Hypervisor-%E6%97%B6%E9%97%B4%E5%A2%9E%E9%87%8F%E5%AF%84%E5%AD%98%E5%99%A8-htimedelta-htimedeltah"><span class="nav-text">8.2.7 Hypervisor 时间增量寄存器 (htimedelta, htimedeltah)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-8-Hypervisor-%E9%99%B7%E9%98%B1%E5%80%BC%E5%AF%84%E5%AD%98%E5%99%A8-htval"><span class="nav-text">8.2.8 Hypervisor 陷阱值寄存器 (htval)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-9-Hypervisor-%E9%99%B7%E9%98%B1%E6%8C%87%E4%BB%A4%E5%AF%84%E5%AD%98%E5%99%A8-htinst"><span class="nav-text">8.2.9 Hypervisor 陷阱指令寄存器 (htinst)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-10-Hypervisor-Guest-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BF%9D%E6%8A%A4%E5%AF%84%E5%AD%98%E5%99%A8-hgatp"><span class="nav-text">8.2.10 Hypervisor Guest 地址转换和保护寄存器 (hgatp)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-11-Virtual-Supervisor-%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8-vsstatus"><span class="nav-text">8.2.11 Virtual Supervisor 状态寄存器 (vsstatus)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-12-Virtual-Supervisor-%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8-vsip-and-vsie"><span class="nav-text">8.2.12 Virtual Supervisor 中断寄存器 (vsip and vsie)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-13-Virtual-Supervisor-%E9%99%B7%E9%98%B1%E5%90%91%E9%87%8F%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8-vstvec"><span class="nav-text">8.2.13 Virtual Supervisor 陷阱向量基址寄存器 (vstvec)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-14-Virtual-Supervisor-%E6%9A%82%E5%AD%98%E5%AF%84%E5%AD%98%E5%99%A8-vsscratch"><span class="nav-text">8.2.14 Virtual Supervisor 暂存寄存器 (vsscratch)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-15-Virtual-Supervisor-%E5%BC%82%E5%B8%B8%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-vsepc"><span class="nav-text">8.2.15 Virtual Supervisor 异常程序计数器 (vsepc)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-16-Virtual-Supervisor-%E5%8E%9F%E5%9B%A0%E5%AF%84%E5%AD%98%E5%99%A8-vscause"><span class="nav-text">8.2.16 Virtual Supervisor 原因寄存器 (vscause)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-17-Virtual-Supervisor-%E9%99%B7%E9%98%B1%E5%80%BC%E5%AF%84%E5%AD%98%E5%99%A8-vstval"><span class="nav-text">8.2.17 Virtual Supervisor 陷阱值寄存器 (vstval)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-18-Virtual-Supervisor-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BF%9D%E6%8A%A4%E5%AF%84%E5%AD%98%E5%99%A8-vsatp"><span class="nav-text">8.2.18 Virtual Supervisor 地址转换和保护寄存器  (vsatp)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-Hypervisor-Instructions"><span class="nav-text">8.3 Hypervisor Instructions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-1-Hypervisor-Virtual-Machine-Load-and-Store-Instructions"><span class="nav-text">8.3.1 Hypervisor Virtual-Machine Load and Store Instructions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-2-Hypervisor-Memory-Management-Fence-Instructions"><span class="nav-text">8.3.2 Hypervisor Memory-Management Fence Instructions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-Machine-Level-CSR"><span class="nav-text">8.4  Machine-Level CSR</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-1-%E6%9C%BA%E5%99%A8%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88mstatus%E5%92%8Cmstatush%EF%BC%89"><span class="nav-text">8.4.1 机器状态寄存器（mstatus和mstatush）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-2-%E6%9C%BA%E5%99%A8%E4%B8%AD%E6%96%AD%E5%A7%94%E6%89%98%E5%AF%84%E5%AD%98%E5%99%A8-mideleg"><span class="nav-text">8.4.2 机器中断委托寄存器(mideleg)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-3-%E6%9C%BA%E5%99%A8%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8-mip%E5%92%8Cmie"><span class="nav-text">8.4.3 机器中断寄存器(mip和mie)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-4-%E6%9C%BA%E5%99%A8%E7%AC%AC%E4%BA%8C%E9%99%B7%E9%98%B1%E5%80%BC%E5%AF%84%E5%AD%98%E5%99%A8-mtval2"><span class="nav-text">8.4.4 机器第二陷阱值寄存器(mtval2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-5-%E6%9C%BA%E5%99%A8%E9%99%B7%E9%98%B1%E6%8C%87%E4%BB%A4%E5%AF%84%E5%AD%98%E5%99%A8-mtinst"><span class="nav-text">8.4.5 机器陷阱指令寄存器(mtinst)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-text">8.5 两阶段地址转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-1-Guest-Physical-Address%E8%BD%AC%E6%8D%A2"><span class="nav-text">8.5.1 Guest Physical Address转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-2-Guest%E9%A1%B5%E9%94%99%E8%AF%AF"><span class="nav-text">8.5.2 Guest页错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9B%B4%E6%A0%8F"><span class="nav-text">8.5.3 内存管理围栏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-Traps"><span class="nav-text">8.6 Traps</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-1-Trap%E5%8E%9F%E5%9B%A0%E7%A0%81"><span class="nav-text">8.6.1 Trap原因码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-2-Trap%E8%A1%A8%E9%A1%B9"><span class="nav-text">8.6.2 Trap表项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-3-mtinst%E6%88%96htinst%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4%E6%88%96%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="nav-text">8.6.3 mtinst或htinst的转换指令或伪指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-4-Trap%E8%BF%94%E5%9B%9E"><span class="nav-text">8.6.4 Trap返回</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-RISC-V-%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%E9%9B%86%E5%88%97%E8%A1%A8"><span class="nav-text">9.  RISC-V 特权指令集列表</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wu JInlin"
      src="/images/20241114140630.jpg">
  <p class="site-author-name" itemprop="name">Wu JInlin</p>
  <div class="site-description" itemprop="description">个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/20241114140630.jpg">
      <meta itemprop="name" content="Wu JInlin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WJL">
      <meta itemprop="description" content="个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="RISC-V 特权架构 | WJL">
      <meta itemprop="description" content="RISC-V 特权架构 spec的翻译，基于20211203版本">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RISC-V 特权架构
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-06 13:52:39" itemprop="dateCreated datePublished" datetime="2023-11-06T13:52:39+08:00">2023-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-15 11:24:28" itemprop="dateModified" datetime="2024-11-15T11:24:28+08:00">2024-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/RISC-V/" itemprop="url" rel="index"><span itemprop="name">RISC-V</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">RISC-V 特权架构 spec的翻译，基于20211203版本</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="RISC-V-特权架构"><a href="#RISC-V-特权架构" class="headerlink" title="RISC-V 特权架构"></a>RISC-V 特权架构</h1><h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>本文档描述了 RISC-V特权架构。此版本（版本 20211203）包含以下版本的 RISC-V ISA 模块：</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724085739408-1730798006986-1.png" alt="image-20230724085739408"></p>
<p>自 1.11 版以来进行了以下更改，虽然不严格向后兼容，但预计在实践中不会导致软件可移植性问题：</p>
<ul>
<li><p>更改了 MRET 和 SRET，以在离开 M 模式时清除 mstatus.MPRV。</p>
</li>
<li><p>保留额外的 satp 模式以供将来使用。</p>
</li>
<li><p>规定scause异常代码字段必须至少实现位 4-0。</p>
</li>
<li><p>已指定宽松 I&#x2F;O 区域以遵循 RVWMO。之前的规范暗示除栅栏和获取&#x2F;释放注释之外的 PPO 规则不适用。</p>
</li>
<li><p>使用基于页面的虚拟内存时，限制了 LR&#x2F;SC 保留集的大小和形状。</p>
</li>
<li><p>PMP 更改需要在任何实现基于页面的虚拟内存的硬件上使用 SFENCE.VMA，即使当前未启用 VM。</p>
</li>
<li><p>允许页表项 A 位的推测性更新。</p>
</li>
<li><p>澄清，如果地址转换算法非推测性地到达一个 PTE，其中设置了为未来标准使用保留的位，则必须引发页错误异常。</p>
</li>
</ul>
<p>此外，自 1.11 版本以来还进行了以下兼容更改：</p>
<ul>
<li><p>删除了 N 扩展。</p>
</li>
<li><p>定义了强制 RV32-only CSR mstatush，其中包含大部分与 RV64 mstatus 的高 32 位相同的字段。</p>
</li>
<li><p>定义强制 CSR mconfigptr，如果非零，则包含配置数据结构的地址。</p>
</li>
<li><p>定义了可选的 mseccfg 和 mseccfgh CSR，用于控制计算机的安全配置。</p>
</li>
<li><p>定义了 menvcfg、henvcfg 和 senvcfg CSR（以及仅限 RV32 的 menvcfgh 和 heenvcfgh CSR），它们控制执行环境的各种特征。</p>
</li>
<li><p>SYSTEM 主操作码的指定部分供自定义使用。</p>
</li>
<li><p>允许无条件委托较低权限的中断。</p>
</li>
<li><p>添加了可选的大端和双端支持。</p>
</li>
<li><p>相对于加载&#x2F;存储&#x2F;AMO 页面错误和访问错误异常，实现定义了加载&#x2F;存储&#x2F;AMO 地址未对齐异常的优先级。</p>
</li>
<li><p>PMP 重置值现在由平台定义。</p>
</li>
<li><p>还定义了另外 48 个可选 PMP 寄存器。</p>
</li>
<li><p>稍微放宽了实现所执行的 A 和 D 位更新的原子性要求。</p>
</li>
<li><p>阐明地址转换缓存的架构行为 添加了 Sv57 和 Sv57x4 地址转换模式。</p>
</li>
<li><p>软件断点异常允许将 0 或 PC 写入 xtval。</p>
</li>
<li><p>阐明裸 S 模式不需要支持 SFENCE.VMA 指令。</p>
</li>
<li><p>为非幂等区域的隐式读取指定宽松约束。</p>
</li>
<li><p>添加了 Svnapot 标准扩展以及 Sv39、Sv48 和 Sv57 PTE 中的 N 位。</p>
</li>
<li><p>添加了 Svpbmt 标准扩展以及 Sv39、Sv48 和 Sv57 PTE 中的 PBMT 位。</p>
</li>
<li><p>添加了 Svinval 标准扩展和相关说明。</p>
</li>
</ul>
<p>最后，Hypervisor架构提案进行了广泛修改。</p>
<p>。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。</p>
<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>本文档描述了 RISC-V特权架构，涵盖非特权 ISA 之外的 RISCV 系统的所有方面，包括特权指令以及运行操作系统和连接外部设备所需的附加功能。</p>
<blockquote>
<p>对我们设计决策的评论的格式如本段所示，如果读者只对规范本身感兴趣，可以跳过。</p>
</blockquote>
<blockquote>
<p>我们简要地指出，本文档中描述的整个特权级设计可以替换为完全不同的特权级设计，而无需更改非特权 ISA，甚至可能无需更改 ABI。特别是，该特权规范旨在运行现有的流行操作系统，因此体现了传统的基于级别的保护模型。替代的特权规范可以体现其他更灵活的保护域模型。为了表达的简单性，文本被写成好像这是唯一可能的特权架构。</p>
</blockquote>
<h2 id="1-1-RISC-V-特权软件堆栈术语"><a href="#1-1-RISC-V-特权软件堆栈术语" class="headerlink" title="1.1 RISC-V 特权软件堆栈术语"></a>1.1 RISC-V 特权软件堆栈术语</h2><p>1.1 RISC-V Privileged Software Stack Terminology</p>
<p>本节介绍我们用来描述 RISC-V 各种可能的特权软件堆栈组件的术语。</p>
<p>图 1.1 显示了 RISC-V 架构可以支持的一些可能的软件堆栈。左侧显示了一个简单的系统，仅支持在应用程序执行环境 (AEE) 上运行的单个应用程序。该应用程序经过编码，可以使用特定的应用程序二进制接口 (ABI) 运行。 ABI 包括受支持的用户级 ISA 以及一组与 AEE 交互的 ABI 调用。 ABI 对应用程序隐藏了 AEE 的详细信息，以便在实现 AEE 时提供更大的灵活性。相同的 ABI 可以在多个不同的主机操作系统上本机实现，或者可以由在具有不同本机 ISA 的计算机上运行的User mode模拟环境支持。</p>
<blockquote>
<p>我们的图形约定使用<strong>黑框和白色文本来表示抽象接口</strong>，以将它们与实现接口的组件的具体实例分开。</p>
</blockquote>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724090901625-1730798006986-2.png" alt="image-20230724090901625"></p>
<p>中间配置显示了可以支持多个应用程序的多道程序执行的传统操作系统（OS）。每个应用程序都通过 ABI 与提供 AEE 的操作系统进行通信。正如应用程序通过 ABI 与 AEE 接口一样，RISC-V 操作系统也通过Supervisor二进制接口 (SBI) 与Supervisor执行环境 (SEE) 接口。 SBI 由用户级和Supervisor级 ISA 以及一组 SBI 函数调用组成。在所有 SEE 实现中使用单个 SBI 允许单个操作系统二进制映像在任何 SEE 上运行。 SEE 可以是低端硬件平台中的简单引导加载程序和 BIOS 式 IO 系统，也可以是高端服务器中Hypervisor提供的虚拟机，也可以是架构模拟环境中主机操作系统上的精简转换层。</p>
<blockquote>
<p>大多数Supervisor级 ISA 定义并未将 SBI 与执行环境和&#x2F;或硬件平台分开，从而使虚拟化和新硬件平台的启动变得复杂。</p>
</blockquote>
<p>最右边的配置显示了virtual machine monitor配置，其中单个Hypervisor支持多个多道程序操作系统。每个操作系统都通过 SBI 与提供 SEE 的Hypervisor进行通信。Hypervisor使用Hypervisor二进制接口 (HBI) 与Hypervisor执行环境 (HEE) 进行通信，以将Hypervisor与硬件平台的细节隔离。</p>
<blockquote>
<p>ABI、SBI 和 HBI 仍在开发中，但我们现在优先支持 Type-2 Hypervisor，其中 SBI 由 S 模式操作系统递归提供。</p>
</blockquote>
<p>RISC-V ISA 的硬件实现通常需要特权 ISA 之外的附加功能，以支持各种执行环境（AEE、SEE 或 HEE）。</p>
<h2 id="1-2-权限级别"><a href="#1-2-权限级别" class="headerlink" title="1.2 权限级别"></a>1.2 权限级别</h2><p>在任何时候，RISC-V 硬件线程 (hart) 都在某个特权级别上运行，这些特权级别被编码为一个或多个 CSR（控制和状态寄存器）中的一种模式。目前定义了三个 RISC-V 特权级别，如表 1.1 所示。</p>
<p>权限级别用于在软件堆栈的不同组件之间提供保护，尝试执行当前权限模式不允许的操作将导致引发异常。这些异常通常会导致底层执行环境陷入陷阱。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724091442469-1730798006986-3.png" alt="image-20230724091442469"></p>
<blockquote>
<p>在描述中，我们尝试将编写代码的权限级别与其运行的权限模式分开，尽管两者通常是紧密相连的。例如，Supervisor级操作系统可以在具有三种特权模式的系统上以Supervisor模式运行，但也可以在具有两种或多种特权模式的系统上在经典virtual machine monitor下以User mode运行。在这两种情况下，可以使用相同的Supervisor级操作系统二进制代码，编码为Supervisor级 SBI，因此期望能够使用Supervisor级特权指令和 CSR。当在User mode下运行guest OS时，所有超级用户级别的操作都将被运行在较高权限级别的 SEE 捕获和模拟。</p>
</blockquote>
<p>机器级别拥有最高的权限，是RISC-V硬件平台唯一强制的权限级别。在机器模式（M 模式）下运行的代码通常本质上是可信的，因为它对机器实现具有低级访问权限。 M-模式可用于管理 RISC-V 上的安全执行环境。User mode（U 模式）和Supervisor模式（S 模式）分别用于常规应用程序和操作系统使用。</p>
<p>每个权限级别都有一组核心的特权 ISA 扩展以及可选的扩展和变体。例如，机器模式支持内存保护的可选标准扩展。此外，Supervisor mode还可以扩展以支持第 8 章中所述的 2 类(Type-2)Hypervisor执行。</p>
<p>实现可能会提供 1 到 3 种特权模式，权衡减少隔离以降低实现成本，如表 1.2 所示。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724091545998-1730798006986-4.png" alt="image-20230724091545998"></p>
<p>所有硬件实现都必须提供 M 模式，因为这是唯一可以不受限制地访问整个机器的模式。最简单的 RISC-V 实现可能仅提供 M 模式，但这无法提供针对不正确或恶意应用程序代码的保护。</p>
<blockquote>
<p>即使仅实施 M 模式，可选 PMP 设施的锁定功能也可以提供一些有限的保护。</p>
</blockquote>
<p>许多 RISC-V 实现还将至少支持User mode（U 模式），以保护系统的其余部分免受应用程序代码的影响。可以添加Supervisor mode（S 模式）以提供Supervisor级操作系统和 SEE 之间的隔离。</p>
<p>Hart 通常在 U 模式下运行应用程序代码，直到某些陷阱（例如，Supervisor调用或定时器中断）强制切换到陷阱处理程序，该处理程序通常在更高特权模式下运行。然后，hart 将执行陷阱处理程序，该处理程序最终将在 U 模式下的原始捕获指令处或之后恢复执行。增加特权级别的陷阱称为垂直陷阱，而保持相同特权级别的陷阱称为水平陷阱。 RISC-V特权架构提供了将陷阱灵活路由到不同特权层的功能。</p>
<blockquote>
<p>水平(Horizontal)陷阱可以实现为垂直(vertical)陷阱，将控制权返回到低特权模式下的水平陷阱处理程序。</p>
</blockquote>
<h2 id="1-3-调试模式"><a href="#1-3-调试模式" class="headerlink" title="1.3 调试模式"></a>1.3 调试模式</h2><p>实现方式还可以包括调试模式以支持片外调试和&#x2F;或制造测试。调试模式（D 模式）可以被视为一种附加特权模式，比 M 模式具有更多的访问权限。单独的调试规范提案描述了 RISC-V 硬件在调试模式下的操作。调试模式保留一些只能在 D 模式下访问的 CSR 地址，并且还可能保留平台上物理地址空间的某些部分。</p>
<h1 id="2-控制和状态寄存器-CSR"><a href="#2-控制和状态寄存器-CSR" class="headerlink" title="2. 控制和状态寄存器 (CSR)"></a>2. 控制和状态寄存器 (CSR)</h1><p>SYSTEM 主操作码用于对 RISC-V ISA 中的所有特权指令进行编码。它们可以分为两个主要类别：原子读取-修改-写入控制和状态寄存器 (CSR)（在 Zicsr 扩展中定义）以及所有其他特权指令。特权架构需要Zicsr扩展；需要哪些其他特权指令取决于特权架构功能集。</p>
<p>除了本手册第 I 卷中描述的非特权状态之外，实现还可能包含其他 CSR，可以使用第 I 卷中描述的 CSR 指令通过特权级别的某些子集进行访问。在本章中，我们将映射 CSR 地址空间。以下章节根据特权级别描述了每个 CSR 的功能，以及通常与特定特权级别密切相关的其他特权指令。请注意，虽然 CSR 和指令与一个特权级别相关联，但它们也可以在所有更高的特权级别上访问。</p>
<p>标准 CSR 对读取没有副作用，但可能对写入有副作用。</p>
<h2 id="2-1-CSR-地址映射约定"><a href="#2-1-CSR-地址映射约定" class="headerlink" title="2.1 CSR 地址映射约定"></a>2.1 CSR 地址映射约定</h2><p>标准 RISC-V ISA 为最多 4,096 个 CSR 预留了 12 位编码空间 (CSR[11:0])。按照惯例，CSR 地址的高 4 位 (CSR[11:8]) 用于根据特权级别对 CSR 的读写可访问性进行编码，如表 2.1 所示。高两位 (CSR[11:10]) 指示寄存器是读&#x2F;写（00、01 或 10）还是只读（11）。接下来的两位 (CSR[9:8]) 编码可以访问 CSR 的最低特权级别。</p>
<blockquote>
<p>CSR 地址约定使用 CSR 地址的高位来编码默认访问权限。这简化了硬件中的错误检查并提供了更大的 CSR 空间，但确实限制了 CSR 到地址空间的映射。</p>
<p>实现可能允许较高特权级别捕获较低特权级别允许的 CSR 访问，以允许拦截这些访问。此更改对于特权较低的软件应该是透明的。</p>
</blockquote>
<p>尝试访问不存在的 CSR 会引发非法指令异常。尝试在没有适当权限级别的情况下访问 CSR 或写入只读寄存器也会引发非法指令异常。读&#x2F;写寄存器还可能包含一些只读位，在这种情况下，对只读位的写入将被忽略。</p>
<p>表 2.1 还指出了在标准用途和自定义用途之间分配 CSR 地址的约定。指定用于自定义用途的 CSR 地址不会由未来的标准扩展重新定义。</p>
<p>机器模式标准读写 CSR 0x7A0–0x7BF 保留供调试系统使用。在这些 CSR 中，0x7A0–0x7AF 可在机器模式下访问，而 0x7B0–0x7BF 仅在调试模式下可见。实现应该在机器模式访问后一组寄存器时引发非法指令异常。</p>
<blockquote>
<p>有效的虚拟化要求尽可能多的指令在虚拟化环境中本地运行，而任何特权访问都会陷入virtual machine monitor[1]。在某些较低权限级别为只读的 CSR，如果在较高权限级别变为可读写，则将被隐藏到单独的 CSR 地址中。这可以避免捕获允许的低权限访问，同时仍然导致非法访问的陷阱。目前，这些<strong>计数器是唯一 shadowed CSR</strong>。</p>
</blockquote>
<h2 id="2-2-CSR列表"><a href="#2-2-CSR列表" class="headerlink" title="2.2  CSR列表"></a>2.2  CSR列表</h2><p>当前已分配CSR地址的CSR如表2.2-2.6所示。计时器、计数器和浮点CSR都是标准的非特权CSR。其他寄存器由特权代码使用，如下面的章节所述。请注意，并非所有实现都需要所有寄存器。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724092947472-1730798006986-5.png" alt="image-20230724092947472"></p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724093027371-1730798006986-6.png" alt="image-20230724093027371"></p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724093049447-1730798006986-7.png" alt="image-20230724093049447"></p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724093108718-1730798006986-10.png" alt="image-20230724093108718"></p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724093212114-1730798006986-8.png" alt="image-20230724093212114"></p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724093306572-1730798006986-9.png" alt="image-20230724093306572"></p>
<h2 id="2-3-CSR字段规格"><a href="#2-3-CSR字段规格" class="headerlink" title="2.3 CSR字段规格"></a>2.3 CSR字段规格</h2><p>CSR Field Specifications</p>
<p>以下定义和缩写用于指定CSR中字段的行为。</p>
<h4 id="保留写保留值，读忽略值-WPRI"><a href="#保留写保留值，读忽略值-WPRI" class="headerlink" title="保留写保留值，读忽略值(WPRI)"></a>保留写保留值，读忽略值(WPRI)</h4><p>一些完整的读&#x2F;写字段被保留以备将来使用。软件应该忽略从这些字段中读取的值，当将值写入同一寄存器的其他字段时，应该保留这些字段中保存的值。为了向前兼容，不提供这些字段的实现必须将它们设置为只读零。这些字段在寄存器描述中被标记为WPRI。</p>
<blockquote>
<p>为了简化软件模型，CSR中先前保留字段的任何向后兼容的未来定义都必须处理使用非原子读&#x2F;修改&#x2F;写序列来更新CSR中的其他字段的可能性。或者，原始CSR定义必须指定子字段只能自动更新，这通常可能需要两个指令的清除位&#x2F;设置位序列，如果中间值不合法，则可能会出现问题。</p>
</blockquote>
<h4 id="只写-只读合法值-WLRL"><a href="#只写-只读合法值-WLRL" class="headerlink" title="只写&#x2F;只读合法值(WLRL)"></a>只写&#x2F;只读合法值(WLRL)</h4><p>一些读&#x2F;写CSR字段仅为可能的位编码的子集指定行为，保留其他位编码。软件不应该向这样的字段写入除合法值之外的任何东西，并且不应该假设读操作将返回合法值，除非最后一次写入是合法值，或者寄存器在另一次操作(例如，重置)将寄存器设置为合法值之后没有被写入。这些字段在寄存器描述中被标记为WLRL。</p>
<blockquote>
<p>硬件实现只需要实现足够的状态位来区分受支持的值，但在读取时必须始终返回任何受支持值的完整指定位编码。</p>
</blockquote>
<p>如果指令试图将不受支持的值写入WLRL字段，则允许但不要求实现引发非法指令异常。当最后一次写入是非法值时，实现可以在读取WLRL字段时返回任意位模式，但是返回的值应该确定地取决于非法写入的值和写入前字段的值。</p>
<h4 id="写入任意值，读取合法值-WARL"><a href="#写入任意值，读取合法值-WARL" class="headerlink" title="写入任意值，读取合法值(WARL)"></a>写入任意值，读取合法值(WARL)</h4><p>一些读&#x2F;写CSR字段仅为位编码的子集定义，但允许写入任何值，同时保证在读取时返回合法值。假设写入CSR没有其他副作用，则可以通过尝试写入所需设置，然后读取以查看是否保留该值来确定支持值的范围。这些字段在寄存器描述中被标记为WARL。</p>
<p>实现不会在将不支持的值写入WARL字段时引发异常。当最后一次写入是非法值时，实现可以在读取WARL字段时返回任何合法值，但是返回的合法值应该确定地取决于非法写入的值和hart的体系结构状态。</p>
<h2 id="2-4-CSR字段调整"><a href="#2-4-CSR字段调整" class="headerlink" title="2.4 CSR字段调整"></a>2.4 CSR字段调整</h2><p>CSR Field Modulation</p>
<p>如果对一个CSR的写入更改了第二个CSR的字段允许的合法值集，那么除非另有指定，否则第二个CSR的字段将立即从其新的合法值中获得一个未指定的值。即使字段在写入前的值在写入后仍然是合法的，也是如此;字段的值可能会因为写入控制CSR而改变。</p>
<blockquote>
<p>作为该规则的特殊情况，写入一个CSR的值可以控制第二个CSR的字段是可写(具有多个合法值)还是只读。当对控制CSR的写入导致第二个CSR的字段从以前的只读变为现在的可写时，该字段立即获得一个未指定但合法的值，除非另有指定。</p>
</blockquote>
<blockquote>
<p>当可写时，一些CSR字段被定义为其他CSR字段的别名。设x为这样一个CSR字段，设y为可写时它别名的CSR字段。如果对控制CSR的写入导致字段x从以前的只读变为现在的可写，则x的新值不是未指定的，而是立即反映其别名y的现有值</p>
</blockquote>
<p>由于这个原因对CSR值的更改不是对受影响的CSR的写入，因此不会触发为该CSR指定的任何副作用。</p>
<h2 id="2-5-CSR隐式读取"><a href="#2-5-CSR隐式读取" class="headerlink" title="2.5 CSR隐式读取"></a>2.5 CSR隐式读取</h2><p>实现有时会执行CSR的隐式读取。(例如，所有S模式读取指令都会隐式地读取satp CSR。)除非另有指定，否则隐式读取CSR所返回的值与在足够特权模式下使用CSR访问指令显式读取CSR所返回的值是相同的。</p>
<h2 id="2-6-CSR位宽调整"><a href="#2-6-CSR位宽调整" class="headerlink" title="2.6 CSR位宽调整"></a>2.6 CSR位宽调整</h2><p>如果CSR的宽度被改变(例如，通过改变MXLEN或UXLEN，如3.1.6.2节所述)，除非另有说明，否则新宽度CSR的可写字段和位的值将像以下算法一样从前宽度CSR中确定:</p>
<ol>
<li>前一宽度CSR的值被复制到相同宽度的临时寄存器中。</li>
<li>对于前一宽度CSR的只读位，临时寄存器中相同位置的位被设置为零。</li>
<li>临时寄存器的宽度被更改为新宽度。如果新的宽度W比以前的宽度窄，则保留临时寄存器中最低有效的W位，而丢弃较高有效的位。如果新宽度比以前的宽度宽，则临时寄存器为零扩展到更宽的宽度。</li>
<li>新宽度CSR的每个可写字段取临时寄存器中相同位置的位的值。</li>
</ol>
<p>更改CSR的宽度不是对CSR的读写，因此不会触发任何副作用。</p>
<h1 id="3-机器级ISA，版本1-12"><a href="#3-机器级ISA，版本1-12" class="headerlink" title="3. 机器级ISA，版本1.12"></a>3. 机器级ISA，版本1.12</h1><p>本章描述RISC-V系统中最高权限的机器模式(M-mode)下的机器级操作。M模式用于对硬件平台的低级访问，是复位时进入的第一个模式。M模式还可以用于实现在硬件中直接实现过于困难或昂贵的特性。RISC-V机器级ISA包含一个公共核心，该核心根据支持的其他特权级别和硬件实现的其他细节进行扩展。</p>
<h2 id="3-1机器级CSR"><a href="#3-1机器级CSR" class="headerlink" title="3.1机器级CSR"></a>3.1机器级CSR</h2><p>除了本节中描述的机器级CSR之外，M模式代码还可以以较低的特权级别访问所有CSR。</p>
<h3 id="3-1-1-机器ISA寄存器-misa"><a href="#3-1-1-机器ISA寄存器-misa" class="headerlink" title="3.1.1 机器ISA寄存器 (misa)"></a>3.1.1 机器ISA寄存器 (misa)</h3><p>misa CSR是一个WARL读写寄存器，报告hart支持的ISA。该寄存器在任何实现中都必须是可读的，但是可以返回0值来表示未实现misa寄存器，这要求通过单独的非标准机制确定CPU能力。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724095308359-1730798006986-11.png" alt="image-20230724095308359"></p>
<p>MXL (Machine XLEN)字段编码本机基数整数ISA宽度，如表3.1所示。</p>
<p>在支持多个基本isa的实现中，MXL字段可能是可写的。M模式下的有效XLEN, MXLEN，由MXL的设置给出，如果misa为零，则有一个固定值。</p>
<p>在重置时，MXL字段总是被设置为支持的最宽的ISA变体。</p>
<center> <span id="Table3-1">Table 3.1</span></center>

<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724095400413-1730798006986-12.png" alt="image-20230724095400413"></p>
<p>misa CSR是MXLEN位宽。如果从misa中读取的值非零，则该值的字段MXL始终表示当前的MXLEN。如果对misa的写入导致MXLEN发生变化，则MXL的位置移动到misa在新宽度处的最重要的两位。</p>
<blockquote>
<p>基数宽度可以使用返回的misa值符号上的分支来快速确定，并且可能在符号上留下一个和第二个分支的移位。这些检查可以在汇编代码中编写，而不需要知道机器的寄存器宽度(XLEN)。基本宽度由XLEN &#x3D; 2^MXL+4^给出。</p>
<p>如果misa为零，也可以通过将直接的4放入寄存器中，然后每次将寄存器向左移动31位来找到基宽。如果一次移位后为零，则机器为RV32。如果两次移位后为零，则机器为RV64，否则为RV128。</p>
</blockquote>
<p>Extensions字段对标准扩展名的存在进行编码，每个字母使用一个比特(比特0编码扩展名“A”的存在，比特1编码扩展名“B”的存在，直到比特25编码扩展名“Z”)。RV32I、RV64I、RV128I基isa的“I”位将被设置，RV32E的“E”位将被设置。Extensions字段是一个可以包含可写位的WARL字段，实现允许修改受支持的ISA。在重置时，Extensions字段将包含支持的扩展的最大集合，如果两者都可用，则将选择I而不是E。</p>
<p>当通过清除misa中的位禁用标准扩展时，由扩展定义或修改的指令和CSR将恢复到其定义或保留的行为，就像没有实现该扩展一样</p>
<p>RV128I基础ISA的设计尚未完成，虽然该规范的大部分其余部分预计将适用于RV128，但本版本的文档仅关注RV32和RV64。</p>
<p>“U”和“S”位将分别设置为支持用户和Supervisor模式。</p>
<p>如果有任何非标准扩展，则设置“X”位。</p>
<blockquote>
<p>misa CSR向机器模式代码公开了CPU特性的基本目录。在机器模式下，通过探测其他机器寄存器，以及作为引导过程的一部分检查系统中的其他ROM存储器，可以获得更广泛的信息。</p>
<p>我们要求较低的特权级别执行环境调用，而不是读取CPU寄存器，以确定每个特权级别可用的特性。这使得虚拟化层可以改变在任何级别上观察到的ISA，并支持更丰富的命令界面，而无需增加硬件设计的负担。</p>
</blockquote>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724095635409-1730798006986-13.png" alt="image-20230724095635409"></p>
<p>“E”位为只读。除非misa全为只读零，否则“E”位总是读取为“I”位的补码。同时支持RV32E和RV32I的实现可以通过清除“I”位来选择RV32E。</p>
<p>如果一个ISA特性x依赖于一个ISA特性y，那么尝试启用特性x而禁用特性y会导致两个特性都被禁用。例如，设置“F”&#x3D;0，“D”&#x3D;1，结果将清除“F”和“D”。</p>
<p>实现可能会对两个或多个misa字段的集合设置施加额外的约束，在这种情况下，它们作为单个WARL字段一起工作。如果试图写入不受支持的组合，将导致这些位被设置为受支持的组合。</p>
<p>书写错误可能会增加IALIGN，例如，通过禁用“C”扩展。如果一条写misa的指令增加了IALIGN，而后续指令的地址不是IALIGN位对齐的，那么对misa的写操作将被抑制，使misa保持不变。</p>
<p>当软件启用以前被禁用的扩展时，除非该扩展另有指定，否则与该扩展唯一关联的所有状态都未指定。</p>
<h3 id="3-1-2-机器Vendor-ID-寄存器-mvendorid"><a href="#3-1-2-机器Vendor-ID-寄存器-mvendorid" class="headerlink" title="3.1.2 机器Vendor ID 寄存器 (mvendorid)"></a>3.1.2 机器Vendor ID 寄存器 (mvendorid)</h3><p>WTD</p>
<h3 id="3-1-3-机器体系结构ID寄存器-marchid"><a href="#3-1-3-机器体系结构ID寄存器-marchid" class="headerlink" title="3.1.3 机器体系结构ID寄存器 (marchid )"></a>3.1.3 机器体系结构ID寄存器 (marchid )</h3><p>marchid CSR是一个mxlen位的只读寄存器，编码hart的基本微体系结构。该寄存器在任何实现中都必须是可读的，但是可以返回0值来表示未实现该字段。mvendorid和marchid的组合应该唯一地标识所实现的hart微架构的类型。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724100248717-1730798006986-15.png" alt="image-20230724100248717"></p>
<p>开源项目架构id由RISC-V International在全球范围内分配，并且具有具有零最高有效位(MSB)的非零架构id。商业架构id由每个商业供应商独立分配，但必须设置MSB，并且在剩余的MXLEN-1位中不能包含零。</p>
<blockquote>
<p>这样做的目的是让体系结构ID表示与开发围绕的回购相关的微体系结构，而不是特定的组织。开源设计的商业制造应该(并且可能被许可要求)保留原始架构ID。这将有助于减少碎片化和工具支持成本，并提供归属。开源架构id由RISC-V International管理，应该只分配给已发布的、正常运行的开源项目。商业架构id可以由任何注册的供应商独立管理，但如果供应商希望同时使用闭源和开源微架构，则需要将id与开源架构id分开(MSB集)，以防止冲突。</p>
<p>在以下Implementation字段中采用的约定可用于隔离相同体系结构设计的分支，包括按组织进行隔离。misa寄存器还有助于区分设计的不同变体</p>
</blockquote>
<h3 id="3-1-4-机器实现ID寄存器-mimpid"><a href="#3-1-4-机器实现ID寄存器-mimpid" class="headerlink" title="3.1.4 机器实现ID寄存器 (mimpid)"></a>3.1.4 机器实现ID寄存器 (mimpid)</h3><p>mimpid CSR提供了处理器实现版本的唯一编码。这个寄存器在任何实现中都必须是可读的，但是可以返回0值来表示该字段没有实现。实现值应该反映RISC-V处理器本身的设计，而不是任何周围的系统。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724101023176-1730798006986-14.png" alt="image-20230724101023176"></p>
<blockquote>
<p>该字段的格式留给体系结构源代码的提供者，但通常会被标准工具打印为十六进制字符串，没有任何前导或尾零，因此实现值可以左对齐(即，从最重要的一点点向下填充)，子字段按照一点点边界对齐，以简化人类的可读性。</p>
</blockquote>
<h3 id="3-1-5-Hart-ID-寄存器-mhartid"><a href="#3-1-5-Hart-ID-寄存器-mhartid" class="headerlink" title="3.1.5 Hart ID 寄存器(mhartid)"></a>3.1.5 Hart ID 寄存器(mhartid)</h3><p>hartid CSR是一个mxlen位的只读寄存器，包含运行代码的硬件线程的整数ID。这个寄存器在任何实现中都必须是可读的。在多处理器系统中，Hart ID不一定连续编号，但至少有一个Hart ID必须为零。Hart id在执行环境中必须是唯一的。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724101123366-1730798006986-16.png" alt="image-20230724101123366"></p>
<blockquote>
<p>在某些情况下，我们必须确保只有一个hart运行某些代码(例如，在重置时)，因此要求一个hart具有已知的hart ID为0。</p>
<p>为了提高效率，系统实现者应该致力于减少系统中使用的最大hart ID的大小。</p>
</blockquote>
<h3 id="3-1-6-机器状态寄存器-mstatus和mstatush"><a href="#3-1-6-机器状态寄存器-mstatus和mstatush" class="headerlink" title="3.1.6 机器状态寄存器(mstatus和mstatush)"></a>3.1.6 机器状态寄存器(mstatus和mstatush)</h3><p>mstatus寄存器是一个mxlen位读写寄存器，RV32和RV64的格式分别如图3.6和3.7所示。状态寄存器跟踪并控制hart的当前运行状态。mstatus的受限视图显示为S级ISA中的sstatus寄存器。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724101211800-1730798006986-17.png" alt="image-20230724101211800"></p>
<p>对于RV32, mstatush是一个32位读写寄存器，格式如图3.8所示。mstatush的30:4位通常包含与RV64的mstatus的62:36位相同的字段。mstatush中不存在SD、SXL和UXL字段。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724101231546-1730798006986-18.png" alt="image-20230724101231546"></p>
<h4 id="3-1-6-1-mstatus寄存器中的特权和全局中断使能堆栈"><a href="#3-1-6-1-mstatus寄存器中的特权和全局中断使能堆栈" class="headerlink" title="3.1.6.1 mstatus寄存器中的特权和全局中断使能堆栈"></a>3.1.6.1 mstatus寄存器中的特权和全局中断使能堆栈</h4><p>全局中断使能位，<strong>MIE</strong>和<strong>SIE</strong>，分别为M模式和S模式提供。这些位主要用于保证当前特权模式下中断处理程序的原子性。</p>
<blockquote>
<p>全局xIE位位于状态的低阶位，允许使用单个CSR指令自动设置或清除它们。</p>
</blockquote>
<p>当hart在特权模式x下执行时，当x IE&#x3D;1时全局启用中断，当x IE&#x3D;0时全局禁用中断。无论较低特权模式的任何全局w IE位的设置如何，较低权限模式的中断 w&lt;x 始终被全局禁用。无论更高特权模式的全局yIE位的设置如何，都始终全局启用更高权限模式的中断 y&gt;x 。在将控制权交给较低特权模式之前，较高特权级别代码可以使用单独的每中断使能位来禁用所选的较高特权模式中断。</p>
<blockquote>
<p>高特权模式可以在将控制权交给低特权模式之前禁用所有中断，但这是不寻常的，因为它只会留下同步陷阱、不可屏蔽中断或重置作为重新获得对hart控制的手段。</p>
</blockquote>
<p>为了支持嵌套陷阱，可以响应中断的每个特权模式x都有一个由启用中断的位和特权模式组成的两级堆栈。xPIE保留在trap发生之前激活的中断启用位的值，xPP保留之前的特权模式。xPP字段最多只能容纳x个特权模式，因此MPP是2位宽，SPP是1位宽。当trap从特权模式y进入特权模式x时，xPIE设置为x IE的值;x IE设置为0;xPP设为y。</p>
<blockquote>
<p>对于较低的特权模式，任何陷阱(同步或异步)通常在较高的特权模式下产生，在进入时禁用中断。更高级的陷阱处理程序要么处理陷阱并使用堆叠的信息返回，要么(如果没有立即返回到被中断的上下文)在重新启用中断之前保存特权堆栈，因此每个堆栈只需要一个条目。</p>
</blockquote>
<p>MRET或SRET指令分别用于以M模式或S模式从陷阱返回。</p>
<p>在执行xRET指令时，假设xPP持有值y，则xie被设置为xPIE;将特权模式修改为y;xPIE设置为1;xPP设置为支持的最小特权模式(如果实现了U模式，则为U模式，否则为M模式)。如果xPP $\neq$M, xRET也设置MPRV&#x3D;0。</p>
<blockquote>
<p>将xPP设置为xRET上支持的最低特权模式有助于识别两级特权模式堆栈管理中的软件错误。</p>
</blockquote>
<p><strong>xPP</strong>字段是WARL字段，只能包含特权模式x和任何实现的特权模式低于x。如果没有实现特权模式x，则xPP必须为只读0。</p>
<blockquote>
<p>M模式软件可以通过将特权模式写入MPP然后再读取它来确定特权模式是否被实现。</p>
<p>如果机器只提供U和M模式，那么只需要一个硬件存储位来表示MPP中的00或11。</p>
</blockquote>
<h4 id="3-1-6-2-mstatus寄存器中的Base-ISA控制"><a href="#3-1-6-2-mstatus寄存器中的Base-ISA控制" class="headerlink" title="3.1.6.2 mstatus寄存器中的Base ISA控制"></a>3.1.6.2 mstatus寄存器中的Base ISA控制</h4><p>对于RV64系统，<strong>SXL</strong>和<strong>UXL</strong>字段是分别控制S模式和u模式下<strong>XLEN</strong>值的WARL字段。这些字段的编码与misa的MXL字段相同，如<a href="#Table3-1">表3.1</a>所示。S模式和u模式下的有效XLEN分别称为SXLEN和UXLEN。</p>
<p>对于RV32系统，SXL和UXL字段不存在，并且SXLEN&#x3D;32和UXLEN&#x3D;32。</p>
<ul>
<li><p>对于RV64系统，如果不支持S模式，则SXL为只读零。否则，它是一个编码SXLEN当前值的WARL字段。具体来说，实现可以使SXL成为只读字段，其值始终确保SXLEN&#x3D;MXLEN。</p>
</li>
<li><p>对于RV64系统，如果不支持U模式，则UXL为只读零。否则，它是一个编码UXLEN当前值的WARL字段。具体来说，实现可以使UXL成为只读字段，其值始终确保UXLEN&#x3D;MXLEN或UXLEN&#x3D;SXLEN。</p>
</li>
</ul>
<p>无论在何种模式下，只要将XLEN设置为小于所支持的最宽XLEN的值，所有操作都必须忽略配置的XLEN以上的源操作数寄存器位，并且必须对结果进行符号扩展以填充目标寄存器中所支持的整个最宽XLEN。类似地，大于XLEN的pc位被忽略，当写入pc时，它被符号扩展以填充支持的最宽XLEN。</p>
<blockquote>
<p>我们要求操作总是用定义的值填充整个底层硬件寄存器，以避免实现定义的行为。</p>
<p>为了降低硬件复杂性，该体系结构不检查低权限模式的XLEN设置是否小于或等于下一个高权限模式。在实践中，这样的设置几乎总是软件错误，但即使在这种情况下，机器操作也是定义良好的。</p>
</blockquote>
<p>如果MXLEN从32更改为更宽的宽度，则每个mstatus字段SXL和UXL如果不限制为单个值，则获取与支持的最宽宽度对应的值，该值不大于新的MXLEN。</p>
<h4 id="3-1-6-3-mstatus寄存器中的内存特权"><a href="#3-1-6-3-mstatus寄存器中的内存特权" class="headerlink" title="3.1.6.3 mstatus寄存器中的内存特权"></a>3.1.6.3 mstatus寄存器中的内存特权</h4><p><strong>MPRV</strong>(修改特权)位修改有效特权模式，即执行加载和存储时的特权级别。</p>
<ul>
<li>当MPRV&#x3D;0时，加载和存储正常运行，使用当前特权模式的转换和保护机制。</li>
<li>当MPRV&#x3D;1时，加载地址和存储地址被转换和保护，并应用端序，就像当前特权模式被设置为MPP一样。</li>
<li>指令地址转换和保护不受MPRV设置的影响。</li>
<li>如果不支持U-mode，则MPRV为只读0。</li>
<li>如果MRET或SRET指令将特权模式更改为特权小于M的模式，也会设置MPRV&#x3D;0。</li>
</ul>
<p><strong>MXR</strong>(使可执行可读 Make eXecutable Readable)位修改加载访问虚拟内存的权限。</p>
<ul>
<li>当MXR&#x3D;0时，只有从标记为可读(图4.18中R&#x3D;1)的页面加载才会成功。</li>
<li>当MXR&#x3D;1时，从标记为可读或可执行(R&#x3D;1或X&#x3D;1)的页面加载将成功。</li>
<li>当基于页面的虚拟内存无效时，MXR不起作用。如果不支持S模式，则MXR为只读0。</li>
</ul>
<blockquote>
<p>MPRV和MXR机制旨在提高M模式例程的效率，以模拟缺少的硬件功能，例如，不对齐的负载和存储。MPRV避免了在软件中执行地址转换的需要。MXR允许从标记为仅执行的页面加载指令字。</p>
<p>当前特权模式和MPP指定的特权模式可能具有不同的XLEN设置。当MPRV&#x3D;1时，加载和存储内存地址被视为当前XLEN被设置为MPP的XLEN，遵循第3.1.6.2节的规则。</p>
</blockquote>
<p><strong>SUM</strong>(允许Supervisor User Memory access)位修改S模式加载和存储访问虚拟内存的权限。</p>
<ul>
<li>当SUM&#x3D;0时，S模式内存访问U模式(图4.18中U&#x3D;1)可访问的页面将出现故障。</li>
<li>当SUM&#x3D;1时，允许这些访问。</li>
<li>当基于页面的虚拟内存无效时，SUM不起作用。</li>
<li>请注意，虽然SUM在不以S模式执行时通常会被忽略，但当MPRV&#x3D;1且MPP&#x3D;S时，它会生效。</li>
<li>如果不支持S模式，SUM为只读0。MODE为只读0。</li>
</ul>
<p>MXR和SUM机制只影响对页表项中编码的权限的解释。特别是，它们对是否由于pma或PMP引发访问错误异常没有影响。</p>
<h4 id="3-1-6-4-mstatus和mstatush寄存器的端序控制"><a href="#3-1-6-4-mstatus和mstatush寄存器的端序控制" class="headerlink" title="3.1.6.4 mstatus和mstatush寄存器的端序控制"></a>3.1.6.4 mstatus和mstatush寄存器的端序控制</h4><p>mstatus和mstatush中的MBE、SBE和UBE位是WARL字段，它们控制内存访问(指令获取除外)的端序。指令读取总是小端顺序的。</p>
<ul>
<li><p><strong>MBE</strong>控制从M模式(假设mstatus.MPRV&#x3D;0)进行的非指令获取内存访问是小端(MBE&#x3D;0)还是大端(MBE&#x3D;1)。</p>
</li>
<li><p>如果不支持S 模式，则<strong>SBE</strong>为只读0。否则，SBE控制从S模式进行的显式加载和存储内存访问是小端(SBE&#x3D;0)还是大端(SBE&#x3D;1)。</p>
</li>
<li><p>如果不支持U模式，则<strong>UBE</strong>为只读0。否则，UBE控制从U模式进行的显式加载和存储内存访问是小端(UBE&#x3D;0)还是大端(UBE&#x3D;1)。</p>
</li>
</ul>
<p>对于对监督级内存管理数据结构(如页表)的隐式访问，端序总是由SBE控制。由于改变SBE改变了实现对这些数据结构的解释，如果任何这样的数据结构在改变SBE时仍在使用，M模式软件必须通过执行SFENCE来遵循这种对SBE的更改。rs1&#x3D;x0和rs2&#x3D;x0的VMA指令。</p>
<blockquote>
<p>只有在人为的场景中，给定的内存管理数据结构才会同时被解释为小端和大端。在实践中，SBE只会在世界交换机的运行时更改，在这种情况下，旧的和新的内存管理数据结构都不会以不同的端序重新解释。在本例中，没有额外的SFENCE。VMA是必要的，超出了世界开关通常需要的范围。</p>
</blockquote>
<p>如果支持S模式，则实现可以使SBE成为MBE的只读副本。如果支持u模式，则实现可以使UBE成为MBE或SBE的只读副本。</p>
<blockquote>
<p>如果字段MBE、SBE和UBE都是只读0，则实现只支持小端内存访问。当支持S模式和u模式时，如果MBE为只读1，而SBE和UBE均为只读1，则实现仅支持大端内存访问(指令读取除外)。</p>
</blockquote>
<blockquote>
<p>第一卷将hart的地址空间定义为一个连续地址的2个XLEN字节的循环序列。地址和字节位置之间的对应关系是固定的，不受任何端序模式的影响。相反，适用的端序模式决定了内存字节和多字节数量(半字、字等)之间的映射顺序。</p>
</blockquote>
<blockquote>
<p>标准RISC-V abi预计将是纯小端或大端，不允许混合端序。然而，已经定义了端序控制，以便允许，例如，一个端序的操作系统执行相反端序的User mode程序。还考虑了非标准用法的可能性，即软件根据需要翻转内存访问的端序。</p>
</blockquote>
<blockquote>
<p>RISC-V指令统一采用小端序，将指令编码与当前的端序设置解耦，这对硬件和软件都有好处。否则，例如，RISC-V汇编程序或反汇编程序将始终需要知道预期的活动端序，尽管端序模式可能在执行期间动态更改。相反，通过给指令一个固定的端序，有时精心编写的软件即使在二进制形式中也可能是端序不可知的，就像位置无关代码一样。</p>
<p>然而，对于编码或解码机器指令的RISC-V软件来说，将指令设置为小端确实会产生影响。在大端模式下，这样的软件必须考虑这样一个事实，即显式加载和存储具有与指令相反的端序，例如在加载之后和存储之前交换字节顺序。</p>
</blockquote>
<h4 id="3-1-6-5-mstatus-寄存器中的虚拟化支持"><a href="#3-1-6-5-mstatus-寄存器中的虚拟化支持" class="headerlink" title="3.1.6.5 mstatus 寄存器中的虚拟化支持"></a>3.1.6.5 mstatus 寄存器中的虚拟化支持</h4><p><strong>TVM</strong>（陷阱虚拟内存）位是一个 WARL 字段，支持拦截Supervisor虚拟内存管理操作。</p>
<ul>
<li>当 TVM&#x3D;1 时，在 S 模式下执行时尝试读取或写入 satp CSR 或执行 SFENCE.VMA 或 SINVAL.VMA 指令将引发非法指令异常。</li>
<li>当 TVM&#x3D;0 时，这些操作在S模式下被允许。当不支持 S 模式时，TVM 为只读 0。</li>
</ul>
<blockquote>
<p>TVM 机制允许guest OS在 S 模式下执行，而不是传统的在 U 模式下虚拟化，从而提高虚拟化效率。这种方法无需捕获对大多数 S 模式 CSR 的访问。</p>
<p>捕获 satp 访问以及 SFENCE.VMA 和 SINVAL.VMA 指令提供了延迟填充影子页表所需的挂钩。</p>
</blockquote>
<p><strong>TW</strong>（超时等待）位是一个 WARL 字段，支持拦截 WFI 指令（参见第 3.3.3 节）。</p>
<ul>
<li>当 TW&#x3D;0 时，WFI 指令可能会在较低特权模式下执行（如果未因某些其他原因而被阻止）。</li>
<li>当 TW&#x3D;1 时，如果 WFI 在任何特权较低的模式下执行，并且它没有在特定于实现的有界时间限制内完成，则 WFI 指令会导致非法指令异常。时间限制可能始终为 0，在这种情况下，当 TW&#x3D;1 时，WFI 在低特权模式下总是会导致非法指令异常。当没有比 M 特权更低的模式时，TW 为只读 0。</li>
</ul>
<blockquote>
<p>捕获 WFI 指令可以触发世界切换到另一个guest OS，而不是浪费地在当前guest OS中闲置。</p>
</blockquote>
<p>实现 S 模式时，在 U 模式下执行 WFI 会导致非法指令异常，除非它在特定于实现的有限时间限制内完成。该规范的未来版本可能会添加一项功能，允许 S 模式选择性地允许 U 模式下的 WFI。此功能仅在 TW&#x3D;0 时才有效。</p>
<p><strong>TSR</strong>（Trap SRET）位是一个WARL字段，支持拦截Supervisor异常返回指令SRET。</p>
<ul>
<li>当 TSR&#x3D;1 时，在 S 模式下执行时尝试执行 SRET 将引发非法指令异常。</li>
<li>当 TSR&#x3D;0 时，该操作在 S 模式下允许。当不支持 S 模式时，TSR 为只读 0。</li>
</ul>
<blockquote>
<p>捕获 SRET 对于在不提供 SRET 的实现上模拟Hypervisor扩展（参见第 8 章）是必要的。</p>
</blockquote>
<h4 id="3-1-6-6-mstatus-寄存器中的扩展上下文状态"><a href="#3-1-6-6-mstatus-寄存器中的扩展上下文状态" class="headerlink" title="3.1.6.6 mstatus 寄存器中的扩展上下文状态"></a>3.1.6.6 mstatus 寄存器中的扩展上下文状态</h4><p>支持大量扩展(substantial extensions)是 RISC-V 的主要目标之一，因此我们定义了一个标准接口，以允许未更改的特权模式代码（特别是Supervisor级操作系统）支持任意User mode状态扩展。</p>
<blockquote>
<p>迄今为止，V 扩展是唯一定义浮点 CSR 和数据寄存器之外的附加状态的标准扩展。</p>
</blockquote>
<p><strong>FS</strong>[1:0] 和 <strong>VS</strong>[1:0] WARL 字段以及 <strong>XS</strong>[1:0] 只读字段用于通过分别设置和跟踪浮点单元和任何其他User mode扩展的当前状态来降低上下文保存和恢复的成本。</p>
<ul>
<li>FS 字段编码浮点单元状态的状态，包括浮点寄存器 f0-f31 和 CSR fcsr、frm 和 fflags。 </li>
<li>VS 字段编码向量扩展状态的状态，包括向量寄存器 v0-v31和CSR vcsr、vxrm、vxsat、vstart、vl、vtype和vlenb。 </li>
<li>XS 字段对附加User mode扩展的状态和关联状态进行编码。</li>
</ul>
<p>这些字段可以通过上下文切换例程进行检查，以快速确定是否需要状态保存或恢复。如果需要保存或恢复，通常需要额外的指令和 CSR 来实现和优化该过程。</p>
<blockquote>
<p>该设计预计大多数上下文切换不需要在浮点单元或其他扩展中的一个或两个中保存&#x2F;恢复状态，因此通过 SD 位提供快速检查。</p>
</blockquote>
<p>FS、VS 和 XS 字段使用与表 3.3 中所示相同的状态编码，四个可能的状态值是 Off、Initial、Clean 和 Dirty。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724104043893-1730798006986-19.png" alt="image-20230724104043893"></p>
<p>如果实现F扩展，FS字段不应是只读零。</p>
<p>如果 F 扩展和 S 模式均未实现，则 FS 为只读零。如果实现了 S 模式但未实现 F 扩展，则 FS 可以选择为只读零。</p>
<blockquote>
<p>允许但不要求使用 S 模式但不带 F 扩展的实现，以使 FS 字段为只读零。一些此类实现将选择不让 FS 字段为只读零，以便能够通过 M 模式中的不可见陷阱来模拟 S 模式和 U 模式的 F 扩展。</p>
</blockquote>
<p>如果实现了 v （向量）寄存器，则 VS 字段不应为只读零。</p>
<p>如果 v （向量）寄存器和 S 模式均未实现，则 VS 为只读零。如果实现了 S 模式但未实现 v 寄存器，则 VS 可以选择为只读零。</p>
<p>在没有需要新状态的附加用户扩展的系统中，XS 字段是只读的零。每个具有状态的附加扩展都提供一个 CSR 字段，该字段对 XS 状态的等效项进行编码。 XS 字段表示所有分机状态的摘要，如表 3.3 所示。</p>
<p>XS 字段有效地报告所有用户分机状态字段的最大状态值，尽管各个分机可以使用与 XS 不同的编码。</p>
<p><strong>SD</strong> 位是一个只读位，它总结了 FS、VS 或 XS 字段是否表示存在某些需要将扩展用户上下文保存到内存的脏状态。如果 FS、XS 和 VS 均为只读零，则 SD 也始终为零。</p>
<ul>
<li>当扩展的状态设置为Off时，任何尝试读取或写入相应状态的指令都会导致非法指令异常。</li>
<li>当状态为 Initial 时，对应的状态应该有一个初始常量值。</li>
<li>当状态为 Clean 时，相应的状态可能与初始值不同，但与上下文交换中存储的最后一个值匹配。</li>
<li>当状态为 Dirty 时，自上次上下文保存以来相应的状态可能已被修改。</li>
</ul>
<p>在上下文保存期间，负责的特权代码只需在其状态为 Dirty 时写出相应的状态，然后就可以将扩展的状态重置为 Clean。在上下文恢复期间，仅当状态为“Clean”时才需要从内存加载上下文（恢复时绝不应为“Dirty”）。如果状态为“Initial”，则必须在上下文恢复时将上下文设置为初始常量值以避免安全漏洞，但这可以在不访问内存的情况下完成。例如，浮点寄存器都可以初始化为立即数0。</p>
<p>FS 和 XS 字段在保存上下文之前由特权代码读取。 FS 字段是在恢复用户上下文时由特权代码直接设置的，而 XS 字段是通过写入各个扩展的状态寄存器来间接设置的。无论特权模式如何，状态字段也会在指令执行期间更新。</p>
<p>User mode ISA 的扩展通常包括额外的User mode状态，并且该状态可能比基本整数寄存器大得多。这些扩展可能仅用于某些应用程序，或者可能仅在单个应用程序中的短期阶段需要。为了提高性能，User mode扩展可以定义附加指令，以允许User mode软件将单元返回到初始状态，甚至关闭单元。</p>
<p>例如，协处理器可能需要在使用前进行配置，并在使用后可以“取消配置”。未配置的状态将表示为上下文保存的初始状态。如果同一应用程序在取消配置和下一次配置（这会将状态设置为脏）之间保持运行，则无需在取消配置指令处实际重新初始化状态，因为所有状态都是用户进程的本地状态，即初始状态可能只会导致协处理器状态在上下文恢复时初始化为常量值，而不是在每次取消配置时。</p>
<p>如果任何后续指令在重新打开之前尝试使用该单元，则执行User mode指令来禁用某个单元并将其置于关闭状态将导致引发非法指令异常。打开单元的User mode指令还必须确保单元的状态正确初始化，因为该单元可能已被另一个上下文同时使用。</p>
<p>改变 FS 的设置对浮点寄存器状态的内容没有影响。特别是，设置 FS&#x3D;Off 不会破坏状态，设置 FS&#x3D;Initial 也不会清除内容。同样，VS的设置对向量寄存器状态的内容没有影响。但是，其他扩展在设置为“关闭”时可能不会保留状态。</p>
<p>实现可能会选择通过报告状态为脏状态来不精确地跟踪浮点寄存器状态的脏状态，即使它没有被修改。在某些实现中，某些不改变浮点状态的指令可能会导致状态从“初始”或“干净”转换为“脏”。在其他实现中，可能根本不会跟踪脏度，在这种情况下，有效的 FS 状态为“关闭”和“脏”，并且尝试将 FS 设置为“初始”或“干净”会导致将其设置为“脏”。</p>
<blockquote>
<p>FS 的这个定义并不禁止由于错误的推测而将 FS 设置为 Dirty。某些平台可能会选择禁止推测性写入 FS 以关闭潜在的侧通道。</p>
</blockquote>
<p>如果指令显式或隐式写入浮点寄存器或 fcsr 但不更改其内容，并且 FS&#x3D;Initial 或 FS&#x3D;Clean，则 FS 是否转换为 Dirty 由实现定义。</p>
<p>实现方式可以选择以类似的不精确方式跟踪向量寄存器状态的脏度，包括当软件尝试设置 VS&#x3D;Initial 或 VS&#x3D;Clean 时可能将 VS 设置为 Dirty。当 VS&#x3D;Initial 或 VS&#x3D;Clean 时，写入向量寄存器或向量 CSR 但不更改其内容的指令是否会导致 VS 转换为 Dirty 是由实现定义的。</p>
<p>表 3.4 显示了 FS、VS 或 XS 状态位的所有可能的状态转换。请注意，标准浮点和向量扩展不支持User mode取消配置或禁用&#x2F;启用指令。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724104307345-1730798006986-20.png" alt="image-20230724104307345"></p>
<p>提供了用于初始化、保存和恢复扩展状态的标准特权指令，以通过将状态视为不透明对象来将特权代码与添加的扩展状态的细节隔离。</p>
<blockquote>
<p>许多协处理器扩展仅在有限的上下文中使用，允许软件在完成后安全地取消配置甚至禁用单元。这减少了大型有状态协处理器的上下文切换开销。</p>
<p>我们将浮点状态与其他扩展状态分开，因为当存在浮点单元时，浮点寄存器是标准调用约定的一部分，因此User mode软件无法知道何时可以安全地禁用浮点单元。</p>
</blockquote>
<p>XS 字段提供所有添加的扩展状态的摘要，但扩展中可能会维护额外的微架构位，以进一步减少上下文保存和恢复开销。</p>
<p>SD 位是只读的，并且当 FS、VS 或 XS 位编码脏状态（即 SD&#x3D;((FS=&#x3D;11) OR (XS=&#x3D;11) OR (VS=&#x3D;11))）时设置。这使得特权代码能够快速确定何时除了整数寄存器组和 PC 之外不需要额外的上下文保存。</p>
<p>浮点单元状态始终使用标准指令（F、D 和&#x2F;或 Q）进行初始化、保存和恢复，并且特权代码必须了解 FLEN 以确定为每个 f 寄存器保留的适当空间。</p>
<p>机器和管理模式共享 FS、VS 和 XS 位的单个副本。Supervisor级软件通常直接使用 FS、VS 和 XS 位来记录与Supervisor级保存的上下文相关的状态。机器级软件在相应版本的上下文中保存和恢复扩展状态时必须更加保守。</p>
<blockquote>
<p>在任何合理的用例中，用户和Supervisor级别之间的上下文切换数量应远远超过其他特权级别的上下文切换数量。请注意，协处理器不应要求保存和恢复其上下文来服务异步中断，除非中断导致用户级上下文交换。</p>
</blockquote>
<h3 id="3-1-7-机器陷阱向量基地址寄存器（mtvec）"><a href="#3-1-7-机器陷阱向量基地址寄存器（mtvec）" class="headerlink" title="3.1.7 机器陷阱向量基地址寄存器（mtvec）"></a>3.1.7 机器陷阱向量基地址寄存器（mtvec）</h3><p>mtvec 寄存器是一个 MXLEN 位 WARL 读&#x2F;写寄存器，用于保存陷阱向量配置，由向量基地址 (BASE) 和向量模式 (MODE) 组成。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724104704315-1730798006986-21.png" alt="image-20230724104704315"></p>
<p>mtvec 寄存器必须始终被实现，但可以包含只读值。如果 mtvec 可写，则寄存器可以保存的值集可能会因实现而异。 BASE 字段中的值必须始终在 4 字节边界上对齐，并且 MODE 设置可能会对 BASE 字段中的值施加额外的对齐约束</p>
<blockquote>
<p>我们在陷阱向量基地址的实现中允许相当大的灵活性。一方面，我们不希望给低端实现带来大量状态位的负担，但另一方面，我们希望为更大的系统提供灵活性。</p>
</blockquote>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724104727948-1730798006986-22.png" alt="image-20230724104727948"></p>
<p>MODE字段的编码如表3.5所示。</p>
<p>当 MODE&#x3D;Direct 时，所有进入机器模式的陷阱都会导致 pc 设置为 BASE 字段中的地址。</p>
<p>当 MODE&#x3D;Vectored 时，所有进入机器模式的同步异常都会导致 pc 被设置为 BASE 字段中的地址，而中断则导致 pc 被设置为 BASE 字段中的地址加上中断原因编号的四倍。例如，机器模式定时器中断（参见第 39 页表 3.6）导致 pc 设置为 BASE+0x1c。</p>
<blockquote>
<p>当启用向量中断时，对应于User mode软件中断的中断原因 0 将被向量到与同步异常相同的位置。这种歧义在实践中不会出现，因为User mode软件中断要么被禁用，要么被委托给User mode。</p>
</blockquote>
<p>对于不同的模式，实现可能具有不同的对齐约束。特别是，MODE&#x3D;Vectored 可能比 MODE&#x3D;Direct 具有更严格的对齐约束。</p>
<blockquote>
<p>允许在向量模式下进行更粗略的对齐，从而无需硬件加法器电路即可实现向量化。</p>
</blockquote>
<blockquote>
<p>复位和 NMI 向量位置在平台规范中给出。</p>
</blockquote>
<h3 id="3-1-8-机器陷阱委托寄存器-medeleg-and-mideleg"><a href="#3-1-8-机器陷阱委托寄存器-medeleg-and-mideleg" class="headerlink" title="3.1.8  机器陷阱委托寄存器  (medeleg and mideleg)"></a>3.1.8  机器陷阱委托寄存器  (medeleg and mideleg)</h3><p>Machine Trap Delegation Registers</p>
<p>默认情况下，任何特权级别的所有Trap都是在机器模式下处理的，尽管机器模式处理程序可以使用 <strong>MRET</strong> 指令将陷阱重定向回适当的级别(第3.3.2节)。</p>
<p>为了提高性能，实现可以在<code>medeleg</code>和<code>mideleg</code>中提供单独的读&#x2F;写位，以指示某些异常和中断应该由较低的特权级别直接处理。机器异常委托寄存器(<code>medeleg</code>)和机器中断委托寄存器(<code>mideleg</code>)是mxlen位读&#x2F;写寄存器。</p>
<p>在具有S模式的系统中，必须存在<code>medeleg</code>和<code>mideleg</code>寄存器，并且在<code>medeleg</code>或<code>mideleg</code>中设置一个位，当在S模式或U模式下发生时，将把相应的陷阱委托给S-mode陷阱处理程序。在没有S模式的系统中，<code>medeleg</code>和<code>mideleg</code>寄存器不应该存在。</p>
<blockquote>
<p>在1.9.1和更早的版本中，这些寄存器存在，但只在M模式下硬连接到零，或者在没有N系统的M&#x2F;U中。在这些情况下，没有理由要求它们返回零，因为<code>misa</code>寄存器指示它们是否存在。</p>
</blockquote>
<p>当一个陷阱被委托到S模式时:</p>
<ul>
<li><code>scause</code>写入陷阱原因;</li>
<li><code>sepc</code>寄存器写入产生陷阱的指令的虚拟地址;</li>
<li><code>stval</code>寄存器写入使用特定于异常的数据;</li>
<li><code>mstatus.SPP</code>字段写入发生trap时所处的特权模式;</li>
<li><code>mstatus.SPIE</code>字段写入发生trap时<code>mstatus.SIE</code>的值;</li>
<li>并且<code>mstatus.SIE</code>字段被清除。</li>
<li><code>mcause</code>、<code>mepc</code>和<code>mtval</code>寄存器以及<code>mstatus</code>的MPP和MPIE字段不被写。</li>
</ul>
<p>实现对可委派trap可配的子集，通过向每个bit写入1，然后回读<code>medeleg</code>或<code>mideleg</code>中的值，以查看哪些位位置为1，从而找到支持的可委派位。</p>
<p>实现中不能有任何<code>medeleg</code>位是只读的1，也就是说，任何可以委托的同步trap必须能够不使能委托。类似地，实现不应将与机器级中断相对应的<code>mideleg</code>的任何位固定为只读1(但对于较低级的中断可以这样做)。</p>
<blockquote>
<p>版本1.11和更早的版本禁止<code>mideleg</code>的任何位为只读位。平台标准可能总是添加这样的限制</p>
</blockquote>
<p><font color="#FF000">Traps永远不会从特权较多的模式过渡到特权较少的模式。例如，如果M-mode将非法指令异常委托给S模式，而M-mode软件随后执行非法指令，则在M-mode中捕获trap，而不是委托给S模式。相比之下，陷阱(traps)可以水平委托( taken horizontally)。使用同样的例子，如果M-mode将非法指令异常委托给S模式，而S模式软件随后执行非法指令，则在S模式中捕获陷阱。</font></p>
<p>&#x3D;&#x3D;委托中断导致中断在委托权限级别被屏蔽。例如，如果通过设置<code>mideleg[5]</code>将supervisor timer interrupt (STI)委托给S模式，则在M模式下执行时不会触发STI。相反，如果<code>mideleg[5]</code>被清除，则STIs可以在任何模式下进行，无论当前模式如何，都会将控制转移到M模式。&#x3D;&#x3D;</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230606151855672-1730798006986-23.png" alt="image-20230606151855672"></p>
<p><font color="#FF00FF" size="5"><code>medeleg</code></font>为每个同步异常分配了一个bit，如原文39页中 表3.6 所示，每个bit的 &#x3D;&#x3D;索引&#x3D;&#x3D; 等于<code>mcause</code>寄存器中返回的值(即，设置bit 8允许将User mode下环境调用（Environment call from U-mode）委托给权限较低的trap处理程序)。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230606152947876-1730798006986-24.png" alt="image-20230606152947876"></p>
<p><font color="#ff00ff" size="5"><code>mideleg</code></font>为单个中断保存trap委托位，其位的布局与<code>mip</code>寄存器中的位相匹配(即，STIP中断委托控制位于第5位)。</p>
<p>&#x3D;&#x3D;对于不能在较低特权模式下发生的异常，相应的<font color="#FF00FF" size="4"><code>medeleg</code></font>位应该为只读零。特别地，<code>medeleg[11]</code>是只读零。&#x3D;&#x3D;</p>
<h3 id="3-1-9-机器中断使能挂起寄存器-mip-and-mie"><a href="#3-1-9-机器中断使能挂起寄存器-mip-and-mie" class="headerlink" title="3.1.9 机器中断使能挂起寄存器  (mip and mie)"></a>3.1.9 机器中断使能挂起寄存器  (mip and mie)</h3><p>Machine Interrupt Registers</p>
<p>mip是一个MXLEN-bit的读&#x2F;写寄存器，包含挂起中断信息</p>
<p>mie是相应的MXLEN-bit的读&#x2F;写寄存器，包含中断使能位</p>
<p>中断原因号i(如第3.1.15节CSR原因中所述)与mip和mie中的第i位对应。bit15:0只分配给标准中断原因，而bit16及以上被指定用于平台或自定义使用。</p>
<p>如果以下所有条件都为真，中断i将捕获到M模式(导致特权模式更改为M模式):</p>
<ul>
<li>&#x3D;&#x3D;(a)当前特权模式为M并且mstatus寄存器中的MIE位被设置，或者当前特权模式的特权小于M模式;&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;(b)位i在mip和mie中均设置;&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;(c)如果寄存器mideleg存在，则mideleg中没有设置第i位。&#x3D;&#x3D;</li>
</ul>
<p>中断陷阱发生的这些条件必须在中断在mip中变为挂起或停止挂起的有限时间内求值，并且还必须在执行xRET指令或显式写入这些中断陷阱条件明确依赖的CSR(包括mip, mie, mstatus和mideleg)之后立即求值。</p>
<p>M模式的中断比任何低权限模式的中断优先级更高。</p>
<ul>
<li>寄存器mip中的每个位可以是可写的，也可以是只读的。</li>
<li>当mip中的第i位可写时，可以通过向该位写入0来清除挂起的中断i。</li>
<li>如果中断i可以成为挂起，但是mip中的第i位是只读的，则实现必须提供一些其他机制来清除挂起的中断。</li>
</ul>
<p>如果相应的中断可以挂起，则mie中的位必须是可写的。不可写的位必须为只读零。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230607104406917-1730798006986-25.png" alt="image-20230607104406917"></p>
<blockquote>
<p>机器级中断寄存器处理一些根中断源(soft&#x2F;timer)，这些根中断源为简单起见被分配了固定的服务优先级，而单独的外部中断控制器可以在更大的中断集上实现更复杂的优先级方案，然后将这些中断混合到机器级中断源中。</p>
</blockquote>
<blockquote>
<p>不可屏蔽中断不会通过mip寄存器显示，因为在执行NMI陷阱处理程序时，它的存在是隐式已知的。</p>
</blockquote>
<p><code>mip.MEIP</code> 和 <code>mie.MEIE</code>是用于机器级外部中断的中断挂起和中断启用位。<strong>MEIP在mip中是只读的</strong>，由<strong>特定于平台的中断控制器设置和清除</strong>。</p>
<p><code>mip.MTIP</code>和<code>mie.MTIE</code>是机器定时器中断的中断挂起和中断启用位。<strong>MTIP在mip中是只读的</strong>，通过写入内存映射的<strong>机器模式定时器比较寄存器</strong>来清除。</p>
<p><code>mip.MSIP</code>和<code>mie.MSIE</code>是用于机器级软件中断的中断挂起和中断启用位。<strong>MSIP在mip中是只读的</strong>，通过**访问内存映射的控制寄存器来&#x3D;&#x3D;写入&#x3D;&#x3D;**，远程hart使用这些寄存器来提供机器级的处理器间中断。hart可以使用相同的内存映射控制寄存器写入自己的MSIP位。&#x3D;&#x3D;如果系统只有一个hart，或者平台标准支持通过外部中断(MEI)交付机器级处理器间中断，那么<code>mip.MSIP</code>和<code>mie.MSIE</code>可能都是只读零。&#x3D;&#x3D;</p>
<p>如果不启用supervisor模式，则<code>mip</code>的SEIP、STIP、SSIP位和<code>mie</code>的SEIE、STIE、SSIE位为只读零。</p>
<p>如果采用supervisor模式，则bits <code>mip.SEIP</code>和<code>mie.SEIE</code>是用于Supervisor 外部中断的中断挂起和中断使能位。<br><strong>SEIP在mip中是可写的</strong>，并且可以由M模式软件写入，以向S模式指示外部中断正在等待。此外，平台级中断控制器可以生成Supervisor级外部中断。基于软件可写SEIP位的逻辑&#x3D;&#x3D;或上&#x3D;&#x3D;来自外部中断控制器的信号，supervisor外部中断被设置为挂起。当<strong>用CSR指令读取mip时，在rd目的寄存器中返回的SEIP位的值是软件可写位和中断控制器发出的中断信号的逻辑或，&#x3D;&#x3D;但是来自中断控制器的信号不用于计算写入SEIP的值&#x3D;&#x3D;。只有软件可写的SEIP位参与CSRRS或CSRRC指令的读-修改-写序列。</strong></p>
<blockquote>
<p>例如，如果我们将软件可写的SEIP位命名为B，外部中断控制器的信号命名为E，则如果执行csrrs t0, mip, t1, t0[9]用B || E写入，则B用B || t1[9]写入。如果执行csrrw t0, mip, t1，则将t0[9]写入B || E，将B简单地写入t1[9]。在两种情况下，B都不依赖于E。</p>
<p>SEIP字段行为被设计为允许更高的特权层干净地模拟外部中断，而不会丢失任何真正的外部中断。因此，CSR指令的行为与常规CSR访问略有不同。</p>
</blockquote>
<p>如果采用supervisor模式，则bits <code>mip.STIP</code>和<code>mie.STIE</code>是Supervisor 定时器中断的中断挂起和中断启用位。STIP可以在mip中写入，并且可以由M模式软件编写，以将定时器中断发送到S模式。</p>
<p>如果采用supervisor模式，则bits <code>mip.SSIP</code>和<code>mie.SSIE</code>是Supervisor 软件中断的中断挂起和中断启用位。SSIP在mip中是可写的，也可以由平台特定的中断控制器设置为1。</p>
<p>以M模式为目的地的多个同时中断按以下优先级递减顺序处理:MEI、MSI、MTI、SEI、SSI、STI。</p>
<blockquote>
<p>机器级中断固定优先级排序规则是根据以下原理开发的。</p>
<p>为了支持抢占，高特权模式的中断必须在低特权模式的中断之前处理。</p>
<p>16位及以上的特定于平台的机器级中断源具有特定于平台的优先级，但通常被选择为具有最高的服务优先级以支持非常快的本地矢量中断。</p>
<p>&#x3D;&#x3D;外部中断在内部(定时器&#x2F;软件)中断之前处理&#x3D;&#x3D;，因为外部中断通常由可能需要低中断服务时间(low interrupt service)的设备生成。</p>
<p>&#x3D;&#x3D;软件中断在内部计时器中断之前处理&#x3D;&#x3D;，因为内部计时器中断通常用于时间切片，其中时间精度不太重要，而软件中断用于处理器间消息传递。当需要高精度定时时，可以避免软件中断，或者可以通过不同的中断路径路由高精度定时器中断。软件中断位于mip的最低4位，因为这些通常是由软件编写的，并且这个位置允许使用具有5位立即的单个CSR指令</p>
</blockquote>
<p>mip和mie寄存器的受限视图显示为Supervisor级别的sip和sie寄存器。如果一个中断通过在mideleg寄存器中设置一个位被委托到S模式，那么它将在sip寄存器中可见，并且可以使用sie寄存器进行屏蔽。否则，sip和sie对应的位为只读零。</p>
<h3 id="3-1-10-硬件性能监控-mcycle-and-minstret"><a href="#3-1-10-硬件性能监控-mcycle-and-minstret" class="headerlink" title="3.1.10 硬件性能监控 (mcycle and minstret )"></a>3.1.10 硬件性能监控 (mcycle and minstret )</h3><p>M 模式包括基本的硬件性能监控设施。 mcycle CSR 计算运行 hart 的处理器内核执行的时钟周期数。 minstret CSR 计算 hart 已退出的指令数量。 mcycle 和 minstret 寄存器在所有 RV32 和 RV64 系统上都具有 64 位精度。</p>
<p>计数器寄存器在hart复位后具有任意值，并且可以写入给定值。任何 CSR 写入都会在写入指令完成后生效。 mcycle CSR 可以在同一内核上的 hart 之间共享，在这种情况下，对 mcycle 的写入将对这些 hart 可见。该平台应提供一种机制来指示哪些 hart 共享 mcycle CSR。</p>
<p>硬件性能监视器包括 29 个附加 64 位事件计数器 mhpmcounter3 – mhpmcounter31。事件选择器 CSR（mhpmevent3–mhpmevent31）是 MXLEN 位 WARL 寄存器，用于控制哪个事件导致相应的计数器递增。</p>
<p>这些事件的含义由平台定义，但事件 0 被定义为表示“无事件”。所有计数器都应该被实现，但合法的实现是使计数器及其相应的事件选择器都为只读0。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724105913319-1730798006986-26.png" alt="image-20230724105913319"></p>
<p>mhpmcounters是 WARL 寄存器，在 RV32 和 RV64 上支持高达 64 位精度。</p>
<blockquote>
<p>该规范的未来修订版将定义一种在硬件性能监视器计数器溢出时生成中断的机制</p>
</blockquote>
<p>当 MXLEN&#x3D;32 时，读取 mcycle、minstret 和 mhpmcountern CSR 将返回相应计数器的位 31-0，写入仅更改位 31-0；读取 mcycleh、minstreth 和 mhpmcounternh CSR 返回相应计数器的位 63-32，写入仅更改位 63-32。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724110030556-1730798006986-28.png" alt="image-20230724110030556"></p>
<h3 id="3-1-11-机器计数器使能寄存器（mcounteren）"><a href="#3-1-11-机器计数器使能寄存器（mcounteren）" class="headerlink" title="3.1.11 机器计数器使能寄存器（mcounteren）"></a>3.1.11 机器计数器使能寄存器（mcounteren）</h3><p>计数器使能寄存器 mcounteren 是一个 32 位寄存器，用于控制硬件性能监控计数器对下一个最低特权模式的可用性。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724110058282-1730798006986-27.png" alt="image-20230724110058282"></p>
<p>该寄存器中的设置仅控制可访问性。读取或写入该寄存器的行为不会影响底层计数器，即使无法访问，底层计数器也会继续递增。</p>
<p>当 mcounteren 寄存器中的 CY、TM、IR 或 HPMn 位清零时，在 S 模式或 U 模式下执行时尝试读取周期、时间、instret 或 hpmcountern 寄存器将导致非法指令异常。当其中一个位被设置时，在下一个实现的特权模式（如果实现了 S 模式，否则为 U 模式）中允许访问相应的寄存器。</p>
<blockquote>
<p>计数器使能位以最少的硬件支持两种常见用例。对于不需要高性能定时器和计数器的系统，机器模式软件可以捕获访问并在软件中实现所有功能。对于需要高性能定时器和计数器但不关心底层硬件计数器混淆的系统，计数器可以直接暴露于较低特权模式。</p>
</blockquote>
<p>Cycle、instret 和 hpmcountern CSR 分别是 mcycle、minstret 和 mhpmcountern 的只读影子。时间 CSR 是内存映射 mtime 寄存器的只读影子。类似地，在 RV32I 上，cycleh、instreth 和 hpmcounternh CSR 分别是 mcycleh、minstreth 和 mhpmcounternh 的只读影子。在 RV32I 上，timeh CSR 是内存映射 mtime 寄存器的高 32 位的只读影子，而 time 仅影子 mtime 的低 32 位。</p>
<blockquote>
<p>实现可以将 time 和 timeh CSR 的读取转换为对内存映射 mtime 寄存器的加载，或在 M 模式软件中模拟此功能。</p>
</blockquote>
<p>在U模式的系统中，必须实现mcounteren，但所有字段都是WARL，并且可能是只读零，这表明在低特权模式下执行时，读取相应的计数器将导致非法指令异常。在没有 U 模式的系统中，mcounteren 寄存器不应该存在。</p>
<h3 id="3-1-12-机器计数器禁止-CSR-mcountinhibit"><a href="#3-1-12-机器计数器禁止-CSR-mcountinhibit" class="headerlink" title="3.1.12 机器计数器禁止 CSR (mcountinhibit)"></a>3.1.12 机器计数器禁止 CSR (mcountinhibit)</h3><p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724110205914-1730798006986-29.png" alt="image-20230724110205914"></p>
<p>计数器禁止寄存器 mcountinhibit 是一个 32 位 WARL 寄存器，用于控制哪个硬件性能监控计数器递增。该寄存器中的设置仅控制计数器是否递增；它们的可访问性不受该寄存器设置的影响。</p>
<p>当 mcountinhibit 寄存器中的 CY、IR 或 HPMn 位清零时，cycle、instret 或 hpmcountern 寄存器照常递增。当 CY、IR 或 HPMn 位被置位时，相应的计数器不会递增。</p>
<p>mcycle CSR 可以在同一内核上的 hart 之间共享，在这种情况下，mcountinhibit.CY 字段也在这些 hart 之间共享，因此对 mcountinhibit.CY 的写入对这些 hart 来说是可见的。</p>
<p>如果未实现 mcountinhibit 寄存器，则实现的行为就像将该寄存器设置为零一样。</p>
<blockquote>
<p>当不需要循环和插入计数器时，希望有条件地禁止它们以减少能耗。提供单个 CSR 来禁止所有计数器还允许对计数器进行原子采样。</p>
<p>由于时间计数器可以在多个内核之间共享，因此不能通过 mcountinhibit 机制对其进行抑制。</p>
</blockquote>
<h3 id="3-1-13-机器暂用控制寄存器-mscratch"><a href="#3-1-13-机器暂用控制寄存器-mscratch" class="headerlink" title="3.1.13  机器暂用控制寄存器  (mscratch)"></a>3.1.13  机器暂用控制寄存器  (mscratch)</h3><p>Machine Scratch Register</p>
<p>mscratch寄存器是专用于机器模式使用的mxlen位读&#x2F;写寄存器。通常，它用于<strong>保存指向机器模式hart-local上下文空间的指针，并在进入M模式陷阱处理程序时与用户寄存器交换</strong>。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230607150308306-1730798006986-30.png" alt="image-20230607150308306"></p>
<blockquote>
<p>MIPS ISA分配了两个用户寄存器(k0&#x2F;k1)供OS使用。尽管 MIPS 方案提供了快速且简单的实现，但它也减少了可用的用户寄存器，并且不能扩展到更高的特权级别或嵌套陷阱。它还可以要求在返回到用户级之前清除两个寄存器，以避免潜在的安全漏洞并提供确定的调试行为。</p>
</blockquote>
<blockquote>
<p>RISC-V用户ISA被设计为支持许多可能的特权系统环境，因此我们不想让任何依赖于OS的特性感染用户级ISA。RISCV CSR交换指令可以快速地将值保存&#x2F;恢复到mscratch寄存器。与MIPS设计不同，OS可以依赖于在运行用户上下文时在mscratch寄存器中保存一个值。</p>
</blockquote>
<h3 id="3-1-14-机器异常程序计数器-mepc"><a href="#3-1-14-机器异常程序计数器-mepc" class="headerlink" title="3.1.14 机器异常程序计数器  (mepc)"></a>3.1.14 机器异常程序计数器  (mepc)</h3><p>Machine Exception Program Counter</p>
<p>mepc是一个mxlen位读写寄存器，格式如图3.21所示。mepc的低位位(mepc[0])始终为零。在只支持IALIGN&#x3D;32的实现中，两个低位位(mepc[1:0])总是为零。</p>
<p>如果实现允许IALIGN为16或32(例如，通过更改CSR misa)，那么，每当IALIGN&#x3D;32时，位mepc[1]在读取时被屏蔽，使其看起来为0。这种屏蔽也发生在MRET指令的隐式读取上。虽然被屏蔽，当IALIGN&#x3D;32时，mepc[1]仍然是可写的。</p>
<p>mepc是一个必须能够保存所有有效虚拟地址的WARL寄存器。它不需要能够保存所有可能的无效地址。在编写mepc之前，实现可能会将无效地址转换为mepc能够保存的其他一些无效地址。</p>
<blockquote>
<p>当地址转换不生效时，虚拟地址和物理地址是相等的。</p>
<p>因此，mepc必须能够表示的地址集包括可用作 <em>有效pc</em> 或 <em>有效地址</em> 的物理地址集。</p>
</blockquote>
<p>&#x3D;&#x3D;<strong>当一个陷阱进入M模式时，用被中断或遇到异常的指令的 <font size="5"><code>虚拟地址</code></font> 写入mepc</strong>&#x3D;&#x3D;。否则，mepc永远不会由实现编写，尽管它可能由软件显式编写。</p>
<h3 id="3-1-15-机器原因寄存器-mcause"><a href="#3-1-15-机器原因寄存器-mcause" class="headerlink" title="3.1.15  机器原因寄存器 (mcause)"></a>3.1.15  机器原因寄存器 (mcause)</h3><p>Machine Cause Register </p>
<p>mcause寄存器是一个 MXLEN-bit 读写寄存器，格式如图3.22所示。当一个trap进入M模式时，mcause会被写入一个代码，表示引起该trap的事件。否则，尽管可以由软件显式地编写，mcause 永远不会由实现编写(mcause is never written by the implementation)。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230607144159954-1730798006986-32.png" alt="image-20230607144159954"></p>
<p>如果陷阱是由中断引起的，则cause寄存器中的中断位被设置。异常代码字段包含标识最后一个异常或中断的代码。表3.6列出了可能的机器级异常代码。异常代码是一个WLRL字段，因此只保证保存受支持的异常代码。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230607102401144-1730798006986-31.png" alt="image-20230607102401144"></p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230607102449479-1730798006986-34.png" alt="image-20230607102449479"></p>
<p>​      </p>
<table>
<thead>
<tr>
<th>中断</th>
<th>异常代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>Reserved</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>管理程序软件中断</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>虚拟管理程序软件中断</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>机器软件中断</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>Reserved</td>
</tr>
<tr>
<td>1</td>
<td>5</td>
<td>管理程序定时器中断</td>
</tr>
<tr>
<td>1</td>
<td>6</td>
<td>虚拟管理程序定时器中断</td>
</tr>
<tr>
<td>1</td>
<td>7</td>
<td>机器定时器中断</td>
</tr>
<tr>
<td>1</td>
<td>8</td>
<td>Reserved</td>
</tr>
<tr>
<td>1</td>
<td>9</td>
<td>管理程序外部中断</td>
</tr>
<tr>
<td>1</td>
<td>10</td>
<td>虚拟管理程序外部中断</td>
</tr>
<tr>
<td>1</td>
<td>11</td>
<td>机器外部中断</td>
</tr>
<tr>
<td>1</td>
<td>12</td>
<td>管理程序 guest 外部中断</td>
</tr>
<tr>
<td>1</td>
<td>13-15</td>
<td>Reserved</td>
</tr>
<tr>
<td>1</td>
<td>≥16</td>
<td>指定用于平台或自定义使用</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td><strong>指令地址未对齐</strong></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td><strong>指令访问错误</strong></td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td><strong>非法指令</strong></td>
</tr>
<tr>
<td>0</td>
<td>3</td>
<td><strong>断点</strong></td>
</tr>
<tr>
<td>0</td>
<td>4</td>
<td><strong>加载地址未对齐</strong></td>
</tr>
<tr>
<td>0</td>
<td>5</td>
<td><strong>加载访问错误</strong></td>
</tr>
<tr>
<td>0</td>
<td>6</td>
<td><strong>储存&#x2F;AMO地址未对齐</strong></td>
</tr>
<tr>
<td>0</td>
<td>7</td>
<td><strong>储存&#x2F;AMO访问错误</strong></td>
</tr>
<tr>
<td>0</td>
<td>8</td>
<td><strong>来自U模式或VU模式的环境调用</strong></td>
</tr>
<tr>
<td>0</td>
<td>9</td>
<td><strong>来自HS模式的环境调用</strong></td>
</tr>
<tr>
<td>0</td>
<td>10</td>
<td><strong>来自VS模式的环境调用</strong></td>
</tr>
<tr>
<td>0</td>
<td>11</td>
<td><strong>来自M模式的环境调用</strong></td>
</tr>
<tr>
<td>0</td>
<td>12</td>
<td><strong>指令页面错误</strong></td>
</tr>
<tr>
<td>0</td>
<td>13</td>
<td><strong>加载页面错误</strong></td>
</tr>
<tr>
<td>0</td>
<td>14</td>
<td>Reserved</td>
</tr>
<tr>
<td>0</td>
<td>15</td>
<td><strong>储存&#x2F;AMO页面错误</strong></td>
</tr>
<tr>
<td>0</td>
<td>16-19</td>
<td>Reserved</td>
</tr>
<tr>
<td>0</td>
<td>20</td>
<td><strong>指令 guest-page 错误</strong></td>
</tr>
<tr>
<td>0</td>
<td>21</td>
<td><strong>加载 guest-page 错误</strong></td>
</tr>
<tr>
<td>0</td>
<td>22</td>
<td><strong>虚拟指令</strong></td>
</tr>
<tr>
<td>0</td>
<td>23</td>
<td><strong>储存&#x2F;AMO访客页错误</strong></td>
</tr>
<tr>
<td>0</td>
<td>24-31</td>
<td>指定用于自定义用途</td>
</tr>
<tr>
<td>0</td>
<td>32-47</td>
<td>Reserved</td>
</tr>
<tr>
<td>0</td>
<td>48-63</td>
<td>指定用于自定义用途</td>
</tr>
<tr>
<td>0</td>
<td>≥64</td>
<td>Reserved</td>
</tr>
</tbody></table>
<p>注意，load和load-reserved指令生成load异常，而store、store conditional和AMO指令生成store&#x2F;AMO异常。</p>
<blockquote>
<p>可以判断cause寄存器的符号位（最高位）将中断与其他陷阱分开。左移可以移除中断位并缩放异常代码以索引到陷阱向量表中。</p>
</blockquote>
<blockquote>
<p>我们不区分特权指令异常和非法操作码异常。这简化了体系结构，还隐藏了实现支持哪些更高权限指令的细节。服务于陷阱的特权级别可以实现一个策略，来决定是否需要区分这些操作码，如果需要区分，则应该将给定的操作码视为非法操作码还是特权操作码。</p>
</blockquote>
<p>如果一条指令可能引发多个同步异常，表3.7中优先级递减的顺序指示了哪个异常被获取并在mcause中报告。任何自定义同步异常的优先级是由实现定义的。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230607144256709-1730798006986-33.png" alt="image-20230607144256709"></p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20240827100909450-1730798006986-36.png" alt="image-20240827100909450"></p>
<p>当虚拟地址转换为物理地址时，地址转换算法决定可能引发哪些特定的异常。</p>
<p>Load&#x2F;store&#x2F;AMO 地址不对齐(address-misaligned)异常的优先级可能高于或低于Load&#x2F;store&#x2F;AMO 页面错误(page-fault a)和访问错误(page-fault )异常。</p>
<blockquote>
<p>Load&#x2F;store&#x2F;AMO 地址不对齐和页面错误异常的相对优先级是具体实现定义的，以灵活地满足两个设计要点。从不支持不对齐访问的实现可以无条件地引发不对齐地址异常，而不执行地址转换或保护检查。只支持对某些物理地址进行不对齐访问的实现必须在确定是否可以继续进行不对齐访问之前转换和检查地址，在这种情况下引发页错误异常或访问更合适。</p>
</blockquote>
<blockquote>
<p>指令地址断点与数据地址断点(又称观察点)和环境中断异常(由EBREAK指令引发)具有相同的原因值，但优先级不同。</p>
</blockquote>
<blockquote>
<p>指令地址不对齐异常是由目标不对齐的控制流指令引发的，而不是由获取指令的行为引发的。因此，这些异常的优先级低于其他指令地址异常。</p>
</blockquote>
<h3 id="3-1-16-机器陷阱值寄存器-mtval"><a href="#3-1-16-机器陷阱值寄存器-mtval" class="headerlink" title="3.1.16 机器陷阱值寄存器  (mtval)"></a>3.1.16 机器陷阱值寄存器  (mtval)</h3><p>Machine Trap Value Register</p>
<p>mtval寄存器是一个mxlen位读写寄存器，格式如图3.23所示。当一个陷阱进入M模式时，mtval要么设置为零，要么写入异常特定的信息，以帮助软件处理陷阱。否则，mtval永远不会由实现编写，尽管它可能由软件显式编写。硬件平台将指定哪些异常必须以信息方式设置mtval，哪些异常可以无条件地将其设置为零。如果硬件平台指定没有异常将mtval设置为非零值，则mtval为只读零。</p>
<p>如果在指令获取、加载或存储中发生断点、地址不对齐、访问错误或页面错误异常时，使用非零值写入mtval，则&#x3D;&#x3D;<strong>mtval将包含发生故障的虚拟地址</strong>&#x3D;&#x3D;。</p>
<blockquote>
<p>当启用基于页面的虚拟内存时，即使对于物理内存访问错误异常，也会使用故障虚拟地址写入mtval。这种设计降低了大多数实现的数据路径成本，特别是那些带有&#x3D;&#x3D;<strong>hardware page-table walkers</strong>&#x3D;&#x3D;的实现。</p>
</blockquote>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230607135602251-1730798006986-35.png" alt="image-20230607135602251"></p>
<p>如果在不对齐的加载或存储导致访问错误或页面错误异常时，使用非零值写入mtval，则mtval将包含导致错误的访问部分的虚拟地址。</p>
<p>如果在具有变长指令的系统上发生指令访问错误或页面错误异常时，使用非零值写入mtval，则mtval将包含导致错误的指令部分的虚拟地址，而mepc将指向该指令的开始。</p>
<p>还可以选择使用mtval寄存器在非法指令异常时返回错误指令位(mepc指向内存中的错误指令)。如果在发生非法指令异常时使用非零值写入mtval，则mtval将包含最短的值:</p>
<ul>
<li>实际故障指令</li>
<li>故障指令的第一个ILEN位</li>
<li>故障指令的第一个MXLEN位</li>
</ul>
<p>在非法指令异常时加载到mtval中的值是右对齐的，所有未使用的上位被清除为零。</p>
<blockquote>
<p>在mtval中捕获错误指令减少了指令模拟的开销，如果指令不对齐，可能会避免几个部分指令加载，并且当使用加载将指令获取到数据寄存器中时，可能会出现数据缓存丢失或缓慢的非缓存访问。如果另一个代理正在操纵指令存储器，就像在动态翻译系统中可能发生的那样，还存在原子性问题。</p>
<p>一个要求是整个指令(或者至少是第一个MXLEN位)在捕获陷阱之前被提取到mtval中。这不应该约束实现，因为实现通常会在尝试解码指令之前获取整个指令，并避免使软件处理程序复杂化。</p>
<p>如果mtval中的值为零，则表示不支持该特性，或者获取了非法的零指令。可以使用mepc指向的指令内存中的负载来区分这两种情况(或者，可以查询系统配置信息，以便在运行时之前安装适当的陷阱处理)。</p>
</blockquote>
<p>如果mtval中的值为零，则表示不支持该特性，或者获取了非法的零指令。可以使用mepc指向的指令内存中的负载来区分这两种情况(或者，可以查询系统配置信息，以便在运行时之前安装适当的陷阱处理)。</p>
<p>如果mtval不是只读0，则它是一个WARL寄存器，必须能够保存所有有效的虚拟地址和值0。它不需要能够保存所有可能的无效地址。在写入mtval之前，实现可能会将无效地址转换为mtval能够保存的其他无效地址。如果实现了返回故障指令位的特性，则mtval还必须能够保存小于2^N^的所有值，其中N为MXLEN和ILEN中较小的一个。</p>
<h3 id="3-1-17-机器配置指针寄存器（mconfigptr）"><a href="#3-1-17-机器配置指针寄存器（mconfigptr）" class="headerlink" title="3.1.17 机器配置指针寄存器（mconfigptr）"></a>3.1.17 机器配置指针寄存器（mconfigptr）</h3><p>mconfigptr 是一个 MXLEN 位只读 CSR，其格式如图 3.24 所示，它保存配置数据结构的物理地址。软件可以遍历这个数据结构来发现有关硬件、平台及其配置的信息。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724110523238-1730798006986-37.png" alt="image-20230724110523238"></p>
<p>以位为单位的指针对齐方式必须不小于支持的最大 MXLEN：即，如果支持的最大 MXLEN 为 8 × n，则 mconfigptr[log<del>2</del>n -1:0] 必须为零。</p>
<p>mconfigptr 必须实现，但它可能为零，表示配置数据结构不存在，或者必须使用替代机制来定位它。</p>
<blockquote>
<p>配置数据结构的格式和模式尚未标准化。</p>
</blockquote>
<blockquote>
<p>虽然 mconfigptr 在某些实现中只是硬连线，但其他实现可能提供一种方法来配置 CSR 读取时返回的值。例如，mconfigptr 可能会显示由平台或 M 模式软件在启动过程开始时编程的内存映射寄存器的值。</p>
</blockquote>
<h3 id="3-1-18-机器环境配置寄存器（menvcfg-和-menvcfgh）"><a href="#3-1-18-机器环境配置寄存器（menvcfg-和-menvcfgh）" class="headerlink" title="3.1.18 机器环境配置寄存器（menvcfg 和 menvcfgh）"></a>3.1.18 机器环境配置寄存器（menvcfg 和 menvcfgh）</h3><p>menvcfg CSR 是一个 MXLEN 位读&#x2F;写寄存器，格式为 MXLEN&#x3D;64，如图 3.25 所示，它控制特权低于 M 的模式的执行环境的某些特征。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724111119669-1730798006986-38.png" alt="image-20230724111119669"></p>
<p>如果 FIOM 位（I&#x2F;O 栅栏意味着内存）在 menvcfg 中设置为 1，则修改以低于 M 的特权模式执行的 FENCE 指令，因此对设备 I&#x2F;O 访问进行排序的要求也意味着对主存储器访问进行排序的要求。表 3.8 详细介绍了当 FIOM&#x3D;1 时特权低于 M 的模式下 FENCE 指令位 PI、PO、SI 和 SO 的修改解释。</p>
<p>类似地，对于特权低于 M 的模式，当 FIOM&#x3D;1 时，如果访问按设备 I&#x2F;O 排序的区域的原子指令设置了其 aq 和&#x2F;或 rl 位，则该指令的排序就像它访问设备 I&#x2F;O 和内存一样。</p>
<p>如果不支持 S 模式，或者 satp.MODE 为只读零（始终为 Bare），则实现可能会使 FIOM 为只读零。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724111155038-1730798006986-39.png" alt="image-20230724111155038"></p>
<blockquote>
<p>menvcfg 中需要 FIOM 位，因此 M 模式可以模拟第 8 章的Hypervisor扩展，该扩展在Hypervisor CSR henvcfg 中具有等效的 FIOM 位。</p>
</blockquote>
<p>PBMTE 位控制 Svpbmt 扩展是否可用于 S 模式和G-stage 地址转换（即，用于 satp 或 hgatp 指向的页表）。当PBMTE&#x3D;1时，Svpbmt可用于S模式和G阶段地址转换。当 PBMTE&#x3D;0 时，实现的行为就像未实现 Svpbmt 一样。如果未实现 Svpbmt，则 PBMTE 只读为零。此外，对于具有Supervisor扩展的实现，如果 menvcfg.PBMTE 为零，则 heenvcfg.PBMTE 为只读零。</p>
<p>STCE 字段的定义将由即将推出的 Sstc 扩展提供。在批准该延期之前，它在 menvcfg 中的分配可能会发生变化。</p>
<p>CBZE 字段的定义将由即将推出的 Zicboz 扩展提供。在批准该延期之前，它在 menvcfg 中的分配可能会发生变化。</p>
<p>CBCFE 和 CBIE 字段的定义将由即将推出的 Zicbom 扩展提供。在批准该延期之前，它们在 menvcfg 中的分配可能会发生变化。</p>
<p>当 MXLEN&#x3D;32 时，menvcfg 包含与 MXLEN&#x3D;64 时 menvcfg 的位 31:0 相同的字段。</p>
<p>此外，当 MXLEN&#x3D;32 时，menvcfgh 是一个 32 位读&#x2F;写寄存器，包含与 MXLEN&#x3D;64 时 menvcfg 的位 63:32 相同的字段。当 MXLEN&#x3D;64 时，寄存器 menvcfgh 不存在。</p>
<p>如果不支持 U 模式，则寄存器 menvcfg 和 menvcfgh 不存在。</p>
<h3 id="3-1-19-机器安全配置寄存器（mseccfg）"><a href="#3-1-19-机器安全配置寄存器（mseccfg）" class="headerlink" title="3.1.19 机器安全配置寄存器（mseccfg）"></a>3.1.19 机器安全配置寄存器（mseccfg）</h3><p>mseccfg 是一个可选的 MXLEN 位读&#x2F;写寄存器，其格式如图 3.26 所示，用于控制安全功能。</p>
<p>仅当 MXLEN&#x3D;32 时，mseccfgh 是一个 32 位读&#x2F;写寄存器，包含与 MXLEN&#x3D;64 时 mseccfg 位 63:32 相同的字段。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724111239448-1730798006987-41.png" alt="image-20230724111239448"></p>
<p>SSEED 和 USEED 字段的定义将由即将推出的熵源扩展 Zkr 提供。在批准该延期之前，它们在 mseccfg 中的分配可能会发生变化。</p>
<p>RLB、MMWP 和 MML 字段的定义将由即将推出的 PMPenhancement 扩展 Smepmp 提供。在批准该延期之前，它们在 mseccfg 中的分配可能会发生变化。</p>
<h2 id="3-2-机器级内存映射寄存器"><a href="#3-2-机器级内存映射寄存器" class="headerlink" title="3.2 机器级内存映射寄存器"></a>3.2 机器级内存映射寄存器</h2><h3 id="3-2-1-机器定时器寄存器（mtime-和-mtimecmp）"><a href="#3-2-1-机器定时器寄存器（mtime-和-mtimecmp）" class="headerlink" title="3.2.1 机器定时器寄存器（mtime 和 mtimecmp）"></a>3.2.1 机器定时器寄存器（mtime 和 mtimecmp）</h3><p>平台提供实时计数器，作为内存映射机器模式读写寄存器 mtime 公开。 mtime 必须以恒定频率递增，并且平台必须提供一种机制来确定 mtime 滴答周期。如果计数溢出，mtime 寄存器将回绕。</p>
<p>mtime 寄存器在所有 RV32 和 RV64 系统上都具有 64 位精度。平台提供 64 位内存映射机器模式定时器比较寄存器 (mtimecmp)。每当 mtime 包含大于或等于 mtimecmp 的值时，机器计时器中断就会处于挂起状态，并将这些值视为无符号整数。中断将保持发布状态，直到 mtimecmp 变得大于 mtime（通常是写入 mtimecmp 的结果）。仅当中断使能且 mie 寄存器中的 MTIE 位被置位时，才会产生中断。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724112537554-1730798006986-40.png" alt="image-20230724112537554"></p>
<blockquote>
<p>定时器设施被定义为使用挂钟时间而不是周期计数器来支持以高度可变的时钟频率运行的现代处理器，以通过动态电压和频率缩放来节省能源。</p>
<p>提供精确的实时时钟 (RTC) 的成本相对较高（需要晶体或 MEMS 振荡器），并且即使在系统其余部分断电时也必须运行，因此系统中通常只有一个时钟位于与处理器不同的频率&#x2F;电压域中。因此，RTC 必须由系统中的所有硬件共享，并且对 RTC 的访问可能会导致电压电平转换器和时钟域交叉的损失。因此，将 mtime 公开为内存映射寄存器比公开为 CSR 更为自然。</p>
<p>较低权限级别没有自己的 timecmp 寄存器。相反，机器模式软件可以通过将下一个定时器中断复用到 mtimecmp 寄存器来在 hart 上实现任意数量的虚拟定时器。</p>
<p>简单的固定频率系统可以使用单个时钟进行周期计数和挂钟时间。</p>
</blockquote>
<p>对 mtime 和 mtimecmp 的写入保证最终会反映在 MTIP 中，但不一定立即反映。</p>
<blockquote>
<p>如果中断处理程序递增 mtimecmp 然后立即返回，则可能会发生虚假定时器中断，因为在此期间 MTIP 可能尚未下降。所有软件都应假设该事件是可能的，但大多数软件应假设该事件极不可能发生。引起偶尔的虚假定时器中断几乎总是比轮询 MTIP 直到它下降的性能更高。</p>
</blockquote>
<p>在 RV32 中，对 mtimecmp 的内存映射写入仅修改寄存器的一个 32 位部分。以下代码序列设置 64 位 mtimecmp 值，而不会由于比较数的中间值而虚假生成定时器中断：</p>
<p>对于 RV64，还支持对 mtime 和 mtimecmp 寄存器的自然对齐 64 位内存访问，并且这些访问是原子的。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724112643225-1730798006987-42.png" alt="image-20230724112643225"></p>
<p>图 3.29：在 RV32 中设置 64 位时间比较数的示例代码，假设采用小端存储系统并且寄存器位于强有序 I&#x2F;O 区域中。将 -1 存储到 mtimecmp 的低位可以防止 mtimecmp 暂时变得小于旧值和新值中的较小者。</p>
<h2 id="3-3-机器模式特权指令"><a href="#3-3-机器模式特权指令" class="headerlink" title="3.3 机器模式特权指令"></a>3.3 机器模式特权指令</h2><h3 id="3-3-1-环境调用和断点"><a href="#3-3-1-环境调用和断点" class="headerlink" title="3.3.1 环境调用和断点"></a>3.3.1 环境调用和断点</h3><p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724114215950-1730798006987-43.png" alt="image-20230724114215950"></p>
<p>ECALL指令用于向支持执行环境发出请求。当在 U 模式、S 模式或 M 模式下执行时，会分别生成 U 模式环境调用异常、S 模式环境调用异常或 M 模式环境调用异常，并且不执行其他操作。</p>
<blockquote>
<p>ECALL 为每个发起特权模式生成不同的异常，以便可以有选择地委派环境调用异常。类 Unix 操作系统的典型用例是将来自 U 模式的环境调用异常委托给 S 模式，但不委托其他异常。</p>
</blockquote>
<p>调试器使用 EBREAK 指令将控制权转移回调试环境。它会生成断点异常并且不执行其他操作。</p>
<blockquote>
<p>如本手册第一卷压缩指令的“C”标准扩展中所述，C.EBREAK 指令执行与 EBREAK 指令相同的操作。</p>
</blockquote>
<p>ECALL 和 EBREAK 导致接收特权模式的 epc 寄存器被设置为 ECALL 或 EBREAK 指令本身的地址，而不是后续指令的地址。由于 ECALL 和 EBREAK 会导致同步异常，因此它们不会被视为退出，并且不应增加 minstret CSR。</p>
<h3 id="3-3-2-陷阱返回指令"><a href="#3-3-2-陷阱返回指令" class="headerlink" title="3.3.2 陷阱返回指令"></a>3.3.2 陷阱返回指令</h3><p>从陷阱返回的指令在 PRIV 次要操作码下编码</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724114320849-1730798006987-44.png" alt="image-20230724114320849"></p>
<p>为了在处理陷阱后返回，每个特权级别都有单独的陷阱返回指令：MRET 和 SRET。</p>
<ul>
<li>MRET始终实现。</li>
<li>如果支持管理模式，则必须提供 SRET，否则应引发非法指令异常。</li>
<li>当 mstatus 中 TSR&#x3D;1 时，SRET 还应引发非法指令异常，如第 3.1.6.5 节所述。</li>
</ul>
<p> xRET 指令可以在特权模式 x 或更高模式下执行，其中执行较低特权的 xRET 指令将弹出相关的较低特权中断使能和特权模式堆栈。除了如第 3.1.6.1 节中所述操作特权堆栈之外，<strong>xRET 将 pc 设置为存储在 xepc 寄存器中的值</strong>。</p>
<p>如果支持 A 扩展，则允许 xRET 指令清除任何未完成的 LR 地址保留，但不是必需的。如果需要，陷阱处理程序应在执行 xRET 之前显式清除预留(reservation)（例如，通过使用虚拟 SC）。</p>
<blockquote>
<p>如果 xRET 指令始终清除 LR 保留，则不可能使用调试器单步执行 LR&#x2F;SC 序列。</p>
</blockquote>
<h3 id="3-3-3-等待中断"><a href="#3-3-3-等待中断" class="headerlink" title="3.3.3 等待中断"></a>3.3.3 等待中断</h3><p>等待中断指令 (WFI) 向实现提供了一个提示，即当前的 hart 可以停止，直到中断可能需要服务。 WFI 指令的执行还可用于通知硬件平台应优先将合适的中断路由到该硬件。 WFI 在所有特权模式下可用，并且可以选择在 U 模式下使用。</p>
<p>当 mstatus 中 TW&#x3D;1 时，该指令可能引发非法指令异常，如第 3.1.6.5 节所述。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724114425454-1730798006987-45.png" alt="image-20230724114425454"></p>
<p>如果在 hart 停止时存在或稍后出现启用的中断，则将在以下指令上进行中断陷阱，即，在陷阱处理程序中恢复执行，并且 mepc &#x3D; pc + 4。</p>
<blockquote>
<p>以下指令采用中断陷阱，以便从陷阱处理程序简单返回将执行 WFI 指令之后的代码。</p>
</blockquote>
<p>WFI指令的目的是为实现提供提示，因此合法的实现是将WFI简单地实现为NOP。</p>
<blockquote>
<p>如果实现在执行指令时没有停止 hart，则将对包含 WFI 的空闲循环中的某些指令进行中断，并且在从处理程序简单返回时，空闲循环将恢复执行。</p>
</blockquote>
<p>当中断被禁用时，WFI 指令也可以被执行。 WFI 的操作必须不受 mstatus（MIE 和 SIE）中的全局中断位和委托寄存器 mideleg 的影响（即，如果本地使能的中断变为挂起，则 hart 必须恢复，即使它已被委托到低特权模式），但应尊重各个中断使能（例如 MTIE）（即，如果中断挂起但未单独启用，实现应避免恢复 hart）。 WFI 还需要恢复在任何特权级别挂起的本地使能中断的执行，无论每个特权级别的全局中断使能如何。</p>
<p>如果导致 hart 恢复执行的事件不会导致采取中断，则执行将在 pc + 4 处恢复，并且软件必须确定要采取的操作，包括在没有可操作事件的情况下循环返回以重复 WFI。</p>
<blockquote>
<p>通过允许在中断被禁用时唤醒，可以调用中断处理程序的备用入口点，该入口点不需要保存当前上下文，因为可以在执行 WFI 之前保存或丢弃当前上下文。</p>
<p>由于实现可以自由地将 WFI 实现为 NOP，因此软件必须显式检查 WFI 后面的代码中是否有任何相关的待处理但已禁用的中断，并且如果未检测到合适的中断，则应循环回 WFI。可以询问 mip 或 sip 寄存器以确定分别在机器或管理模式下是否存在任何中断。</p>
<p>WFI 的操作不受委托寄存器设置的影响。</p>
<p>WFI 的定义是为了使实现可以陷入更高特权模式，例如，在遇到 WFI 时立即或在一段时间间隔后启动机器模式转换到较低功耗状态。</p>
</blockquote>
<blockquote>
<p>相同的“等待事件”模板可用于等待内存位置更改或消息到达的未来可能的扩展。</p>
</blockquote>
<h3 id="3-3-4-自定义系统指令"><a href="#3-3-4-自定义系统指令" class="headerlink" title="3.3.4 自定义系统指令"></a>3.3.4 自定义系统指令</h3><p>图 3.30 所示的 SYSTEM 主操作码的子空间被指定供自定义使用。建议这些指令使用位 29:28 来指定所需的最低特权模式，就像其他 SYSTEM 指令一样。</p>
<h2 id="3-4-复位"><a href="#3-4-复位" class="headerlink" title="3.4 复位"></a>3.4 复位</h2><p>复位后，hart 的特权模式设置为 M。mstatus 字段 MIE 和 MPRV 复位为 0。如果支持小端存储器访问，则 mstatus&#x2F;mstatush 字段 MBE 重置为 0。misa 寄存器重置以启用支持的扩展的最大集和最宽的 MXLEN，如第 3.1.1 节中所述。对于“A”标准扩展的实现，没有有效的负载预留。 pc 设置为实现定义的复位向量。 mcause 寄存器被设置为指示复位原因的值。可写 PMP 寄存器的 A 和 L 字段设置为 0，除非平台要求某些 PMP 寄存器的 A 和 L 字段使用不同的复位值。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724134008936-1730798006987-46.png" alt="image-20230724134008936"></p>
<p>如果Hypervisor扩展已实现，hgatp.MODE 和 vsatp.MODE 字段重置为 0。没有 WARL 字段包含非法值。所有其他状态均未指定。</p>
<p>重置后的 mcause 值具有特定于实现的解释，但在不区分不同重置条件的实现上应返回值 0。区分不同复位条件的实现应该仅使用 0 来指示最完整的复位。</p>
<blockquote>
<p>一些设计可能有多种复位原因（例如，上电复位、外部硬复位、检测到欠压、看门狗定时器失效、睡眠模式唤醒），机器模式软件和调试器可能希望区分这些原因。</p>
<p>mcause 重置值可能会在同步异常之后成为 mcause 值的别名。这种重叠应该没有歧义，因为在重置时，pc通常设置为与其他陷阱不同的值。</p>
</blockquote>
<h2 id="3-5-不可屏蔽中断"><a href="#3-5-不可屏蔽中断" class="headerlink" title="3.5 不可屏蔽中断"></a>3.5 不可屏蔽中断</h2><p>不可屏蔽中断 (NMI) 仅用于硬件错误情况，并导致立即跳转到在 M 模式下运行的实现定义的 NMI 向量，无论 hart 的中断使能位的状态如何。 mepc 寄存器写入被中断指令的虚拟地址，并且 mcause 设置为指示 NMI 源的值。因此，NMI 可以覆盖活动机器模式中断处理程序中的状态。</p>
<p>NMI 写入 mcause 的值是实现定义的。应设置 mcause 的高中断位以指示这是一个中断。异常代码 0 被保留表示“未知原因”，并且不通过 mcause 寄存器区分 NMI 源的实现应在异常代码中返回 0。</p>
<p>与重置不同，NMI 不会重置处理器状态，从而能够诊断、报告并可能遏制硬件错误。</p>
<h2 id="3-6-物理内存属性"><a href="#3-6-物理内存属性" class="headerlink" title="3.6 物理内存属性"></a>3.6 物理内存属性</h2><p>完整系统的物理内存映射包括各种地址范围，一些对应于内存区域，一些对应于内存映射的控制寄存器，还有一些对应于地址空间中的空洞。某些内存区域可能不支持读取、写入或执行；有些可能不支持子字(subword)或子块(subblock)访问；有些可能不支持原子操作；有些可能不支持缓存一致性或可能具有不同的内存模型。同样，内存映射控制寄存器在支持的访问宽度、对原子操作的支持以及读写访问是否具有相关副作用方面有所不同。</p>
<p>在 RISC-V 系统中，机器物理地址空间每个区域的这些属性和功能称为物理内存属性 （physical memory attributes）(PMA)。本节介绍 RISC-V PMA 术语以及 RISC-V 系统如何实现和检查 PMA。</p>
<p>PMA 是底层硬件的固有属性，在系统运行期间很少发生变化。与第 3.7 节中描述的物理内存保护值不同，PMA 不随执行上下文而变化。某些存储区域的 PMA 在芯片设计时就已确定——例如片上 ROM。其他的在电路板设计时是固定的，例如取决于哪些其他芯片连接到片外总线。片外总线还可能支持可以在每个电源周期（冷插拔）或在系统运行时动态更改（热插拔）的设备。某些设备可能在运行时进行配置，以支持意味着不同 PMA 的不同用途，例如，片上暂存器 RAM 可能由一个终端应用程序中的一个核心私有缓存，或者在另一终端应用程序中作为共享的非缓存内存进行访问。</p>
<p>大多数系统将要求在知道物理地址后，稍后在执行流水线的硬件中动态检查至少一些 PMA，因为并非所有物理内存地址都支持某些操作，并且某些操作需要了解可配置 PMA 属性的当前设置。虽然许多其他架构在虚拟内存页表中指定一些 PMA 并使用 TLB 通知流水线这些属性，但这种方法将特定于平台的信息注入虚拟化层，并且可能导致系统错误，除非在每个物理内存区域的每个页表条目中正确初始化其属性。此外，可用的页面大小对于指定物理内存空间中的属性可能不是最佳的，从而导致地址空间碎片和昂贵的 TLB 条目的低效使用。</p>
<p>对于 RISC-V，我们将 PMA 的规范和检查分离到一个单独的硬件结构中，即 PMA 检查器。在许多情况下，每个物理地址区域的属性在系统设计时就已知，并且可以硬连线到 PMA 检查器中。在属性是运行时可配置的情况下，可以提供特定于平台的存储器映射控制寄存器，以适合平台上每个区域的粒度指定这些属性（例如，对于可以在可缓存和不可缓存用途之间灵活划分的片上SRAM）。检查 PMA 是否有对物理内存的任何访问，包括经过虚拟内存到物理内存转换的访问。为了帮助系统调试，我们强烈建议在可能的情况下，RISCV 处理器精确捕获未通过 PMA 检查的物理内存访问。精确捕获的 PMA 违规表现为指令、加载或存储访问错误异常，与虚拟内存页面错误异常不同。精确的 PMA 陷阱可能并不总是可行，例如，在探测使用访问故障作为发现机制一部分的传统总线架构时。在这种情况下，来自从设备的错误响应将被报告为不精确的总线错误中断。</p>
<p>PMA 还必须可被软件读取，才能正确访问某些设备或正确配置访问内存的其他硬件组件，例如 DMA 引擎。由于 PMA 与给定物理平台的组织紧密相关，因此许多细节本质上是特定于平台的，软件可以了解平台的 PMA 值的方法也是如此。某些设备（尤其是传统总线）不支持 PMA 发现，因此如果尝试进行不受支持的访问，则会给出错误响应或超时。通常，特定于平台的机器模式代码将提取 PMA 并最终使用某种标准表示形式将此信息呈现给更高级别的特权较低的软件。</p>
<p>当平台支持 PMA 动态重新配置时，将提供一个接口，通过将请求传递到可以正确重新配置平台的机器模式驱动程序来设置属性。例如，在某些内存区域上切换可缓存性属性可能涉及特定于平台的操作，例如缓存刷新，这些操作仅适用于机器模式。</p>
<h3 id="3-6-1-主内存与-I-O-与空闲区域"><a href="#3-6-1-主内存与-I-O-与空闲区域" class="headerlink" title="3.6.1 主内存与 I&#x2F;O 与空闲区域"></a>3.6.1 主内存与 I&#x2F;O 与空闲区域</h3><p>给定内存地址范围最重要的特征是它是否拥有常规主内存或 I&#x2F;O 设备，或者是否为空。常规主存储器需要具有许多属性，如下所述，而 I&#x2F;O 设备可以具有更广泛的属性。不适合常规主内存的内存区域（例如设备暂存器 RAM）被归类为 I&#x2F;O 区域。空区域也被分类为 I&#x2F;O 区域，但具有指定不支持访问的属性。</p>
<h3 id="3-6-2-支持的访问类型-PMA"><a href="#3-6-2-支持的访问类型-PMA" class="headerlink" title="3.6.2 支持的访问类型 PMA"></a>3.6.2 支持的访问类型 PMA</h3><p>访问类型指定支持哪些访问宽度（从 8 位字节到长多字突发），以及每个访问宽度是否支持未对齐访问</p>
<blockquote>
<p>尽管在 RISC-V 硬件上运行的软件无法直接生成内存突发，但软件可能必须对 DMA 引擎进行编程才能访问 I&#x2F;O 设备，因此可能需要知道支持哪些访问大小。</p>
</blockquote>
<p>主内存区域始终支持所连接设备所需的所有访问宽度的读写，并且可以指定是否支持取指令。</p>
<blockquote>
<p>某些平台可能要求所有主存都支持指令读取。其他平台可能禁止从某些主内存区域获取指令。</p>
</blockquote>
<blockquote>
<p>在某些情况下，访问主存储器的处理器或设备的设计可能支持其他宽度，但必须能够与主存储器支持的类型一起工作。</p>
</blockquote>
<p>I&#x2F;O 区域可以指定支持哪些数据宽度的读、写或执行访问组合。</p>
<p>对于具有基于页面的虚拟内存的系统，I&#x2F;O 和内存区域可以指定支持硬件页表读取和硬件页表写入的组合。</p>
<blockquote>
<p>类 Unix 操作系统通常要求所有可缓存主内存都支持页表遍历。</p>
</blockquote>
<h3 id="3-6-3-原子性PMA"><a href="#3-6-3-原子性PMA" class="headerlink" title="3.6.3 原子性PMA"></a>3.6.3 原子性PMA</h3><p>原子性 PMA 描述了该地址区域支持哪些原子指令。对原子指令的支持分为两类：LR&#x2F;SC 和 AMO。</p>
<blockquote>
<p>某些平台可能要求所有可缓存主内存支持所连接处理器所需的所有原子操作。</p>
</blockquote>
<h4 id="3-6-3-1-AMO-PMA"><a href="#3-6-3-1-AMO-PMA" class="headerlink" title="3.6.3.1 AMO PMA"></a>3.6.3.1 AMO PMA</h4><p>AMO 内有四个级别的支持：AMONone、AMOSwap、AMOLogical 和 AMOArithmetic。</p>
<ul>
<li>AMONone 表示不支持任何 AMO 操作。 </li>
<li>AMOSwap 表示该地址范围仅支持amoswap 指令。</li>
<li>AMOLogical 表示支持交换指令以及所有逻辑 AMO（amoand、amoor、amoxor）。</li>
<li>AMOArithmetic 表示支持所有 RISC-V AMO。对于每个支持级别，如果底层内存区域支持给定宽度的读取和写入，则支持该宽度的自然对齐 AMO。</li>
</ul>
<p>主存储器和 I&#x2F;O 区域可能仅支持处理器支持的原子操作的子集或不支持。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724140045917-1730798006987-47.png" alt="image-20230724140045917"></p>
<blockquote>
<p>我们建议在可能的情况下至少为 I&#x2F;O 区域提供 AMOLogical 支持。</p>
</blockquote>
<h4 id="3-6-3-2-可预订性-PMA"><a href="#3-6-3-2-可预订性-PMA" class="headerlink" title="3.6.3.2 可预订性 PMA"></a>3.6.3.2 可预订性 PMA</h4><p>对于 LR&#x2F;SC，存在三个支持级别，指示可预订性和偶发性属性的组合：RsrvNone、RsrvNonEventual 和 RsrvEventual。 </p>
<ul>
<li>RsrvNone表示不支持LR&#x2F;SC操作（位置不可预留）。 </li>
<li>RsrvNonEventual 表示支持操作（位置可保留），但没有非特权 ISA 规范中描述的最终成功保证。 </li>
<li>RsrvEventual 表示支持该操作并提供最终成功保证。</li>
</ul>
<blockquote>
<p>我们建议尽可能为主内存区域提供 RsrvEventual 支持。大多数 I&#x2F;O 区域不支持 LR&#x2F;SC 访问，因为这些访问最方便地构建在缓存一致性方案之上，但有些区域可能支持 RsrvNonEventual 或 RsrvEventual。</p>
</blockquote>
<blockquote>
<p>当 LR&#x2F;SC 用于标记为 RsrvNonEventual 的内存位置时，软件应提供在检测到缺乏进度时使用的替代后备机制。</p>
</blockquote>
<h4 id="3-6-3-3-对齐"><a href="#3-6-3-3-对齐" class="headerlink" title="3.6.3.3 对齐"></a>3.6.3.3 对齐</h4><p>对于某些地址和访问宽度，支持对齐 LR&#x2F;SC 或对齐 AMO 的内存区域也可能支持未对齐 LR&#x2F;SC 或未对齐 AMO。如果对于给定的地址和访问宽度，未对齐的 LR&#x2F;SC 或 AMO 生成地址未对齐异常，则使用该地址和访问宽度的所有加载、存储、LR&#x2F;SC 和 AMO 都必须生成地址未对齐异常。</p>
<blockquote>
<p>标准“A”扩展不支持未对齐的 AMO 或 LR&#x2F;SC 对。标准“Zam”扩展提供了对未对齐 AMO 的支持。目前对未对齐 LR&#x2F;SC 序列的支持尚未标准化，因此对未对齐地址的 LR 和 SC 必须引发异常。</p>
<p>强制未对齐的加载和存储在未对齐的 AMO 引发地址未对齐的异常时引发地址未对齐的异常，从而允许在 M 模式陷阱处理程序中模拟未对齐的 AMO。处理程序通过获取全局互斥体并模拟关键部分内的访问来保证原子性。假设未对齐加载和存储的处理程序使用相同的互斥体，则对使用相同字大小的给定地址的所有访问都将是相互原子的。</p>
</blockquote>
<p>对于某些未对齐的访问，实现可能会引发访问错误异常，而不是地址未对齐异常，这表明该指令不应由陷阱处理程序模拟。如果对于给定的地址和访问宽度，所有未对齐的 LR&#x2F;SC 和 AMO 都生成访问错误异常，则不需要原子执行使用相同地址和访问宽度的常规未对齐加载和存储。</p>
<h3 id="3-6-4-内存排序-PMA"><a href="#3-6-4-内存排序-PMA" class="headerlink" title="3.6.4 内存排序 PMA"></a>3.6.4 内存排序 PMA</h3><p>为了通过 FENCE 指令和原子指令排序位进行排序，地址空间的区域被分类为主存储器或 I&#x2F;O。</p>
<p>一个 hart 对主存储器区域的访问不仅可以被其他 hart 观察到，也可以被其他能够在主存储器系统中发起请求的设备（例如 DMA 引擎）观察到。一致的主内存区域始终具有 RVWMO 或 RVTSO 内存模型。不连贯的主内存区域具有实现定义的内存模型。</p>
<p>一个hart对I&#x2F;O区域的访问不仅可以被其他hart和总线主控设备观察到，而且可以被目标从属I&#x2F;O设备观察到，并且可以以宽松或强顺序来访问I&#x2F;O区域。对具有宽松排序的 I&#x2F;O 区域的访问通常由其他硬件和总线主控设备以类似于对 RVWMO 存储器区域的访问顺序的方式进行观察，如本规范第 I 卷中的 A.4.2 节中所讨论的。相比之下，对具有强顺序的 I&#x2F;O 区域的访问通常由其他 hart 和总线主控设备按程序顺序观察。</p>
<p>每个强有序 I&#x2F;O 区域都指定一个编号的排序通道，这是一种可以在不同 I&#x2F;O 区域之间提供排序保证的机制。通道 0 仅用于指示点对点强排序，其中仅 hart 对单个关联 I&#x2F;O 区域的访问是强排序的。</p>
<p>通道 1 用于在所有 I&#x2F;O 区域提供全局强排序。 hart 对与通道 1 关联的任何 I&#x2F;O 区域的任何访问只能被所有其他 hart 和 I&#x2F;O 设备观察到按程序顺序发生，包括相对于该 hart 对具有不同通道号的宽松 I&#x2F;O 区域或强有序 I&#x2F;O 区域进行的访问。换句话说，对通道1中某个区域的任何访问都相当于在该指令之前和之后执行了一个fence io,io指令。</p>
<p>其他较大的通道编号为该硬件跨具有相同通道编号的任何区域的访问提供程序排序。</p>
<p>系统可能支持每个内存区域的排序属性的动态配置。</p>
<blockquote>
<p>强排序可用于提高与旧设备驱动程序代码的兼容性，或者当已知实现不会对访问进行重新排序时，与插入显式排序指令相比，可以提高性能。</p>
<p>本地强排序（通道 0）是强排序的默认形式，因为如果 hart 和 I&#x2F;O 设备之间只有单个有序通信路径，则通常可以直接提供。</p>
<p>通常，如果不同的强排序 I&#x2F;O 区域共享相同的互连路径并且该路径不重新排序请求，则它们可以共享相同的排序通道，而无需额外的排序硬件。</p>
</blockquote>
<h3 id="3-6-5-PMA-的一致性和可缓存性"><a href="#3-6-5-PMA-的一致性和可缓存性" class="headerlink" title="3.6.5 PMA 的一致性和可缓存性"></a>3.6.5 PMA 的一致性和可缓存性</h3><p>一致性是为单个物理地址定义的一种属性，表示一个代理对该地址的写入最终将对系统中的其他代理可见。不要将一致性与系统的内存一致性模型混淆，后者定义了在给定整个内存系统的先前读写历史记录的情况下，内存读取可以返回哪些值。在 RISC-V 平台中，由于软件复杂性、性能和能耗影响，不鼓励使用硬件不相干区域。</p>
<p>内存区域的可缓存性不应影响该区域的软件视图，除了其他 PMA 中反映的差异外，例如主内存与 I&#x2F;O 分类、内存排序、支持的访问和原子操作以及一致性。因此，我们将缓存能力视为仅由机器模式软件管理的平台级设置。</p>
<p>当平台支持内存区域的可配置缓存能力设置时，平台特定的机器模式例程将更改设置并在必要时刷新缓存，因此系统仅在缓存能力设置之间的转换期间不一致。这种暂时状态对于较低权限级别不应该是可见的。</p>
<blockquote>
<p>我们将 RISC-V 缓存分为三种类型：主私有、共享和从私有。主私有缓存连接到单个主代理，即向内存系统发出读&#x2F;写请求的代理。共享缓存位于主设备和从设备之间，并且可以分层组织。从机专用缓存不会影响一致性，因为它们是单个从机的本地缓存，并且不会影响主机上的其他 PMA，因此这里不再进一步考虑。除非另有明确说明，否则我们在下一节中使用私有缓存来表示主私有缓存。</p>
<p>为不被任何代理缓存的共享内存区域提供一致性是很简单的。此类区域的 PMA 将简单地指示不应将其缓存在私有或共享缓存中</p>
<p>对于只读区域来说，一致性也很简单，可以由多个代理安全地缓存，而不需要缓存一致性方案。该区域的 PMA 将指示它可以被缓存，但不支持写入。</p>
<p>某些读写区域可能只能由单个代理访问，在这种情况下，它们可以由该代理私下缓存，而不需要一致性方案。这些区域的 PMA 将表明它们可以被缓存。数据也可以缓存在共享缓存中，因为其他代理不应访问该区域</p>
<p>如果一个代理可以缓存其他代理可以访问的读写区域，无论是缓存还是非缓存，都需要缓存一致性方案来避免使用过时的值。在缺乏硬件缓存一致性的区域（硬件不一致性区域），缓存一致性可以完全在软件中实现，但众所周知，软件一致性方案很难正确实现，并且由于需要保守的软件引导的缓存刷新，通常会产生严重的性能影响。硬件缓存一致性方案需要更复杂的硬件，并且可能由于缓存一致性探测而影响性能，但对于软件来说是不可见的。</p>
<p>对于每个硬件高速缓存一致性区域，PMA 将指示该区域是一致的，以及如果系统具有多个一致性控制器则使用哪个硬件一致性控制器。对于某些系统，一致性控制器可能是外层共享高速缓存，其本身可以分层地访问进一步的外层高速缓存一致性控制器。</p>
<p>平台内的大多数内存区域将与软件一致，因为它们将被固定为未缓存、只读、硬件缓存一致或仅由一个代理访问。</p>
</blockquote>
<p>如果 PMA 指示不可缓存性，则对该区域的访问必须由内存本身满足，而不是由任何缓存满足。</p>
<blockquote>
<p>对于具有高速缓存能力控制机制的实现，可能会出现程序无法高速缓存地访问当前驻留在高速缓存中的存储器位置的情况。在这种情况下，必须忽略缓存的副本。此约束对于防止特权较高模式的推测缓存重新填充影响特权较低模式的不可缓存访问的行为是必要的。</p>
</blockquote>
<h3 id="3-6-6-幂等性PMA"><a href="#3-6-6-幂等性PMA" class="headerlink" title="3.6.6 幂等性PMA"></a>3.6.6 幂等性PMA</h3><p>幂等性 PMA 描述对地址区域的读取和写入是否是幂等的。假定主内存区域是幂等的。对于 I&#x2F;O 区域，可以单独指定读取和写入的幂等性（例如，读取是幂等的，但写入不是）。如果访问是非幂等的，即任何读或写访问都可能存在副作用，则必须避免推测或冗余访问。</p>
<p>出于定义幂等性 PMA 的目的，由冗余访问创建的观察到的内存顺序的变化不被视为副作用。</p>
<blockquote>
<p>虽然硬件的设计应始终避免对标记为非幂等的内存区域进行推测或冗余访问，但也有必要确保软件或编译器优化不会生成对非幂等内存区域的虚假访问。</p>
</blockquote>
<blockquote>
<p>非幂等区域可能不支持未对齐的访问。对此类区域的未对齐访问应该引发访问错误异常，而不是地址未对齐异常，这表明软件不应使用多个较小的访问来模拟未对齐的访问，这可能会导致意外的副作用。</p>
</blockquote>
<p>对于非幂等区域，不得提前或推测地执行隐式读取和写入，但以下例外。当执行非推测性隐式读取时，允许实现另外读取包含非推测性隐式读取的地址的自然对齐的 2 的幂区域内的任何字节。此外，当执行非推测性指令提取时，允许实现另外读取相同大小的下一个自然对齐的 2 的幂区域内的任何字节（该区域的地址以 2XLEN 为模）。这些附加读取的结果可用于满足后续的早期或推测性隐式读取。这些自然对齐的 2 幂区域的大小是实现定义的，但是，对于具有基于页面的虚拟内存的系统，不得超过支持的最小页面大小。</p>
<h2 id="3-7-物理内存保护"><a href="#3-7-物理内存保护" class="headerlink" title="3.7 物理内存保护"></a>3.7 物理内存保护</h2><p>为了支持安全处理并包含故障，需要限制硬件上运行的软件可访问的物理地址。可选的物理内存保护 (PMP) 单元提供 per-hart 机器模式控制寄存器，允许为每个物理内存区域指定物理内存访问权限（读、写、执行）。 PMP 值的检查与第 3.6 节中描述的 PMA 检查并行。</p>
<p>PMP 访问控制设置的粒度是特定于平台的，但标准 PMP 编码支持小至四个字节的区域。某些区域的权限可以是硬连线的 - 例如，某些区域可能仅在机器模式下可见，但在较低权限层中不可见。</p>
<blockquote>
<p>平台对物理内存保护的需求差异很大，并且某些平台可能会提供其他 PMP 结构来补充或替代本节中描述的方案。</p>
</blockquote>
<p>PMP 检查适用于有效特权模式为 S 或 U 的所有访问，包括 S 和 U 模式下的取指令、mstatus 寄存器中的 MPRV 位清零时 S 和 U 模式下的数据访问，以及 mstatus 中的 MPRV 位置位且 mstatus 中的 MPP 字段包含 S 或 U 时的任何模式下的数据访问。PMP 检查还适用于虚拟地址转换的页表访问，其有效特权模式为 S。可选地，PMP 检查还可以适用于 M-模式访问，在这种情况下，PMP 寄存器本身被锁定，因此即使是 M 模式软件也无法更改它们，直到 hart 复位。实际上，PMP 可以向 S 和 U 模式授予权限（默认情况下没有权限），并且可以撤销 M 模式的权限（默认情况下具有完全权限）。</p>
<p>PMP 违规总是被精确地捕获在处理器中。</p>
<h3 id="3-7-1-物理内存保护-CSR"><a href="#3-7-1-物理内存保护-CSR" class="headerlink" title="3.7.1 物理内存保护 CSR"></a>3.7.1 物理内存保护 CSR</h3><p>PMP 条目由 8 位配置寄存器和 1 个 MXLEN 位地址寄存器描述。某些 PMP 设置还使用与前面的 PMP 条目关联的地址寄存器。最多支持 64 个 PMP 条目。实现可以实现0个、16 个或 64 个 PMP CSR；必须首先实施编号最低的 PMP CSR。所有 PMP CSR 字段都是 WARL，并且可以是只读零。 PMP CSR 仅适用于 M 模式。</p>
<blockquote>
<p>RV64 系统使用 pmpcfg2（而不是 pmpcfg1）来保存 PMP 条目 8-15 的配置。此设计降低了支持多个 MXLEN 值的成本，因为 PMP 条目 8-11 的配置出现在 RV32 和 RV64 的 pmpcfg2[31:0] 中。</p>
</blockquote>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724141910461-1730798006987-48.png" alt="image-20230724141910461"></p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724141918708-1730798006987-49.png" alt="image-20230724141918708"></p>
<p>PMP 地址寄存器是名为 pmpaddr0–pmpaddr63 的 CSR。每个 PMP 地址寄存器对 RV32 的 34 位物理地址的第 33-2 位进行编码，如图 3.33 所示。对于 RV64，每个 PMP 地址寄存器对 56 位物理地址的第 55-2 位进行编码，如图 3.34 所示。并非所有物理地址位都可以实现，因此 pmpaddr 寄存器是 WARL。</p>
<blockquote>
<p>PMP 地址寄存器是名为 pmpaddr0–pmpaddr63 的 CSR。每个 PMP 地址寄存器对 RV32 的 34 位物理地址的第 33-2 位进行编码，如图 3.33 所示。对于 RV64，每个 PMP 地址寄存器对 56 位物理地址的第 55-2 位进行编码，如图 3.34 所示。并非所有物理地址位都可以实现，因此 pmpaddr 寄存器是 WARL。</p>
</blockquote>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724141945653-1730798006987-50.png" alt="image-20230724141945653"></p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724141953635-1730798006987-51.png" alt="image-20230724141953635"></p>
<p>图 3.35 显示了 PMP 配置寄存器的布局。 R、W 和 X 位设置后，分别指示 PMP 条目允许读、写和指令执行。当这些位之一被清除时，相应的访问类型被拒绝。 R、W和X字段形成集体WARL字段，其中R&#x3D;0和W&#x3D;1的组合被保留。其余两个字段 A 和 L 将在以下部分中描述。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724142012022-1730798006987-52.png" alt="image-20230724142012022"></p>
<p>尝试从没有执行权限的 PMP 区域获取指令会引发指令访问错误异常。尝试执行在没有读权限的情况下访问 PMP 区域内的物理地址的加载或加载保留指令会引发加载访问错误异常。尝试执行在没有写权限的情况下访问 PMP 区域内的物理地址的存储、条件存储或 AMO 指令会引发存储访问错误异常。</p>
<p>如果 MXLEN 更改，pmpxcfg 字段的内容将被保留，但会出现在 MXLEN 新设置规定的 pmpcfgy CSR 中。例如，当 MXLEN 从 64 更改为 32 时，pmp4cfg 从 pmpcfg0[39:32] 移动到 pmpcfg1[7:0]。 pmpaddr CSR 遵循第 2.6 节中描述的常用 CSR 宽度调制规则。</p>
<h5 id="地址匹配-Address-Matching"><a href="#地址匹配-Address-Matching" class="headerlink" title="地址匹配  Address Matching"></a>地址匹配  Address Matching</h5><p>PMP 条目配置寄存器中的 A 字段对关联 PMP 地址寄存器的地址匹配模式进行编码。该字段的编码如表3.10所示。当A&#x3D;0时，该PMP条目被禁用并且不匹配任何地址。支持另外两种地址匹配模式：自然对齐的 2 幂区域 (NAPOT)，包括自然对齐的四字节区域 (NA4) 的特殊情况；以及任意范围的顶部边界 (TOR)。这些模式支持四字节粒度。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724142103189-1730798006987-53.png" alt="image-20230724142103189"></p>
<p>NAPOT 范围利用相关地址寄存器的低位来编码范围的大小，如表 3.11 所示。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724142124344-1730798006987-54.png" alt="image-20230724142124344"></p>
<p>如果选择 TOR，则关联的地址寄存器形成地址范围的顶部，而前面的 PMP 地址寄存器形成地址范围的底部。如果 PMP 条目 i 的 A 字段设置为 TOR，则该条目与任何地址 y 匹配，使得 pmpaddr<del>i−1</del> ≤ y &lt; pmpaddr<del>i</del> （与 pmmpcfg<del>i−1</del> 的值无关）。如果 PMP 条目 0 的 A 字段设置为 TOR，则零用于下限，因此它匹配任何地址 y &lt; pmpaddr<del>0</del> 。</p>
<blockquote>
<p>如果 pmpaddr<del>i−1</del> ≥ pmpaddr<del>i</del> 且 pmmpcfg<del>i</del>.A&#x3D;TOR，则 PMP 条目 i 不匹配任何地址。</p>
</blockquote>
<p>尽管 PMP 机制支持小至四个字节的区域，但平台可以指定更粗略的 PMP 区域。一般来说，PMP 粒度为 2G+2 字节，并且所有 PMP 区域中的粒度必须相同。当G≥1时，NA4模式不可选。当 G ≥ 2 且 pmmpcfgi .A[1] 被设置时，即模式为 NAPOT，则位 pmpaddri [G-2:0] 读取为全 1。当 G ≥ 1 且 pmmpcfgi .A[1] 清零时，即模式为 OFF 或 TOR，则位 pmpaddri [G-1:0] 读取为全零。位 pmpaddri [G1:0] 不影响 TOR 地址匹配逻辑。尽管更改 pmpcfgi .A[1] 会影响从 pmpaddri 读取的值，但它不会影响该寄存器中存储的基础值 — 特别是，当 pmpcfgi .A 从 NAPOT 更改为 TOR&#x2F;OFF 然后再更改回 NAPOT 时，pmpaddri [G-1] 保留其原始值。</p>
<p>软件可以通过将零写入pmp0cfg、然后将所有1写入pmpaddr0、然后读回pmpaddr0来确定PMP粒度。如果G是最低有效位组的索引，则PMP粒度是2^G+2^字节。</p>
<p>如果当前 XLEN 大于 MXLEN，则 PMP 地址寄存器将从 MXLEN 位零扩展至 XLEN 位，以实现地址匹配。</p>
<h5 id="锁定和特权模式-Locking-and-Privilege-Mode"><a href="#锁定和特权模式-Locking-and-Privilege-Mode" class="headerlink" title="锁定和特权模式 Locking and Privilege Mode"></a>锁定和特权模式 Locking and Privilege Mode</h5><p>L 位表示 PMP 条目已锁定，即对配置寄存器和相关地址寄存器的写入被忽略。锁定的 PMP 条目将保持锁定状态，直到重置 Hart。如果 PMP 条目 i 被锁定，则对 pmpicfg 和 pmpaddri 的写入将被忽略。此外，如果 PMP 条目 i 被锁定并且 pmpicfg.A 设置为 TOR，则忽略对 pmpaddri-1 的写入。</p>
<blockquote>
<p>即使 A 字段设置为 OFF，设置 L 位也会锁定 PMP 条目。</p>
</blockquote>
<p>除了锁定 PMP 条目之外，L 位还指示是否对 M 模式访问强制执行 R&#x2F;W&#x2F;X 权限。当 L 位被设置时，这些权限将针对所有特权模式强制执行。当L位清零时，任何与PMP条目匹配的M模式访问都会成功； R&#x2F;W&#x2F;X 权限仅适用于 S 和 U 模式。</p>
<h5 id="优先级和匹配逻辑-Priority-and-Matching-Logic"><a href="#优先级和匹配逻辑-Priority-and-Matching-Logic" class="headerlink" title="优先级和匹配逻辑 Priority and Matching Logic"></a>优先级和匹配逻辑 Priority and Matching Logic</h5><p>PMP 条目是静态优先级的。与访问的任何字节匹配的编号最小的 PMP 条目决定该访问是成功还是失败。匹配的 PMP 条目必须与访问的所有字节匹配，否则无论 L、R、W 和 X 位如何，访问都会失败。例如，如果 PMP 条目配置为匹配四字节范围 0xC–0xF，则假设 PMP 条目是与这些地址匹配的最高优先级条目，则对 0x8–0xF 范围的 8 字节访问将失败。</p>
<p>如果 PMP 条目与访问的所有字节匹配，则 L、R、W 和 X 位确定访问是否成功或失败。如果L位清零且访问的特权模式为M，则访问成功。否则，如果设置了L位或者访问的特权模式为S或U，则只有设置了与访问类型对应的R、W或X位，访问才会成功。</p>
<p>如果没有PMP表项匹配M模式接入，则接入成功。如果没有PMP表项匹配S模式或U模式接入，但至少实现了一个PMP表项，则接入失败。</p>
<blockquote>
<p>如果至少实现了一个 PMP 条目，但所有 PMP 条目的 A 字段都设置为 OFF，则所有 S 模式和 U 模式内存访问都将失败。</p>
</blockquote>
<p>失败的访问会生成指令、加载或存储访问错误异常。请注意，单个指令可能会生成多个访问，这些访问可能不是相互原子的。如果一条指令生成的至少一个访问失败，则生成访问错误异常，尽管该指令生成的其他访问可能会成功，但会产生明显的副作用。值得注意的是，引用虚拟内存的指令被分解为多次访问。</p>
<p>在一些实现中，未对齐的加载、存储和指令提取也可以分解为多次访问，其中一些访问可以在访问错误异常发生之前成功。特别是，通过 PMP 检查的未对齐存储的一部分可能会变得可见，即使另一部分未通过 PMP 检查。对于比 XLEN 位宽的浮点存储（例如 RV32D 中的 FSD 指令），即使存储地址自然对齐，也可能出现相同的行为。</p>
<h3 id="3-7-2-物理内存保护和分页"><a href="#3-7-2-物理内存保护和分页" class="headerlink" title="3.7.2 物理内存保护和分页"></a>3.7.2 物理内存保护和分页</h3><p>物理内存保护机制旨在与第 4 章中描述的基于页的虚拟内存系统组合在一起。当启用分页时，访问虚拟内存的指令可能会导致多次物理内存访问，包括对页表的隐式引用。 PMP 检查适用于所有这些访问。隐式页表访问的有效特权模式是 S。</p>
<p>虚拟内存的实现允许推测性地执行地址转换，并且比显式内存访问所需的时间更早，并且允许将它们缓存在地址转换缓存结构中，包括可能缓存在裸转换模式和 M 模式中使用的从有效地址到物理地址的标识映射。可以在地址转换和显式存储器访问之间的任何点检查（并且可能缓存）所得到的物理地址的PMP设置。因此，当修改 PMP 设置时，M 模式软件必须将 PMP 设置与虚拟内存系统和任何 PMP 或地址转换高速缓存同步。这是通过在写入 PMP CSR 后执行 rs1&#x3D;x0 和 rs2&#x3D;x0 的 SFENCE.VMA 指令来实现的。</p>
<p>如果未实现基于页的虚拟内存，则内存访问会同步检查 PMP 设置，因此不需要 SFENCE.VMA。</p>
<h1 id="4-Supervisor-ISA，版本-1-12"><a href="#4-Supervisor-ISA，版本-1-12" class="headerlink" title="4. Supervisor ISA，版本 1.12"></a>4. Supervisor ISA，版本 1.12</h1><p>本章介绍 RISC-V Supervisor 架构，其中包含与各种Supervisor 地址转换和保护方案一起使用的通用内核。</p>
<blockquote>
<p>Supervisor 模式在与底层物理硬件（例如物理内存和设备中断）的交互方面被刻意限制，以支持干净的虚拟化。本着这种精神，某些Supervisor 设施（包括定时器和处理器间中断的请求）由特定于实现的机制提供。在一些系统中，Supervisor执行环境（SEE）以Supervisor二进制接口（SBI）指定的方式提供这些设施。其他系统通过其他一些实现定义的机制直接提供这些设施。</p>
</blockquote>
<h2 id="4-1-Supervisor-CSR"><a href="#4-1-Supervisor-CSR" class="headerlink" title="4.1 Supervisor CSR"></a>4.1 Supervisor CSR</h2><p>为Supervisor提供了许多 CSR。</p>
<blockquote>
<p>Supervisor应该只查看Supervisor级操作系统应该可见的 CSR 状态。特别是，在Supervisor可访问的 CSR 中，没有关于存在（或不存在）可见的更高权限级别（机器级别或其他）的信息。</p>
<p>许多Supervisor CSR 是等效机器模式 CSR 的子集，应首先阅读机器模式章节以帮助理解Supervisor级 CSR 描述。</p>
</blockquote>
<h3 id="4-1-1-Supervisor状态寄存器（sstatus）"><a href="#4-1-1-Supervisor状态寄存器（sstatus）" class="headerlink" title="4.1.1 Supervisor状态寄存器（sstatus）"></a>4.1.1 Supervisor状态寄存器（sstatus）</h3><p>sstatus 寄存器是一个 SXLEN 位读&#x2F;写寄存器，当 SXLEN&#x3D;32 时，格式如图 4.1 所示；当 SXLEN&#x3D;64 时，格式如图 4.2 所示。状态寄存器跟踪处理器的当前操作状态。</p>
<p>SPP 位指示在进入管理模式之前，hart 正在执行的特权级别。当捕获陷阱时，如果陷阱源自User mode，则 SPP 设置为 0，否则设置为 1。</p>
<p>当执行 SRET 指令（参见第 3.3.2 节）从陷阱处理程序返回时，如果 SPP 位为 0，则特权级别设置为User mode；如果 SPP 位为 1，则特权级别设置为Supervisor模式；然后 SPP 设置为 0。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724143935161-1730798006987-55.png" alt="image-20230724143935161"></p>
<p>SIE 位允许或禁止Supervisor模式下的所有中断。当 SIE 清零时，在管理模式下不会产生中断。当hart在User mode下运行时，SIE中的值被忽略，并启用Supervisor 中断。Supervisor可以使用 sie CSR 禁用各个中断源。</p>
<p>SPIE 位指示在陷入Supervisor mode之前是否启用Supervisor中断。当陷阱进入Supervisor模式时，SPIE 设置为 SIE，并且 SIE 设置为 0。当执行 SRET 指令时，SIE 设置为 SPIE，然后 SPIE 设置为 1。</p>
<p>sstatus 寄存器是 mstatus 寄存器的子集。</p>
<blockquote>
<p>在简单的实现中，读取或写入 sstatus 中的任何字段都相当于读取或写入 mstatus 中的同名字段。</p>
</blockquote>
<h4 id="4-1-1-1-sstatus-寄存器中的基本-ISA-控制"><a href="#4-1-1-1-sstatus-寄存器中的基本-ISA-控制" class="headerlink" title="4.1.1.1 sstatus 寄存器中的基本 ISA 控制"></a>4.1.1.1 sstatus 寄存器中的基本 ISA 控制</h4><p>UXL 字段控制 U 模式的 XLEN 值，称为 UXLEN，它可能与 S 模式的 XLEN 值（称为 SXLEN）不同。 UXL的编码与misa的MXL字段的编码相同，如表3.1所示。</p>
<p>当SXLEN&#x3D;32时，UXL字段不存在，UXLEN&#x3D;32。当SXLEN&#x3D;64时，它是一个WARL字段，编码UXLEN的当前值。特别地，实现可以使UXL成为只读字段，其值始终确保UXLEN&#x3D;SXLEN。</p>
<p>如果 UXLEN ̸&#x3D; SXLEN，则在较窄模式下执行的指令必须忽略高于配置的 XLEN 的源寄存器操作数位，并且必须对结果进行符号扩展以填充目标寄存器中支持的最宽 XLEN。</p>
<p>如果UXLEN &lt; SXLEN，则User mode取指令地址以及加载和存储有效地址取模2UXLEN。例如，当 UXLEN&#x3D;32 且 SXLEN&#x3D;64 时，User mode内存访问引用地址空间的最低 4 GiB。</p>
<h4 id="4-1-1-2-sstatus-寄存器中的内存权限"><a href="#4-1-1-2-sstatus-寄存器中的内存权限" class="headerlink" title="4.1.1.2 sstatus 寄存器中的内存权限"></a>4.1.1.2 sstatus 寄存器中的内存权限</h4><p>MXR（使可执行文件可读）位修改加载访问虚拟内存的权限。当 MXR&#x3D;0 时，只有从标记为可读的页面（图 4.18 中的 R&#x3D;1）加载才会成功。当 MXR&#x3D;1 时，从标记为可读或可执行（R&#x3D;1 或 X&#x3D;1）的页面加载将会成功。当基于页面的虚拟内存未生效时，MXR 无效。</p>
<p>SUM（允许Supervisor用户内存访问）位修改 S 模式加载和存储访问虚拟内存的权限。当 SUM&#x3D;0 时，S 模式内存对 U 模式（图 4.18 中 U&#x3D;1）可访问的页面的访问将会出错。当SUM&#x3D;1时，允许这些访问。当基于页的虚拟内存未生效时以及在 U 模式下执行时，SUM 不起作用。请注意，无论 SUM 的状态如何，S 模式都无法执行用户页面中的指令。</p>
<p>如果 satp.MODE 为只读 0，则 SUM 为只读 0。</p>
<blockquote>
<p>SUM 机制可防止监控软件无意中访问用户内存。</p>
<p>操作系统可以在 SUM 清零的情况下执行大部分代码；应该访问用户内存的少数代码段可以临时设置 SUM。</p>
<p>SUM 机制不利用 S 模式软件的权限来执行用户代码页中的指令。在Supervisor上下文中从用户内存执行的合法用例通常很少见，并且在 POSIX 环境中不存在。然而，如果Supervisor漏洞利用代码可以存储在用户缓冲区中攻击者选择的虚拟地址处，那么Supervisor中导致任意代码执行的错误就会更容易被利用。</p>
<p>一些非 POSIX 单地址空间操作系统确实允许某些特权软件部分在Supervisor模式下执行，而大多数程序在User mode下运行，所有程序都在共享地址空间中。该用例可以通过将物理代码页映射到具有不同权限的多个虚拟地址来实现，可能在指令页错误处理程序的帮助下指导Supervisor软件使用备用映射。</p>
</blockquote>
<h4 id="4-1-1-3-sstatus-寄存器中的字节顺序控制"><a href="#4-1-1-3-sstatus-寄存器中的字节顺序控制" class="headerlink" title="4.1.1.3 sstatus 寄存器中的字节顺序控制"></a>4.1.1.3 sstatus 寄存器中的字节顺序控制</h4><p>UBE 位是一个 WARL 字段，用于控制 U 模式下显式内存访问的字节顺序，该字节顺序可能与 S 模式下内存访问的字节顺序不同。实现可以使 UBE 成为始终指定与 S 模式相同的字节顺序的只读字段。</p>
<p>UBE 控制从 U 模式进行的显式加载和存储内存访问是小端 (UBE&#x3D;0) 还是大端 (UBE&#x3D;1)。</p>
<p>UBE 对指令获取没有影响，指令获取是始终为小尾数的隐式内存访问。</p>
<p>对于对Supervisor 内存管理数据结构（例如页表）的隐式访问，S 模式字节顺序始终适用，并且 UBE 被忽略。</p>
<blockquote>
<p>标准 RISC-V ABI 预计纯粹是仅小端字节序或仅大端字节序，不支持混合字节序。然而，字节序控制已被定义为允许一种字节序的操作系统执行相反字节序的User mode程序。</p>
</blockquote>
<h3 id="4-1-2-Supervisor陷阱向量基地址寄存器（stvec）"><a href="#4-1-2-Supervisor陷阱向量基地址寄存器（stvec）" class="headerlink" title="4.1.2 Supervisor陷阱向量基地址寄存器（stvec）"></a>4.1.2 Supervisor陷阱向量基地址寄存器（stvec）</h3><p>stvec 寄存器是一个 SXLEN 位读&#x2F;写寄存器，用于保存陷阱向量配置，由向量基地址 (BASE) 和向量模式 (MODE) 组成。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724145322312-1730798006987-56.png" alt="image-20230724145322312"></p>
<p>stvec 中的 BASE 字段是一个 WARL 字段，可以保存任何<strong>有效的虚拟或物理地址</strong>，但受到以下对齐约束：地址必须是 4 字节对齐，并且除 Direct 之外的 MODE 设置可能会对 BASE 字段中的值施加额外的对齐约束。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724145344664-1730798006987-57.png" alt="image-20230724145344664"></p>
<p>MODE字段的编码如表4.1所示。当 MODE&#x3D;Direct 时，所有进入管理模式的陷阱都会导致 pc 设置为 BASE 字段中的地址。当 MODE&#x3D;Vectored 时，进入Supervisor mode的所有同步异常都会导致 pc 被设置为 BASE 字段中的地址，而中断则导致 pc 被设置为 BASE 字段中的地址加上四倍的中断原因编号。例如，管理模式定时器中断（参见表 4.2）导致 pc 设置为 BASE+0x14。设置 MODE&#x3D;Vectored 可能会对 BASE 施加更严格的对齐约束。</p>
<h3 id="4-1-3-Supervisor中断寄存器（sip-和-sie）"><a href="#4-1-3-Supervisor中断寄存器（sip-和-sie）" class="headerlink" title="4.1.3 Supervisor中断寄存器（sip 和 sie）"></a>4.1.3 Supervisor中断寄存器（sip 和 sie）</h3><p>sip 寄存器是包含待处理中断信息的 SXLEN 位读&#x2F;写寄存器，而 sie 是包含中断使能位的相应 SXLEN 位读&#x2F;写寄存器。中断原因编号 i（如 CSR 原因第 4.1.8 节中所报告）与 sip 和 sie 中的位 i 相对应。位 15:0 仅分配给标准中断原因，而位 16 及以上指定用于平台或自定义使用。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724145729075-1730798006987-58.png" alt="image-20230724145729075"></p>
<p>如果满足以下两个条件，则中断 i 将陷入 S 模式：</p>
<ol>
<li><strong>当前特权模式为 S 并且 sstatus 寄存器中的 SIE 位被置位，或者当前特权模式的特权低于 S 模式；</strong></li>
<li><strong>位i在sip和sie中均被设置。</strong></li>
</ol>
<p>中断陷阱发生的这些条件必须在 sip 中的中断变为或停止挂起时起的有限时间内进行评估，并且还必须在执行 SRET 指令或显式写入这些中断陷阱条件明确依赖的 CSR（包括 sip、sie 和 sstatus）之后立即评估。</p>
<p>S 模式的中断优先于任何低特权模式的中断。</p>
<p>寄存器sip中的每个单独的位可以是可写的或者可以是只读的。当 sip 中的位 i 可写时，可以通过向该位写入 0 来清除挂起的中断 i。如果中断 i 可以变为挂起，但 sip 中的位 i 是只读的，则实现必须提供某种其他机制来清除挂起的中断（这可能涉及对执行环境的调用）。</p>
<p>如果相应的中断可能变为挂起状态，则 sie 中的位必须是可写的。不可写的 sie 位是只读的零。</p>
<p>寄存器 sip 和 sie 的标准部分（位 15:0）的格式分别如图 4.6 和 4.7 所示。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724145759373-1730798006987-59.png" alt="image-20230724145759373"></p>
<ul>
<li><p>位 sip.SEIP 和 sie.SEIE 是Supervisor级<strong>外部中断</strong>的中断挂起和中断启用位。如果实现，<strong>SEIP 在 sip 中是&#x3D;&#x3D;只读&#x3D;&#x3D;的</strong>，并且由执行环境设置和清除，通常通过特定于平台的中断控制器。</p>
</li>
<li><p>位 sip.STIP 和 sie.STIE 是Supervisor级<strong>定时器</strong>中断的中断待处理位和中断使能位。如果实现，<strong>STIP在sip中是&#x3D;&#x3D;只读&#x3D;&#x3D;的</strong>，并且由执行环境设置和清除。</p>
</li>
<li><p>位 sip.SSIP 和 sie.SSIE 是Supervisor级<strong>软件中断</strong>的中断待处理位和中断使能位。如果实现，<strong>SSIP 在 sip 中是&#x3D;&#x3D;可写&#x3D;&#x3D;的</strong>，并且也可以由特定于平台的中断控制器设置为 1。</p>
</li>
</ul>
<blockquote>
<p>处理器间中断通过特定于实现的方式发送到其他 hart，这最终将导致接收 hart 的 sip 寄存器中的 SSIP 位被设置。</p>
</blockquote>
<p>每个标准中断类型（SEI、STI 或 SSI）可能无法实现，在这种情况下，相应的中断挂起和中断启用位是只读零。 sip 和 sie 中的所有位都是 WARL 字段。可以通过向 sie 中的每个位位置写入 1，然后读回以查看哪些位位置保存有 1，来找到已实现的中断。</p>
<blockquote>
<p><strong>sip 和 sie 寄存器是 mip 和 mie 寄存器的子集。读取 sip&#x2F;sie 的任何已实现字段或写入任何可写字段都会影响对 mip&#x2F;mie 的同名字段的读取或写入。</strong></p>
<p>sip 和 sie 的位 3、7 和 11 分别对应机器模式软件、定时器和外部中断。由于大多数平台会选择不将这些中断从 M 模式委托给 S 模式，因此它们在图 4.6 和 4.7 中显示为 0。</p>
</blockquote>
<p>发往Supervisor mode的多个同时中断按以下优先级递减顺序进行处理：SEI、SSI、STI。</p>
<h3 id="4-1-4-Supervisor定时器和性能计数器"><a href="#4-1-4-Supervisor定时器和性能计数器" class="headerlink" title="4.1.4 Supervisor定时器和性能计数器"></a>4.1.4 Supervisor定时器和性能计数器</h3><p>Supervisor软件使用与User mode软件相同的硬件性能监控工具，包括时间、周期和 instret CSR。实现应该提供一种修改计数器值的机制。</p>
<p>该实现必须提供一种根据实时计数器时间来调度定时器中断的工具。</p>
<h3 id="4-1-5-计数器使能寄存器（scounteren）"><a href="#4-1-5-计数器使能寄存器（scounteren）" class="headerlink" title="4.1.5 计数器使能寄存器（scounteren）"></a>4.1.5 计数器使能寄存器（scounteren）</h3><p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724145934050-1730798006987-60.png" alt="image-20230724145934050"></p>
<p>计数器使能寄存器 scounteren 是一个 32 位寄存器，用于控制硬件性能监控计数器对 U 模式的可用性。</p>
<p>当 scounteren 寄存器中的 CY、TM、IR 或 HPMn 位清零时，在 U 模式下执行时尝试读取周期、时间、instret 或 hpmcountern 寄存器将导致非法指令异常。当这些位之一被设置时，允许访问相应的寄存器。</p>
<p>scounteren 必须实现。然而，任何位都可能是只读零，这表明在 U 模式下执行时读取相应的计数器将导致异常。因此，它们实际上是 WARL 字段。</p>
<blockquote>
<p>mcounteren 中某个位的设置不影响 scounteren 中相应位是否可写。然而，如果 scounteren 和 mcounteren 中的相应位都被设置，则 U 模式只能访问计数器。</p>
</blockquote>
<h3 id="4-1-6-Supervisor暂存寄存器（sscratch）"><a href="#4-1-6-Supervisor暂存寄存器（sscratch）" class="headerlink" title="4.1.6 Supervisor暂存寄存器（sscratch）"></a>4.1.6 Supervisor暂存寄存器（sscratch）</h3><p>sscratch 寄存器是一个 SXLEN 位读&#x2F;写寄存器，专用于监控程序使用。</p>
<p>通常，sscratch 用于在 hart 执行用户代码时保存指向 hart 本地 Supervisor上下文的指针。在陷阱处理程序开始时，sscratch 与用户寄存器交换以提供初始工作寄存器。</p>
<h3 id="4-1-7-Supervisor异常程序计数器（sepc）"><a href="#4-1-7-Supervisor异常程序计数器（sepc）" class="headerlink" title="4.1.7 Supervisor异常程序计数器（sepc）"></a>4.1.7 Supervisor异常程序计数器（sepc）</h3><p>sepc 是一个 SXLEN 位读&#x2F;写寄存器，其格式如图 4.10 所示。 sepc (sepc[0]) 的低位始终为零。在仅支持 IALIGN&#x3D;32 的实现中，两个低位 (sepc[1:0]) 始终为零。</p>
<p>如果实现允许 IALIGN 为 16 或 32（例如，通过更改 CSR misa），则每当 IALIGN&#x3D;32 时，位 sepc[1] 在读取时被屏蔽，使其显示为 0。这种屏蔽也会发生在 SRET 指令的隐式读取中。尽管被屏蔽，当 IALIGN&#x3D;32 时，sepc[1] 仍然可写。</p>
<p>sepc 是一个 WARL 寄存器，必须能够保存所有<strong>有效的虚拟地址</strong>。它不需要能够保存所有可能的无效地址。在写入 sepc 之前，实现可能会将无效地址转换为 sepc 能够保存的其他一些无效地址。</p>
<p>当陷阱进入 S 模式时，<strong>sepc 会写入被中断或遇到异常的指令的虚拟地址</strong>。否则，sepc 永远不会由实现编写，尽管它可能是由软件显式编写的。</p>
<h3 id="4-1-8-Supervisor原因寄存器（scause）"><a href="#4-1-8-Supervisor原因寄存器（scause）" class="headerlink" title="4.1.8 Supervisor原因寄存器（scause）"></a>4.1.8 Supervisor原因寄存器（scause）</h3><p>原因寄存器是一个 SXLEN 位读写寄存器，其格式如图 4.11 所示。当陷阱进入 S 模式时，会使用指示导致陷阱的事件的代码写入原因。</p>
<p>否则，原因永远不会由实现编写，尽管它可能是由软件明确编写的。</p>
<p>如果陷阱是由中断引起的，则原因寄存器中的中断位会被置位。异常代码字段包含标识最后一个异常或中断的代码。表 4.2 列出了当前Supervisor ISA 可能的异常代码。异常代码是 WLRL 字段。要求保存值 0-31（即必须实现bit[4:0]），但否则仅保证保存受支持的异常代码。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724160610101-1730798006987-61.png" alt="image-20230724160610101"></p>
<h3 id="4-1-9-Supervisor陷阱值寄存器-stval"><a href="#4-1-9-Supervisor陷阱值寄存器-stval" class="headerlink" title="4.1.9 Supervisor陷阱值寄存器 (stval)"></a>4.1.9 Supervisor陷阱值寄存器 (stval)</h3><p>stval 寄存器是一个 SXLEN 位读写寄存器，其格式如图 4.12 所示。当陷阱进入 S 模式时，stval 会写入异常特定信息，以帮助软件处理陷阱。否则，stval 永远不会由实现编写，尽管它可能是由软件显式编写的。硬件平台将指定哪些异常必须以信息方式设置 stval，哪些异常可以无条件将其设置为零。</p>
<p>如果在指令获取、加载或存储过程中发生断点、地址未对齐、访问错误或页错误异常时用非零值写入 stval，则 stval 将包含错误虚拟地址。</p>
<p>如果在未对齐的加载或存储导致访问错误或页错误异常时使用非零值写入 stval，则 stval 将包含导致错误的访问部分的虚拟地址。</p>
<p>如果在具有可变长度指令的系统上发生指令访问错误或页错误异常时，将 stval 写入非零值，则 stval 将包含导致错误的指令部分的虚拟地址，而 sepc 将指向指令的开头。</p>
<p>stval 寄存器还可以选择用于在非法指令异常时返回错误指令位（sepc 指向内存中的错误指令）。如果发生非法指令异常时用非零值写入 stval，则 stval 将包含以下最短值：</p>
<ul>
<li>实际的故障指令 </li>
<li>故障指令的前 ILEN 位 </li>
<li>故障指令的前 SXLEN 位</li>
</ul>
<p>非法指令异常时加载到 stval 的值是右对齐的，并且所有未使用的高位都被清除为零。对于其他陷阱，stval 设置为零，但未来的标准可能会重新定义其他陷阱的 stval 设置。</p>
<p>stval 是一个 WARL 寄存器，必须能够保存所有有效的虚拟地址和值 0。它不需要能够保存所有可能的无效地址。在写入 stval 之前，实现可能会将无效地址转换为 stval 能够保存的其他无效地址。如果实现了返回错误指令位的功能，则 stval 还必须能够保存所有小于 2N 的值，其中 N 是 SXLEN 和 ILEN 中较小的一个。</p>
<h3 id="4-1-10-Supervisor环境配置寄存器（senvcfg）"><a href="#4-1-10-Supervisor环境配置寄存器（senvcfg）" class="headerlink" title="4.1.10 Supervisor环境配置寄存器（senvcfg）"></a>4.1.10 Supervisor环境配置寄存器（senvcfg）</h3><p>senvcfg CSR 是一个 SXLEN 位读&#x2F;写寄存器，其格式如图 4.13 所示，它控制 U 模式执行环境的某些特性。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724161315934-1730798006987-62.png" alt="image-20230724161315934"></p>
<p>如果 senvcfg 中的 FIOM 位（I&#x2F;O 栅栏意味着内存）设置为 1，则 U 模式下执行的 FENCE 指令将被修改，因此对设备 I&#x2F;O 的访问顺序的要求也意味着对主存储器访问的顺序要求。表 4.3 详细介绍了当 FIOM&#x3D;1 时 U 模式下 FENCE 指令位 PI、PO、SI 和 SO 的修改解释。</p>
<p>类似地，对于当 FIOM&#x3D;1 时的 U 模式，如果访问按设备 I&#x2F;O 排序的区域的原子指令设置了其 aq 和&#x2F;或 rl 位，则该指令的排序就像它访问设备 I&#x2F;O 和内存一样。</p>
<p>如果 satp.MODE 为只读零（始终为 Bare），则实现可能会使 FIOM 为只读零。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724161406984-1730798006987-63.png" alt="image-20230724161406984"></p>
<blockquote>
<p>当 I&#x2F;O 设备被仿真为 U 模式并且以下两个条件均成立时，FIOM 位存在于特定情况下：(a) 仿真设备具有应该是 I&#x2F;O 空间但实际上通过地址转换映射到主存储器的内存缓冲区，以及 (b) 从 U 模式访问该仿真设备涉及多个物理硬件。</p>
<p>如果无法采用半虚拟化，则在 S 模式下运行的Hypervisor（没有第 8 章的Hypervisor扩展的优势）可能需要模拟 U 模式的设备。如果同一个Hypervisor提供具有多个虚拟 HART 的虚拟机 (VM)，一对一映射到真实 HART，则多个 HART 可能会同时访问模拟设备，可能是因为：</p>
<p>(a) VM 内的客户操作系统将设备中断处理分配给一个 hart，同时该设备还可以由中断处理程序之外的另一个 hart 访问，或者 (b) 设备的控制（或部分控制）正在从一个 hart 迁移到另一个 hart，例如用于 VM 内的中断负载平衡。对于这种情况，VM 内的客户软件应像往常一样使用互斥锁和&#x2F;或处理器间中断来正确协调跨多个 hart 对（模拟）设备的访问，这在一定程度上需要执行 I&#x2F;O 栅栏。但是，如果某些设备“I&#x2F;O”实际上是主内存，而访客并不知道，那么这些 I&#x2F;O 栅栏可能还不够。设置 FIOM&#x3D;1 会修改这些栅栏（以及在 U 模式下执行的所有其他 I&#x2F;O 栅栏）以也包括主内存。</p>
<p>软件始终可以通过不使用主内存来模拟应该是 I&#x2F;O 空间的设备内存缓冲区来避免设置 FIOM。然而，这种选择通常需要捕获对模拟缓冲区的所有 U 模式访问，这可能会对性能产生显着影响。</p>
<p>FIOM 提供的替代方案实施起来足够便宜，我们认为值得支持，即使很少启用。</p>
</blockquote>
<p>CBZE 字段的定义将由即将推出的 Zicboz 扩展提供。在批准该延期之前，其在 senvcfg 内的分配可能会发生变化。</p>
<p>CBCFE 和 CBIE 字段的定义将由即将推出的 Zicbom 扩展提供。在批准该延期之前，它们在 senvcfg 中的分配可能会发生变化。</p>
<h3 id="4-1-11-Supervisor地址转换和保护寄存器-satp"><a href="#4-1-11-Supervisor地址转换和保护寄存器-satp" class="headerlink" title="4.1.11 Supervisor地址转换和保护寄存器 (satp)"></a>4.1.11 Supervisor地址转换和保护寄存器 (satp)</h3><p>satp 寄存器是一个 SXLEN 位读&#x2F;写寄存器，其格式如图 4.14（SXLEN&#x3D;32）和图 4.15（SXLEN&#x3D;64）所示，控制supervisor-mode地址转换和保护。</p>
<ul>
<li><p>该寄存器保存根页表的物理页号（<code>PPN</code>），即其supervisor physical addresses除以 4 KiB；</p>
</li>
<li><p>地址空间标识符（<code>ASID</code>），有助于基于每个地址空间的地址转换栅栏； </p>
</li>
<li><p><code>MODE</code> 字段，选择当前的地址转换方案。</p>
<p>有关访问该寄存器的更多详细信息，请参见第 3.1.6.5 节。</p>
</li>
</ul>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724161617963-1730798006987-64.png" alt="image-20230724161617963"></p>
<blockquote>
<p>在 satp 中存储 PPN，而不是物理地址，支持 RV32 大于 4 GiB 的物理地址空间。</p>
<p>satp.PPN 字段可能无法保存所有物理页号。一些平台标准可能对 satp.PPN 可能假设的值施加限制，例如，要求与主存储器相对应的所有物理页号都是可表示的。</p>
</blockquote>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724161653067-1730798006987-65.png" alt="image-20230724161653067"></p>
<blockquote>
<p>我们将<code>ASID</code>和页表基地址存储在同一CSR中，以允许在上下文切换时<strong>原子地更改</strong>这对地址。非原子地交换它们可能会用新的转换污染旧的虚拟地址空间，反之亦然。这种方法还略微降低了上下文切换的成本。</p>
</blockquote>
<p>表4.4显示了SXLEN&#x3D;32和SXLEN&#x3D;64时MODE字段的编码。当 MODE&#x3D;Bare 时，supervisor virtual addresses等于supervisor physical addresses，并且除了 3.7 节中描述的物理内存保护方案之外，没有额外的内存保护。要选择 MODE&#x3D;Bare，软件必须向 satp 的其余字段写入零（当 SXLEN&#x3D;32 时为bit 30-0，或当 SXLEN&#x3D;64 时为bit 59-0）。尝试在其余字段中选择具有非零模式的 MODE&#x3D;Bare 会对其余字段采用的值产生未指定的影响，并对地址转换和保护行为产生未指定的影响。</p>
<p>当SXLEN&#x3D;32时，MODE&#x3D;Bare和ASID[8:7]&#x3D;3对应的satp编码被指定供定制使用，而MODE&#x3D;Bare和ASID[8:7]$\neq$3对应的编码被保留以供未来标准使用。</p>
<p>当SXLEN&#x3D;64时，与MODE&#x3D;Bare对应的所有satp编码被保留以供将来的标准使用。</p>
<blockquote>
<p>该标准的 1.11 版规定，当 MODE&#x3D;Bare 时，satp 中的其余字段不起作用。保留这些字段有助于将来定义附加转换和保护模式，特别是在 RV32 中，现有 MODE 字段的所有模式都已分配给该模式。</p>
</blockquote>
<p>当 SXLEN&#x3D;32 时，MODE 的唯一有效设置是 Sv32，这是第 4.3 节中描述的分页虚拟内存方案。</p>
<p>当 SXLEN&#x3D;64 时，定义了三个分页虚拟内存方案：Sv39、Sv48 和 Sv57，分别在第 4.4、4.5 和 4.6 节中描述。另一种方案 Sv64 将在本规范的后续版本中定义。剩余的 MODE 设置保留供将来使用，并且可以定义 satp 中其他字段的不同解释。</p>
<p>实现不需要支持所有 MODE 设置，如果使用不支持的 MODE 写入 satp，则整个写入无效； satp 中的任何字段均未修改。</p>
<p>ASID 位数未指定，可能为零。所实现的 ASID 位的数量（称为 ASIDLEN）可以通过将 1 写入 ASID 字段中的每个位位置，然后读回 satp 中的值以查看 ASID 字段中的哪些位位置保持为 1 来确定。首先实现 ASID 的最低有效位：即，如果 ASIDLEN &gt; 0，则 ASID[ASIDLEN-1:0] 可写。 ASIDLEN 的最大值称为 ASIDMAX，对于 Sv32 为 9，对于 Sv39、Sv48 和 Sv57 为 16。</p>
<blockquote>
<p>对于许多应用程序来说，页面大小的选择会对性能产生重大影响。大页面大小会增加 TLB 范围并放松对虚拟索引、物理标记缓存的关联性约束。同时，大页面会加剧内部碎片，浪费物理内存以及可能的缓存容量。</p>
<p>经过深思熟虑，我们为 RV32 和 RV64 确定了 4 KiB 的常规页面大小。我们希望这一决定能够简化低级运行时软件和设备驱动程序的移植。现代操作系统中的透明超级页面支持改善了 TLB 到达（reach）问题 [2]。此外，多级 TLB 层次结构相对于其映射地址空间的多级高速缓存层次结构来说相当便宜（inexpensive）。</p>
</blockquote>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724162139046-1730798006987-66.png" alt="image-20230724162139046"></p>
<p>&#x3D;&#x3D;当有效特权模式为 S 模式或 U 模式时，satp 寄存器被视为活动的。&#x3D;&#x3D;当 satp 处于活动状态时，地址转换算法的执行可能仅使用给定的 satp 值开始。</p>
<blockquote>
<p>当 satp 不再活动时，不需要在 satp 处于活动状态时开始的转换完成或终止，除非执行与地址和 ASID 匹配的 SFENCE.VMA 指令。 SFENCE.VMA 指令必须用于确保通过 hart 对这些结构的后续隐式读取来观察对地址转换数据结构的更新。</p>
</blockquote>
<p>请注意，写入 satp 并不意味着页表更新和后续地址转换之间存在任何顺序约束，也不意味着地址转换缓存有任何失效。如果新地址空间的页表已被修改，或者 ASID 被重用，则可能需要在写入 satp 之后或在某些情况下之前执行 SFENCE.VMA 指令（请参见第 4.2.1 节）。</p>
<blockquote>
<p>在提供足够大的 ASID 空间的情况下，不强制执行在 satp 写入时刷新地址转换缓存，可以降低上下文切换的成本。</p>
</blockquote>
<h2 id="4-2-Supervisor-指令"><a href="#4-2-Supervisor-指令" class="headerlink" title="4.2 Supervisor 指令"></a>4.2 Supervisor 指令</h2><p>除了 3.3.2 节中定义的 SRET 指令外，还提供了一条新的超级用户级指令。</p>
<h3 id="4-2-1-Supervisor内存管理Fence指令"><a href="#4-2-1-Supervisor内存管理Fence指令" class="headerlink" title="4.2.1 Supervisor内存管理Fence指令"></a>4.2.1 Supervisor内存管理Fence指令</h3><p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724162609386-1730798006987-68.png" alt="image-20230724162609386"></p>
<p>Supervisor内存管理栅栏指令 SFENCE.VMA 用于将内存中内存管理数据结构的更新与当前执行同步。指令执行会导致对这些数据结构的隐式读写；然而，这些隐式引用通常没有相对于显式加载和存储进行排序。执行 SFENCE.VMA 指令可保证当前 RISC-V hart 可见的任何先前存储都排序在该 hart 中后续指令对内存管理数据结构的某些隐式引用之前。 SFENCE.VMA 排序的特定操作集由 rs1 和 rs2 确定，如下所述。 SFENCE.VMA 还用于使与 hart 关联的地址转换缓存中的条目无效（请参见第 4.3.2 节）。有关该指令行为的更多详细信息，请参见第 3.1.6.5 节和第 3.7.2 节。</p>
<blockquote>
<p>SFENCE.VMA 用于刷新与地址转换相关的任何本地硬件缓存。它被指定为栅栏而不是 TLB 刷新，以提供关于哪些指令受刷新操作影响的更清晰的语义，并支持更广泛的动态缓存结构和内存管理方案。更高权限级别还使用 SFENCE.VMA 来同步页表写入和地址转换硬件。</p>
</blockquote>
<p>SFENCE.VMA 仅命令本地 hart 对内存管理数据结构的隐式引用。</p>
<blockquote>
<p>因此，当内存管理数据结构被修改时，必须单独通知其他硬件。一种方法是使用 1) 本地数据栅栏以确保本地写入在全局范围内可见，然后 2) 对其他线程的处理器间中断，然后 3) 远程线程的中断处理程序中的本地 SFENCE.VMA，最后 4) 向原始线程发出操作已完成的信号。当然，这是 TLB 击落的 RISC-V 模拟。</p>
</blockquote>
<p>对于仅针对单个地址映射（即一页或超级页）修改转换数据结构的常见情况，rs1 可以指定该映射内的虚拟地址以仅影响该映射的转换栅栏。此外，对于仅针对单个地址空间标识符修改转换数据结构的常见情况，rs2 可以指定地址空间。 SFENCE.VMA 的行为取决于 rs1 和 rs2，如下所示：</p>
<ul>
<li>如果 rs1 &#x3D; x0 且 rs2 &#x3D; x0，则栅栏会对所有地址空间的任何级别页表进行的所有读取和写入进行排序。该栅栏还使所有地址空间的所有地址转换缓存条目无效。</li>
<li>如果 rs1 &#x3D; x0 且 rs2 $\neq$ x0，则栅栏会对任何级别的页表进行的所有读取和写入进行排序，但仅限于整数寄存器 rs2 标识的地址空间。对全局映射的访问（参见第 4.3.1 节）没有顺序。该栅栏还会使与整数寄存器 rs2 标识的地址空间匹配的所有地址转换高速缓存条目无效，包含全局映射的条目除外。</li>
<li>如果 rs1$\neq$ x0 且 rs2 &#x3D; x0，则对于所有地址空间，栅栏命令仅对与 rs1 中的虚拟地址相对应的叶页表条目进行读取和写入。对于所有地址空间，栅栏还会使包含与 rs1 中的虚拟地址相对应的叶页表条目的所有地址转换缓存条目无效。</li>
<li>如果 rs1$\neq$ x0 且 rs2 $\neq$ x0，则对于整数寄存器 rs2 标识的地址空间，栅栏命令仅对与 rs1 中的虚拟地址相对应的叶页表条目进行读取和写入。对全局映射的访问没有顺序。该栅栏还会使所有包含与 rs1 中的虚拟地址相对应的叶页表条目且与整数寄存器 rs2 标识的地址空间匹配的地址转换缓存条目无效，包含全局映射的条目除外。</li>
</ul>
<p>如果 rs1 中保存的值不是有效的虚拟地址，则 SFENCE.VMA 指令无效。在这种情况下不会引发任何异常。</p>
<p>当 rs2$\neq$x0 时，rs2 中保存的值的位 SXLEN-1:ASIDMAX 被保留以供将来的标准使用。在标准扩展定义它们的使用之前，它们应该被软件归零并被当前的实现忽略。此外，如果 ASIDLEN &lt; ASIDMAX，则实现应忽略 rs2 中保存的值的 ASIDMAX-1:ASIDLEN 位。</p>
<blockquote>
<p>过度防护始终是合法的，例如，仅基于 rs1 和&#x2F;或 rs2 中的位子集进行防护，和&#x2F;或简单地将所有 SFENCE.VMA 指令视为具有 rs1&#x3D;x0 和&#x2F;或 rs2&#x3D;x0。例如，更简单的实现可以忽略 rs1 中的虚拟地址和 rs2 中的 ASID 值，并始终执行全局隔离。当 rs1 中保存无效虚拟地址时不引发异常的选择有助于这种类型的简化。</p>
</blockquote>
<p>内存管理数据结构的隐式读取可以返回自包含该地址的最新 SFENCE.VMA 以来在任何时间都有效的地址的任何转换。SFENCE.VMA 隐含的排序不会以与标准 RVWMO 排序规则干净交互的方式将对内存管理数据结构的隐式读取和写入放入全局内存顺序中。特别地，尽管SFENCE.VMA将先前的显式访问排序在随后的隐式访问之前，并且那些隐式访问在其关联的显式访问之前排序，但是SFENCE.VMA不一定将全局存储器顺序中的先前的显式访问置于随后的显式访问之前。这些隐式加载也不需要遵守相对于先前加载或存储到同一地址的正常程序顺序语义。</p>
<blockquote>
<p>该规范的结果是，实现可以使用自包含该地址的最新 SFENCE.VMA 以来在任何时间都有效的地址的任何转换。特别是，如果修改了叶 PTE 但未执行包含的 SFENCE.VMA，则将使用旧翻译或新翻译，但选择是不可预测的。该行为在其他方面是明确定义的。</p>
<p>在传统的 TLB 设计中，多个条目可能会匹配单个地址，例如，如果未首先清除原始非叶 PTE 的有效位并执行 rs1&#x3D;x0 的 SFENCE.VMA，则将页面升级为超级页面。在这种情况下，适用类似的评论：使用旧的非叶 PTE 还是新的叶 PTE 是不可预测的，但行为是明确定义的。</p>
<p>该规范的另一个结果是，使用一组宽度小于 PTE 宽度的存储来更新 PTE 通常是不安全的，因为实现在任何时候读取 PTE 都是合法的，包括当只有部分存储生效时。</p>
</blockquote>
<blockquote>
<p>该规范允许缓存 V（有效）位清零的 PTE。必须编写操作系统来应对这种可能性，但要提醒实施者，急切地缓存无效的 PTE 会导致额外的页面错误，从而降低性能。</p>
</blockquote>
<p>实现必须仅对 satp 寄存器的当前内容或后续有效 (V&#x3D;1) 翻译数据结构条目所指向的翻译数据结构执行隐式读取，并且必须仅针对因指令执行而生成的隐式访问（而不是推测执行的隐式访问）引发异常。</p>
<p>对 sstatus 字段 SUM 和 MXR 的更改会立即生效，无需执行 SFENCE.VMA 指令。将 satp.MODE 从 Bare 更改为其他模式（反之亦然）也会立即生效，无需执行 SFENCE.VMA 指令。同样，对 satp.ASID 的更改会立即生效。</p>
<blockquote>
<p>以下常见情况通常需要执行 SFENCE.VMA 指令：</p>
<ul>
<li><p>当软件回收 ASID（即，将其与不同的页表重新关联）时，应首先使用回收的 ASID 更改 satp 以指向新页表，然后执行 SFENCE.VMA，并将 rs1&#x3D;x0 和 rs2 设置为回收的 ASID。或者，软件可以在将不同的 ASID 加载到 satp 时执行相同的 SFENCE.VMA 指令，前提是下次 satp 加载回收的 ASID 时，它会同时加载新的页表。</p>
</li>
<li><p>如果实现不提供 ASID，或者软件选择始终使用 ASID 0，则每次 satp 写入后，软件应使用 rs1&#x3D;x0 执行 SFENCE.VMA。在没有修改全局翻译的常见情况下，rs2 应设置为 x0 以外的寄存器，但其中包含值零，以便全局翻译不会被刷新。</p>
</li>
<li><p>如果软件修改非叶 PTE，则应以 rs1&#x3D;x0 执行 SFENCE.VMA。如果遍历路径上的任何 PTE 设置了 G 位，则 rs2 必须为 x0；否则，rs2 应设置为要修改翻译的 ASID。</p>
</li>
<li><p>如果软件修改了叶 PTE，则应执行 SFENCE.VMA，并将 rs1 设置为页面内的虚拟地址。如果遍历路径上的任何 PTE 设置了 G 位，则 rs2 必须为 x0；否则，rs2 应设置为要修改翻译的 ASID。</p>
</li>
<li><p>对于增加叶子 PTE 的权限以及将无效 PTE 更改为有效叶子的特殊情况，软件可以选择延迟执行 SFENCE.VMA。修改 PTE 后但执行 SFENCE.VMA 之前，将使用新权限或旧权限。在后一种情况下，可能会发生页面错误异常，此时软件应根据前面的要点执行 SFENCE.VMA。</p>
</li>
</ul>
</blockquote>
<p>如果 hart 使用地址转换缓存，则该缓存必须显示为该 hart 专用。特别是，ASID 的含义对于 hart 来说是本地的；软件可以选择使用相同的ASID来引用不同hart上的不同地址空间。</p>
<blockquote>
<p>未来的扩展可以将 ASID 重新定义为跨 SEE 的全局，从而启用共享翻译缓存和广播 TLB 击落的硬件支持等选项。然而，随着操作系统的发展，使用新颖的 ASID 管理技术显着减少 TLB 击落的范围，我们预计本地 ASID 方案因其简单性和可能更好的可扩展性而仍然具有吸引力。</p>
</blockquote>
<p>对于使 satp.MODE 只读为零（始终为裸）的实现，尝试执行 SFENCE.VMA 指令可能会引发非法指令异常。</p>
<h2 id="4-3-Sv32：基于页面的32位虚拟内存系统"><a href="#4-3-Sv32：基于页面的32位虚拟内存系统" class="headerlink" title="4.3 Sv32：基于页面的32位虚拟内存系统"></a>4.3 Sv32：基于页面的32位虚拟内存系统</h2><p>当 Sv32 写入 satp 寄存器中的 MODE 字段时（参见第 4.1.11 节），监控程序(supervisor operates)在 32 位分页虚拟内存系统中运行。在此模式下，通过遍历基数树页表将Supervisor和用户虚拟地址转换为Supervisor物理地址。当 SXLEN&#x3D;32 时支持 Sv32，并且设计为包含足以支持现代基于 Unix 的操作系统的机制。</p>
<blockquote>
<p>最初的 RISC-V 分页虚拟内存架构被设计为支持现有操作系统的简单实现。我们设计了页表布局来支持硬件页表遍历器。软件 TLB 重新填充是高性能系统的性能瓶颈，对于解耦的专用协处理器来说尤其麻烦。实现可以选择使用机器模式陷阱处理程序来实现软件 TLB 重新填充，作为 M 模式的扩展。</p>
</blockquote>
<blockquote>
<p>一些 ISA 在架构上公开了虚拟索引、物理标记（VIPT）的高速缓存，因为通过不同虚拟地址对同一物理地址的访问可能不连贯，除非虚拟地址集中位于同一高速缓存。隐含地，该规范不允许在架构上公开此类行为。</p>
</blockquote>
<h3 id="4-3-1-寻址和内存保护"><a href="#4-3-1-寻址和内存保护" class="headerlink" title="4.3.1 寻址和内存保护"></a>4.3.1 寻址和内存保护</h3><p>Sv32 实现支持 32 位虚拟地址空间，分为 4 KiB 页。 Sv32虚拟地址被划分为虚拟页号（VPN）和页偏移量，如图4.16所示。当在 satp 寄存器的 MODE 字段中选择 Sv32 虚拟内存模式时，supervisor virtual addresses通过<strong>两级页表</strong>转换为supervisor physical addresses。 20 位 VPN 被转换为 22 位物理页号 (PPN)，而 12 位页偏移量则未转换。然后使用任何物理内存保护结构（第 3.7 节）检查生成的Supervisor 物理地址，然后直接转换为机器级物理地址。如有必要，Supervisor级物理地址将被零扩展至实现中找到的物理地址位数。</p>
<blockquote>
<p>例如，考虑支持 34 位物理地址的 RV32 系统。当satp.MODE的值为Sv32时，直接产生34位物理地址，因此不需要零扩展。当 satp.MODE 的值为 Bare 时，32 位虚拟地址将被转换（未修改）为 32 位物理地址，然后该物理地址被零扩展为 34 位机器级物理地址。</p>
</blockquote>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724164250374-1730798006987-67.png" alt="image-20230724164250374"></p>
<p>Sv32 页表由 2^10^ 个页表条目 (PTE) 组成，每个条目四个字节。页表的大小恰好是页的大小，并且必须始终与页边界对齐。根页表的物理页号存储在satp寄存器中。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724164311147-1730798006987-69.png" alt="image-20230724164311147"></p>
<p>Sv32 的 PTE 格式如图 4.18 所示。 </p>
<p><strong>V</strong>位表示PTE是否有效；如果为 0，则 PTE 中的所有其他位都无关紧要，并且可以由软件自由使用。</p>
<p>权限位 <strong>R、W</strong> 和 <strong>X</strong> 分别指示该页是否可读、可写和可执行。当三个都为零时，PTE是指向下一级页表的指针；否则，它是叶子 PTE。可写页面也必须标记为可读；相反的组合保留供将来使用。表 4.5 总结了权限位的编码。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724164338249-1730798006987-70.png" alt="image-20230724164338249"></p>
<ul>
<li>尝试从没有执行权限的页面获取指令会引发获取页面错误异常。</li>
<li>尝试执行有效地址位于没有读权限的页面内的加载或加载保留指令会引发加载页面错误异常。</li>
<li>尝试执行有效地址位于无写权限的页内的存储、条件存储或 AMO 指令会引发存储页错误异常。</li>
</ul>
<blockquote>
<p>AMO 永远不会引发加载页面错误异常。由于任何不可读的页面也是不可写的，因此尝试在不可读的页面上执行 AMO 总是会引发存储页面错误异常。</p>
</blockquote>
<p><strong>U 位指示该页是否可以由User mode访问</strong>。 U模式软件只能在U&#x3D;1时访问该页面。如果设置了 sstatus 寄存器中的 SUM 位，则管理模式软件也可以访问 U&#x3D;1 的页面。然而，Supervisor代码通常在 SUM 位清零的情况下运行，在这种情况下，Supervisor代码将在访问User mode页面时出错。无论 SUM 如何，Supervisor都不能在 U&#x3D;1 的页面上执行代码。</p>
<blockquote>
<p>另一种 PTE 格式将支持Supervisor和用户的不同权限。我们省略了这个功能，因为它对于 SUM 机制来说在很大程度上是多余的（参见第 4.1.1.2 节），并且需要 PTE 中更多的编码空间。</p>
</blockquote>
<p><strong>G位指定全局映射</strong>。全局映射是存在于所有地址空间中的映射。对于非叶 PTE，全局设置意味着页表后续级别中的所有映射都是全局的。请注意，未能将全局映射标记为全局只会降低性能，而将非全局映射标记为全局则是一个软件错误，在切换到具有该地址范围的不同非全局映射的地址空间后，可能会不可预测地导致使用任一映射。</p>
<blockquote>
<p>全局映射不需要冗余地存储在多个 ASID 的地址转换缓存中。此外，当使用 rs2$\neq$x0 执行 SFENCE.VMA 指令时，不需要从本地地址转换缓存中刷新它们。</p>
</blockquote>
<p><strong>RSW</strong> 字段保留供监控软件使用；实现应忽略该字段。</p>
<p>每个叶 PTE 包含一个<strong>已访问位</strong> (A) 和一个<strong>脏位</strong> (D)。 A 位指示自上次清除 A 位以来已读取、写入或提取虚拟页。 D 位指示自上次清除 D 位以来虚拟页已被写入。</p>
<p>允许使用两种方案来管理 A 和 D 位：</p>
<ul>
<li><p>当访问虚拟页且 A 位清零时，或写入虚拟页且 D 位清零时，将引发页错误异常。</p>
</li>
<li><p>当访问虚拟页且 A 位清零时，或写入虚拟页且 D 位清零时，实现会设置 PTE 中的相应位。 PTE 更新相对于对 PTE 的其他访问必须是原子的，并且必须以原子方式检查 PTE 是否有效并授予足够的权限。 A 位的更新可以作为推测的结果来执行，但是对 D 位的更新必须是准确的（即，不是推测的），并且由本地 hart 按程序顺序观察。此外，PTE 更新必须不晚于显式内存访问或本地 hart 对该虚拟页的任何后续显式内存访问出现在全局内存顺序中。由 FENCE 指令提供的加载和存储排序以及原子指令上的获取&#x2F;释放位也对与远程 Hart 观察到的那些加载和存储关联的 PTE 更新进行排序。<br>对于导致更新的显式内存访问，PTE 更新不需要是原子的，并且序列是可中断的。然而，在 PTE 更新全局可见之前，hart 不得执行显式内存访问。</p>
</li>
</ul>
<p>系统中的所有 hart 必须采用彼此相同的 PTE 更新方案。</p>
<blockquote>
<p>该规范的先前版本要求 PTE A 位更新准确，但允许 A 位作为推测的结果进行更新，从而简化了地址转换预取器的实现。系统软件通常使用A位作为页面替换策略提示，但不要求功能正确性的精确性。另一方面，D 位更新仍然需要准确并按程序顺序执行，因为 D 位会影响页面逐出的功能正确性。</p>
<p>当然，仍然允许实现仅以精确的方式执行 A 和 D 位更新。</p>
<p>在这两种情况下，要求原子性可确保 PTE 更新不会被其他对页表的干预写入中断，因为此类中断可能会导致在已重用于其他目的的 PTE 上、在已回收用于其他目的的内存上设置 A&#x2F;D 位，等等。简单的实现可能会生成页面错误异常。</p>
<p>A 和 D 位永远不会被实现清除。如果监控软件不依赖于访问和&#x2F;或脏位，例如如果它不将内存页交换到辅助存储，或者如果这些页用于映射 I&#x2F;O 空间，则应始终在 PTE 中将它们设置为 1 以提高性能。</p>
</blockquote>
<p>任何级别的 PTE 都可以是叶 PTE，因此除了 4 KiB 页面之外，Sv32 还支持 4 MiB 兆页。</p>
<p>巨型页面必须在虚拟和物理上与 4 MiB 边界对齐；如果物理地址未充分对齐，则会引发页错误异常。</p>
<p>对于非叶 PTE，D、A 和 U 位保留供未来标准使用。在标准扩展定义它们的使用之前，它们必须由软件清除以实现向前兼容性。</p>
<p>对于基于页的虚拟内存和“A”标准扩展的实现，LR&#x2F;SC 保留集必须完全位于单个基页内（即自然对齐的 4 KiB 区域）。</p>
<h3 id="4-3-2-虚拟地址转换过程"><a href="#4-3-2-虚拟地址转换过程" class="headerlink" title="4.3.2 虚拟地址转换过程"></a>4.3.2 虚拟地址转换过程</h3><p>虚拟地址 va 转换为物理地址 pa 如下：</p>
<ol>
<li><p>令 a 为 satp.ppn × PAGESIZE，并令 i &#x3D; LEVELS − 1。（对于 Sv32，PAGESIZE&#x3D;2^12^ 且 LEVELS&#x3D;2。）satp 寄存器必须处于活动状态，即有效特权模式必须为 S 模式或 U 模式。</p>
</li>
<li><p>令pte为地址a+va.vpn[i]×PTESIZE处的PTE的值。 （对于 Sv32，PTESIZE&#x3D;4。）如果访问 pte 违反了 PMA 或 PMP 检查，则引发与原始访问类型相对应的访问错误异常。</p>
</li>
<li><p>如果 pte.v &#x3D; 0，或者 pte.r &#x3D; 0 且 pte.w &#x3D; 1，或者如果在 pte 内设置了为未来标准使用保留的任何位或编码，则停止并引发与原始访问类型相对应的页错误异常。</p>
</li>
<li><p>否则，PTE 有效。如果pte.r &#x3D; 1或pte.x &#x3D; 1，则转至步骤5。否则，该PTE是指向页表下一级的指针。令 i &#x3D; i − 1。如果 i &lt; 0，则停止并引发与原始访问类型相对应的页面错误异常。否则，令 a &#x3D; pte.ppn × PAGESIZE 并转到步骤 2。</p>
</li>
<li><p>找到了叶子PTE。给定当前特权模式以及 mstatus 寄存器的 SUM 和 MXR 字段的值，确定 pte.r、pte.w、pte.x 和 pte.u 位是否允许请求的内存访问。如果不是，则停止并引发与原始访问类型相对应的页面错误异常。</p>
</li>
<li><p>如果 i &gt; 0 并且 pte.ppn[i − 1 : 0] ̸&#x3D; 0，这是一个未对齐的超级页面；停止并引发与原始访问类型相对应的页面错误异常。</p>
</li>
<li><p>如果 pte.a &#x3D; 0，或者原始内存访问是存储并且 pte.d &#x3D; 0，则引发与原始访问类型相对应的页错误异常，或者：</p>
<ul>
<li>如果对 pte 的存储违反了 PMA 或 PMP 检查，则引发与原始访问类型相对应的访问错误异常。</li>
<li>以原子方式执行以下步骤：<ul>
<li>将 pte 与地址 a + va.vpn[i] × PTESIZE 处的 PTE 值进行比较。</li>
<li>如果值匹配，则将 pte.a 设置为 1，如果原始内存访问是存储，则还将 pte.d 设置为 1。</li>
<li>如果比较失败，返回步骤2</li>
</ul>
</li>
</ul>
</li>
<li><p>翻译成功了。转换后的物理地址如下：</p>
<ul>
<li>pa.pgoff &#x3D; va.pgoff。</li>
<li>如果 i &gt; 0，则这是超级页转换，并且 pa.ppn[i − 1 : 0] &#x3D; va.vpn[i − 1 : 0]。</li>
<li>pa.ppn[级别 − 1 : i] &#x3D; pte.ppn[级别 − 1 : i]。</li>
</ul>
</li>
</ol>
<p>该算法中对地址转换数据结构的所有隐式访问都是使用宽度 PTESIZE 执行的。</p>
<blockquote>
<p>例如，这意味着 Sv48 实现不能使用两个单独的 4B 读取来非原子地访问单个 8B PTE，并且该实现执行的 A&#x2F;D 位更新被视为原子更新整个 PTE，而不仅仅是单独更新 A 和&#x2F;或 D 位（即使 PTE 值不会以其他方式更改）。</p>
</blockquote>
<p>步骤 2 中隐式地址转换读取的结果可以保存在只读、不连贯的地址转换高速缓存中，但不与其他 hart 共享。地址转换高速缓存可以保存任意数量的条目，包括相同地址和ASID的任意数量的条目。如果与条目关联的 ASID 与步骤 0 中加载的 ASID 匹配或者如果条目与全局映射关联，则地址转换高速缓存中的条目可以满足后续步骤 2 的读取。为了确保隐式读取观察对相同内存位置的写入，必须在写入后执行 SFENCE.VMA 指令以刷新相关的缓存翻译。</p>
<p>步骤 7 中不能使用地址转换缓存；访问过的位和脏位只能直接在内存中更新。</p>
<blockquote>
<p>同一地址允许多个地址转换缓存条目共存。这代表了这样一个事实：在传统的 TLB 层次结构中，如果例如将页面升级为超级页面而没有首先清除原始非叶 PTE 的有效位并执行 rs1&#x3D;x0 的 SFENCE.VMA，或者如果在层次结构的给定级别并行存在多个 TLB，则多个条目可能会匹配单个地址。在这种情况下，就像在写入内存管理表和随后隐式读取同一地址之间不执行 SFENCE.VMA 一样：无法预测是使用旧的非叶 PTE 还是新的叶 PTE，但行为是明确定义的。</p>
</blockquote>
<p>只要 satp 处于活动状态（如第 4.1.11 节中所定义），实现还可以随时对任何虚拟地址推测性地执行地址转换算法。这种推测执行具有预填充地址转换高速缓存的效果。</p>
<p>地址转换算法的推测执行的行为与算法的非推测执行相同，只是它们不能设置 PTE 的脏位，它们不能触发异常，并且如果自算法的推测执行开始以来，地址转换高速缓存条目已被 hart 执行的任何 SFENCE.VMA 指令使这些条目无效，则它们不得创建地址转换高速缓存条目。</p>
<blockquote>
<p>例如，开始翻译算法的非推测性和推测性执行、读取 2 级页表、在 hart 执行带有 rs1&#x3D;rs2&#x3D;x0 的 SFENCE.VMA 时暂停，然后恢复使用现已过时的 2 级 PTE 都是非法的，因为后续隐式读取可能会用过时的 PTE 填充地址翻译缓存。</p>
<p>因此，在许多实现中，带有 rs1&#x3D;x0 的 SFENCE.VMA 指令将终止所有先前启动的地址转换算法的推测执行（对于指定的 ASID，如果适用），或者只是等待它们完成（在这种情况下，创建的任何地址转换缓存条目将被 SFENCE.VMA 酌情无效）。同样，rs1̸&#x3D;x0 的 SFENCE.VMA 指令通常必须确保防止先前启动的地址转换算法（针对指定的 ASID，如果适用）的推测执行创建映射叶 PTE 的新地址转换缓存条目，或者等待它们完成。</p>
<p>允许任意提前和推测性地读取转换数据结构的实现的结果是，在任何时候，通过执行算法可到达的所有页表条目都可以被加载到地址转换高速缓存中。</p>
<p>尽管将页表放置在非幂等内存中并不常见，但并没有明确禁止这样做。由于该算法可能只触及从 satp 中指示的根页表可到达的页表，因此实现的页表遍历器将触及的地址范围完全在Supervisor控制之下。</p>
</blockquote>
<blockquote>
<p>该算法不承认在具有较窄物理地址的实现中忽略高阶 PPN 位的可能性。</p>
</blockquote>
<h2 id="4-4-Sv39：基于页面的39位虚拟内存系统"><a href="#4-4-Sv39：基于页面的39位虚拟内存系统" class="headerlink" title="4.4 Sv39：基于页面的39位虚拟内存系统"></a>4.4 Sv39：基于页面的39位虚拟内存系统</h2><p>本节介绍 SXLEN&#x3D;64 的简单分页虚拟内存系统，它支持 39 位虚拟地址空间。 Sv39的设计遵循Sv32的整体方案，本节仅详细介绍方案之间的差异。</p>
<blockquote>
<p>我们为 RV64 指定了多个虚拟内存系统，以缓解提供大地址空间和最小化地址转换成本之间的紧张关系。对于许多系统来说，512 GiB 的虚拟地址空间就足够了，因此 Sv39 就足够了。 Sv48 将虚拟地址空间增加到 256 TiB，但增加了专用于页表的物理内存容量、页表遍历的延迟以及存储虚拟地址的硬件结构的大小。 Sv57 进一步增加了虚拟地址空间、页表容量要求和转换延迟。</p>
</blockquote>
<h3 id="4-4-1-寻址和内存保护"><a href="#4-4-1-寻址和内存保护" class="headerlink" title="4.4.1 寻址和内存保护"></a>4.4.1 寻址和内存保护</h3><p>Sv39 实现支持 39 位虚拟地址空间，分为 4 KiB 页。 Sv39 地址的分区如图 4.19 所示。取指令地址以及加载和存储有效地址为 64 位，必须使第 63-39 位全部等于第 38 位，否则将发生页错误异常。 27 位 VPN 通过三级页表转换为 44 位 PPN，而 12 位页面偏移量则不进行转换。</p>
<blockquote>
<p>当在较窄和较宽的地址之间进行映射时，RISC-V 将较窄的物理地址零扩展为较宽的大小。 64 位虚拟地址和 Sv39 的 39 位可用地址空间之间的映射不是基于零扩展，而是遵循一种根深蒂固的约定，该约定允许操作系统使用全尺寸（64 位）虚拟地址的一个或几个最高有效位来快速区分用户和Supervisor地址区域。</p>
</blockquote>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724171650493-1730798006987-71.png" alt="image-20230724171650493"></p>
<p>Sv39 页表包含 2^9^ 个页表条目 (PTE)，每个条目八个字节。页表的大小恰好是页的大小，并且必须始终与页边界对齐。根页表的物理页号存储在 satp 寄存器的 PPN 字段中。</p>
<blockquote>
<p>Sv39 的 PTE 格式如图 4.21 所示。位 9-0 的含义与 Sv32 相同。</p>
<ul>
<li>位 63 保留供第 5 章中的 Svnapot 扩展使用。如果未实现 Svnapot，则位 63 保持保留，并且必须由软件清零以实现前向兼容性，否则会引发页错误异常。</li>
<li>位 62-61 保留供第 6 章中的 Svpbmt 扩展使用。如果未实现 Svpbmt，则位 62-61 保持保留，并且必须由软件清零以实现前向兼容性，否则会引发页错误异常。</li>
<li>位 60-54 保留供未来标准使用，并且在某些标准扩展定义其使用之前，必须由软件清零以实现前向兼容性。如果设置了这些位中的任何一个，则会引发页面错误异常。</li>
</ul>
</blockquote>
<p>任何级别的 PTE 都可以是叶 PTE，因此除了 4 KiB 页面之外，Sv39 还支持 2 MiB 兆页和 1 GiB 千兆页，每个页都必须在虚拟和物理上与等于其大小的边界对齐。如果物理地址未充分对齐，则会引发页错误异常。</p>
<p>虚拟到物理地址转换的算法与第 4.3.2 节中的相同，除了 LEVELS 等于 3 并且 PTESIZE 等于 8。</p>
<h2 id="4-5-Sv48：基于页面的48位虚拟内存系统"><a href="#4-5-Sv48：基于页面的48位虚拟内存系统" class="headerlink" title="4.5 Sv48：基于页面的48位虚拟内存系统"></a>4.5 Sv48：基于页面的48位虚拟内存系统</h2><p>本节介绍 SXLEN&#x3D;64 的简单分页虚拟内存系统，它支持 48 位虚拟地址空间。 Sv48 适用于 39 位虚拟地址空间不足的系统。它紧密遵循Sv39的设计，只是增加了一层额外的页表，因此本章仅详细介绍两种方案之间的差异。</p>
<p>支持 Sv48 的实现也必须支持 Sv39。</p>
<blockquote>
<p>支持 Sv48 的系统也可以基本免费支持 Sv39，因此应该这样做以保持与采用 Sv39 的监控软件的兼容性。</p>
</blockquote>
<h3 id="4-5-1-寻址和内存保护"><a href="#4-5-1-寻址和内存保护" class="headerlink" title="4.5.1 寻址和内存保护"></a>4.5.1 寻址和内存保护</h3><p>Sv48 实现支持 48 位虚拟地址空间，分为 4 KiB 页。 Sv48 地址的分区如图 4.22 所示。取指令地址以及加载和存储有效地址为 64 位，必须使第 63-48 位都等于第 47 位，否则将发生页错误异常。 36 位 VPN 通过四级页表转换为 44 位 PPN，而 12 位页偏移量则未转换。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724172731223-1730798006987-72.png" alt="image-20230724172731223"></p>
<p>Sv48 的 PTE 格式如图 4.24 所示。位 63-54 和 9-0 的含义与 Sv39 相同。任何级别的 PTE 都可以是叶 PTE，因此除了 4 KiB 页面之外，Sv48 还支持 2 MiB megapages、1 GiB gigapages 和 512 GiB terapages，其中每个页面都必须在虚拟和物理上与等于其大小的边界对齐。如果物理地址未充分对齐，则会引发页错误异常。</p>
<p>虚拟到物理地址转换的算法与第 4.3.2 节中的相同，除了 LEVELS 等于 4 并且 PTESIZE 等于 8。</p>
<h2 id="4-6-Sv57：基于页面的57位虚拟内存系统"><a href="#4-6-Sv57：基于页面的57位虚拟内存系统" class="headerlink" title="4.6 Sv57：基于页面的57位虚拟内存系统"></a>4.6 Sv57：基于页面的57位虚拟内存系统</h2><p>本节介绍为 RV64 系统设计的简单分页虚拟内存系统，该系统支持 57 位虚拟地址空间。 Sv57 适用于 48 位虚拟地址空间不足的系统。它紧密遵循Sv48的设计，只是增加了一层额外的页表，因此本章仅详细介绍两种方案之间的差异。</p>
<p>支持 Sv57 的实现也必须支持 Sv48。</p>
<blockquote>
<p>支持 Sv57 的系统也可以基本无成本支持 Sv48，因此应该这样做以保持与采用 Sv48 的监控软件的兼容性。</p>
</blockquote>
<h3 id="4-6-1-寻址和内存保护"><a href="#4-6-1-寻址和内存保护" class="headerlink" title="4.6.1 寻址和内存保护"></a>4.6.1 寻址和内存保护</h3><p>Sv57 实现支持 57 位虚拟地址空间，分为 4 KiB 页。 Sv57 地址的分区如图 4.25 所示。取指令地址以及加载和存储有效地址为 64 位，必须使第 63-57 位全部等于第 56 位，否则将发生页错误异常。 45 位 VPN 通过五级页表转换为 44 位 PPN，而 12 位页偏移量则不进行转换。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230724183615160-1730798006987-73.png" alt="image-20230724183615160"></p>
<p>Sv57 的 PTE 格式如图 4.27 所示。位 63-54 和 9-0 的含义与 Sv39 相同。任何级别的 PTE 都可以是叶 PTE，因此除了 4 KiB 页外，Sv57 还支持 2 MiB megapages、1 GiB gigapages、512 GiB terapages 和 256 TiB petapages，其中每个页必须在虚拟和物理上与等于其大小的边界对齐。如果物理地址未充分对齐，则会引发页错误异常。</p>
<p>虚拟到物理地址转换的算法与第 4.3.2 节中的相同，除了 LEVELS 等于 5 并且 PTESIZE 等于 8。</p>
<h1 id="5-NAPOT-翻译连续性的“Svnapot”标准扩展，版本-1-0"><a href="#5-NAPOT-翻译连续性的“Svnapot”标准扩展，版本-1-0" class="headerlink" title="5. NAPOT 翻译连续性的“Svnapot”标准扩展，版本 1.0"></a>5. NAPOT 翻译连续性的“Svnapot”标准扩展，版本 1.0</h1><p>在 Sv39、Sv48 和 Sv57 中，当 PTE 的 N&#x3D;1 时，PTE 表示的转换是一系列连续虚拟到物理转换的一部分，PTE 位 5-0 具有相同的值。此类范围必须具有大于基本页大小的自然对齐 2 次方 (NAPOT) 粒度。</p>
<p>Svnapot 扩展依赖于 Sv39。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230725085323917-1730798006987-74.png" alt="image-20230725085323917"></p>
<p>NAPOT PTE 的行为与第 4.3.2 节中的地址转换算法中的非 NAPOT PTE 相同，但以下情况除外：</p>
<p>如果根据表 5.1 pte 中的编码有效，则 NAPOT PTE 的隐式读取将返回 pte 的副本，而不是返回 pte 的原始值，其中 pte.ppn[pte.napot_bits − 1 : 0] 被 vpn[i][pte.napot_bits − 1 : 0] 替换。如果根据表 5.1 保留 pte 中的编码，则必须引发页错误异常。</p>
<p>NAPOT 页表条目的隐式读取可能会创建地址转换缓存条目，将 a + va.vpn[j] × PTESIZE 映射到 pte 的副本，其中 pte.ppn[pte.napot_bits − 1 : 0] 被 vpn[0][pte.napot_bits − 1 : 0] 替换，对于任何或所有 j，使得 j[8 : napot_bits] &#x3D; i[8 : napot_bits]，全部用于标识的地址空间在由步骤 0 加载的 satp 中。</p>
<blockquote>
<p>NAPOT PTE 的动机是它可以作为表示连续区域的一个或多个条目缓存在 TLB 中，就好像它是由单个翻译覆盖的单个（大）页面一样。这种压缩在某些场景下可以帮助缓解 TLB 压力。该编码旨在适应预先存在的 Sv39、Sv48 和 Sv57 PTE 格式，以免破坏选择不实施该方案的现有实施或设计。它的设计也是为了不使地址转换算法的定义复杂化。</p>
<p>地址转换高速缓存抽象捕获由于创建覆盖整个 NAPOT 区域的单个 TLB 条目而产生的行为。它还被设计为与支持 NAPOT PTE 的实现保持一致，方法是将 NAPOT 区域分割为覆盖任何较小的二次幂区域大小的 TLB 条目。例如，64 KiB NAPOT PTE 可能会触发创建 16 个标准 4 KiB TLB 条目，所有内容都具有从 NAPOT PTE 生成的内容（即使其他 4 KiB 区域的 PTE 具有不同的内容）。</p>
<p>在典型的使用场景中，同一区域中的 NAPOT PTE 将具有相同的属性、相同的 PPN 以及相同的 5-0 位值。 RSW 保留用于监控软件控制。操作系统和&#x2F;或Supervisor有责任以这样的方式配置页表，使得 NAPOT PTE 与重叠相同地址范围的其他 NAPOT 或非 NAPOT PTE 之间不存在不一致。如果需要进行更新，操作系统通常应首先将所有 PTE 标记为无效，然后发出覆盖范围内所有 4 KiB 区域的 SFENCE.VMA 指令（通过 rs1&#x3D;x0 的单个 SFENCE.VMA，或 rs1̸&#x3D;x0 的多个 SFENCE.VMA 指令），然后更新 PTE，如第 4.2.1 节中所述，除非已知任何不一致是良性的。如果确实存在任何不一致，则效果与错误使用 SFENCE.VMA 时的效果相同：将选择其中一种翻译，但该选择是不可预测的。</p>
<p>如果一个实现选择使用 NAPOT PTE（或其缓存版本），它可能根本不会参考第 4.3.2 节中的算法直接指定的 PTE。因此，即使在典型使用情况下，同一地址范围的所有映射中的 D 和 A 位也可能不相同。操作系统必须查询页面的所有 NAPOT 别名以确定该页面是否已被访问和&#x2F;或是否已脏。如果操作系统手动设置页面的 A 和&#x2F;或 D 位，建议操作系统也适当地为其他 NAPOT 别名设置 A 和&#x2F;或 D 位，以避免不必要的陷阱。</p>
<p>与普通 PTE 一样，TLB 可以缓存 V（有效）位清零的 NAPOT PTE。</p>
<p>根据需要，NAPOT方案将来可以扩展到其他中间页大小和&#x2F;或页表的其他级别。该编码旨在在需要时适应其他 NAPOT 大小。例如：</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230725085727616-1730798006987-75.png" alt="image-20230725085727616"></p>
<p>在这种情况下，实现可能支持也可能不支持所有选项。此扩展的可发现性机制将被扩展，以允许系统软件确定支持哪些大小。</p>
<p>其他大小可能仍然被故意排除，以便未用于指示有效 NAPOT 区域大小的 PPN 位（例如，pte.ppn[i] 的最低有效位）可以在将来重新用于其他用途。</p>
<p>但是，如果事实证明更细粒度的中间页面大小支持没有用，我们首先选择仅标准化 64 KiB 支持。</p>
</blockquote>
<h1 id="6-“Svpbmt”基于页的内存类型的标准扩展，版本-1-0"><a href="#6-“Svpbmt”基于页的内存类型的标准扩展，版本-1-0" class="headerlink" title="6. “Svpbmt”基于页的内存类型的标准扩展，版本 1.0"></a>6. “Svpbmt”基于页的内存类型的标准扩展，版本 1.0</h1><p>在 Sv39、Sv48 和 Sv57 中，叶页表条目的第 62-61 位指示使用基于页面的内存类型，这些类型会覆盖关联内存页面的 PMA。 PBMT 位的编码如表 6.1 所示。</p>
<p>Svpbmt 扩展依赖于 Sv39。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230725090209390-1730798006987-76.png" alt="image-20230725090209390"></p>
<blockquote>
<p>未来的扩展可能会提供更多和&#x2F;或更细粒度的控制，以控制哪些 PMA 可以被覆盖。</p>
</blockquote>
<p>对于非叶 PTE，位 62-61 保留供未来标准使用。在标准扩展定义它们的使用之前，必须由软件清除它们以实现向前兼容性，否则会引发页面错误异常。</p>
<p>当 PBMT 设置将主内存页面覆盖为 I&#x2F;O 时（反之亦然），对此类页面的内存访问遵循最终有效属性的内存排序规则，如下所示。</p>
<p>如果页面的底层物理内存属性是 I&#x2F;O，并且该页面的 PBMT&#x3D;NC，则对该页面的访问遵循 RVWMO。然而，出于 FENCE、.aq 和 .rl 的目的，对此类页面的访问被视为 I&#x2F;O 和主内存访问。</p>
<p>如果页面的底层物理内存属性是主内存，并且该页面具有 PBMT&#x3D;IO，则相对于对物理主内存的其他访问以及对具有 PBMT&#x3D;IO 的页面的其他访问，对该页面的访问遵循强通道 0 I&#x2F;O 排序规则。然而，出于 FENCE、.aq 和 .rl 的目的，对此类页面的访问被视为 I&#x2F;O 和主内存访问。</p>
<blockquote>
<p>如果使用 PBMT&#x3D;NC 映射地址范围，则依赖 I&#x2F;O 强排序规则编写的设备驱动程序将无法正确运行。因此，不鼓励这种配置。使用 PBMT&#x3D;NC 映射物理 I&#x2F;O 区域通常仍然有用，以便可以执行写组合和推测访问。如果应用得当，此类优化可能会提高性能。</p>
</blockquote>
<p>当 Svpbmt 与非零 PBMT 编码一起使用时，同一物理页的多个虚拟别名可能同时存在且具有不同的内存属性。还可以通过启用了 Svpbmt 的 PTE 进行 U 模式或 S 模式映射，以观察给定物理内存区域的不同内存属性，而不是通过 M 模式或当 MODE&#x3D;Bare 执行对同一页面的并发访问。在这种情况下，属性规定的行为（包括一致性，否则不受影响）可能会被违反。</p>
<p>使用不可缓存的不同属性（例如 NC 和 IO）访问同一位置不会导致一致性损失，但可能会导致比通常保证的更严格属性更弱的内存排序。在此类访问之间执行栅栏 iorw, iorw 指令足以防止内存顺序丢失。</p>
<p>使用不同的可缓存性属性访问同一位置可能会导致一致性丧失。在此类访问之间执行以下序列可以防止一致性丢失和内存顺序丢失：fence iorw、iorw，后跟 cbo.flush 到该位置的地址，后跟 fence iorw、iorw。</p>
<blockquote>
<p>由此可见，如果稍后可能使用原始属性引用同一位置，则必须事先重复此序列。</p>
</blockquote>
<blockquote>
<p>在某些情况下，较弱的序列可能足以防止失去连贯性。这些情况将在 RVWMO 内存模型与 Zicbom 扩展中的指令的交互即将正式化之后详细说明。</p>
</blockquote>
<p>当在 H 扩展中启用两阶段地址转换时，基于页的内存类型也会在两个阶段中应用。首先，如果 hgatp.MODE 不等于 0，则非零G-stage  PTE PBMT 位将覆盖 PMA 中的属性以生成中间属性集。否则，PMA 充当中间属性。其次，如果 vsatp.MODE 不等于 0，则非零 VS 阶段 PTE PBMT 位会覆盖中间属性，以生成对相关页面的访问所使用的最终属性集。否则，中间属性将用作最终属性集。</p>
<h1 id="7-细粒度地址转换缓存失效的“Svinval”标准扩展，版本-1-0"><a href="#7-细粒度地址转换缓存失效的“Svinval”标准扩展，版本-1-0" class="headerlink" title="7. 细粒度地址转换缓存失效的“Svinval”标准扩展，版本 1.0"></a>7. 细粒度地址转换缓存失效的“Svinval”标准扩展，版本 1.0</h1><p>Svinval 扩展将 SFENCE.VMA、HFENCE.VVMA 和 HFENCE.GVMA 指令拆分为更细粒度的失效和排序操作，这些操作可以在某些类的高性能实现上更有效地批处理或流水线化。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230725091626425-1730798006987-77.png" alt="image-20230725091626425"></p>
<p>SINVAL.VMA 指令使具有相同 rs1 和 rs2 值的 SFENCE.VMA 指令无效的任何地址转换高速缓存条目无效。然而，与 SFENCE.VMA 不同，SINVAL.VMA 指令仅相对于 SFENCE.VMA、SFENCE.W.INVAL 和 SFENCE.INVAL.IR 指令进行排序，如下定义。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230725091639381-1730798006987-78.png" alt="image-20230725091639381"></p>
<p>SFENCE.W.INVAL 指令保证当前 RISC-V hart 可见的任何先前存储都在同一 hart 执行的后续 SINVAL.VMA 指令之前排序。SFENCE.INVAL.IR 指令保证当前 hart 执行的任何先前的 SINVAL.VMA 指令都排在该 hart 对内存管理数据结构的后续隐式引用之前。</p>
<p>当由单个 hart 按顺序（但不一定连续）执行时，序列 SFENCE.W.INVAL、SINVAL.VMA 和 SFENCE.INVAL.IR 与假设的 SFENCE.VMA 指令具有相同的效果，其中：</p>
<ul>
<li>SFENCE.VMA 的 rs1 和 rs2 值与 SINVAL.VMA 中使用的值相同， </li>
<li>SFENCE.W.INVAL 之前的读取和写入被视为 SFENCE.VMA 之前的读取和写入，</li>
<li>并且 SFENCE.INVAL.IR 之后的读取和写入被视为 SFENCE.VMA 后续的读取和写入。</li>
</ul>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230725091909928-1730798006987-79.png" alt="image-20230725091909928"></p>
<p>如果实现了Supervisor扩展，Svinval 扩展还提供两个附加指令：HINVAL.VVMA 和 HINVAL.GVMA。它们与 SINVAL.VMA 具有相同的语义，只不过它们与 SFENCE.W.INVAL 和 SFENCE.INVAL.IR 结合来分别替换 HFENCE.VVMA 和 HFENCE.GVMA，而不是 SFENCE.VMA。此外，HINVAL.GVMA 使用 VMID 而不是 ASID。</p>
<p>SINVAL.VMA、HINVAL.VVMA 和 HINVAL.GVMA 分别需要与 SFENCE.VMA、HFENCE.VVMA 和 HFENCE.GVMA 相同的权限并引发相同的异常。特别是，尝试在 U 模式下执行任何这些指令总是会引发非法指令异常，并且当 mstatus.TVM&#x3D;1 时尝试在 S 模式或 HS 模式下执行 SINVAL.VMA 或 HINVAL.GVMA 也会引发非法指令异常。尝试在 VS 模式或 VU 模式下执行 HINVAL.VVMA 或 HINVAL.GVMA，或在 VU 模式下执行 SINVAL.VMA 会引发虚拟指令异常。当 hstatus.VTVM&#x3D;1 时，尝试在 VS 模式下执行 SINVAL.VMA 也会引发虚拟指令异常。</p>
<blockquote>
<p>当 mstatus.TVM&#x3D;1 或 hstatus.VTVM&#x3D;1 时，SFENCE.W.INVAL 和 SFENCE.INVAL.IR 指令不需要被捕获，因为它们仅具有排序效果，而没有可见的副作用。 SINVAL.VMA 指令的捕获足以实现预期整体 TLB 维护功能的仿真。</p>
<p>在典型用法中，软件将通过执行 SFENCE.W.INVAL 指令，对相关地址（以及可选的 ASID 或 VMID）执行一系列 SINVAL.VMA、HINVAL.VVMA 或 HINVAL.GVMA 指令，然后执行 SFENCE.INVAL.IR 指令，使地址转换缓存中的一系列虚拟地址无效。</p>
<p>高性能实现将能够对地址转换缓存失效操作进行流水线处理，并将推迟任何流水线停顿或其他内存排序强制执行，直到执行 SFENCE.W.INVAL、SFENCE.INVAL.IR、SFENCE.VMA、HFENCE.GVMA 或 HFENCE.VVMA 指令。</p>
<p>更简单的实现可以分别与 SFENCE.VMA、HFENCE.VVMA 和 HFENCE.GVMA 相同地实现 SINVAL.VMA、HINVAL.VVMA 和 HINVAL.GVMA，同时将 SFENCE.W.INVAL 和 SFENCE.INVAL.IR 指令实现为无操作。</p>
</blockquote>
<h1 id="8-Hypervisor扩展，版本-1-0"><a href="#8-Hypervisor扩展，版本-1-0" class="headerlink" title="8.  Hypervisor扩展，版本 1.0"></a>8.  Hypervisor扩展，版本 1.0</h1><p>本章描述了RISC-V hypervisor extension ，它<strong>虚拟化了supervisor-level的体系结构</strong>，以支持在type-1或type-2 hypervisor 之上高效地托管guestOS。</p>
<p> hypervisor extension 将<strong>supervisor mode更改</strong>为 <em>hypervisor-extended supervisor mode</em>  (HS-mode，或简称hypervisor mode)，其中运行hypervisor或具有托管功能(hosting-capable)的OS。</p>
<p> hypervisor extension <strong>还添加了另一个地址转换阶段，从GPA（guest physical addresses）到SPA（supervisor physical addresses），从而为guest OS虚拟化内存和内存映射的I&#x2F;O子系统</strong>。</p>
<p>HS-mode的行为与S-mode相同，但有<strong>额外的指令和CSR来控制地址转换的新阶段</strong>，并<strong>支持在虚拟S-mode (VS-mode)中托管guest OS</strong>。<strong>常规的S模式OS无需修改即可在HS模式或VS模式guest模式下执行。</strong></p>
<p>在HS模式下，OS或hypervisor通过与S模式下的OS<strong>相同的SBI</strong>与机器进行交互。期望 HS模式hypervisor为其VS模式客户机实现SBI。</p>
<p>hypervisor扩展依赖于具有32个寄存器(RV32I或RV64I)的“I”基础整数ISA，而不是只有16个寄存器的RV32E。**&#x3D;&#x3D;CSR mtval不能为只读零，并且必须支持标准的基于页面的地址转换，RV32支持Sv32, <font color="red">RV64支持Sv39</font>&#x3D;&#x3D;**。</p>
<p>通过在misa CSR中设置第7位来启用虚拟机hypervisor扩展，这与字母h相对应。<strong>建议实现虚拟机hypervisor扩展的RISC-V hart不要硬连接misa[7]，以便该扩展能够被禁用</strong>。</p>
<blockquote>
<p>基准特权架构旨在<strong>简化经典虚拟化技术的使用</strong>，其中**<font color="red">guest OS 在user-level 运行</font>，因为数量少的特权指令可以很容易地检测和捕获**。hypervisor扩展&#x3D;&#x3D;<strong>通过降低这些traps的频率来提高虚拟化性能</strong>&#x3D;&#x3D;。</p>
<p>通过<strong>以S模式运行hypervisor</strong>，并为<strong>hypervisor CSR访问</strong>和<strong>维护影子页表（shadow page tables）</strong> <strong>捕获到M模式</strong>， hypervisor extension被设计为可以在<strong>不实现该扩展的平台上有效地进行仿真</strong>。type-2 hypervisors 的大多数CSR访问都是有效的S模式访问，因此不需要被捕获。Hypervisors可以类似地支持嵌套虚拟化。</p>
</blockquote>
<h2 id="8-1-特权模式"><a href="#8-1-特权模式" class="headerlink" title="8.1 特权模式"></a>8.1 特权模式</h2><p>Privilege Modes</p>
<p>当前虚拟化模式（表示为 V）指示 hart 当前是否正在 guest 虚拟机中执行。</p>
<ul>
<li>当 V&#x3D;1 时，hart 要么处于虚拟 S 模式（VS 模式），要么处于以 VS 模式运行的guest OS之上的虚拟 U 模式（VU 模式）。</li>
<li>当 V&#x3D;0 时，hart 处于 M 模式、HS 模式或在 HS 模式下运行的OS之上的 U 模式。</li>
</ul>
<p>虚拟化模式还指示两阶段地址转换是激活的(V&#x3D;1)还是非激活的(V&#x3D;0)。表8.1列出了带有hypervisor扩展的RISC-V hart可能的特权模式。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619102536443-1730798006987-80.png" alt="image-20230619102536443"></p>
<p>对于特权模式U和VU，名义特权模式为U，对于特权模式HS和VS，名义特权模式为S。</p>
<p>HS模式比VS模式优先，VS模式比VU模式优先。<strong>在U模式下执行时，VS-mode中断被全局禁用</strong>。</p>
<blockquote>
<p>&#x3D;&#x3D;<strong>此描述没有考虑U模式或VU模式中断的可能性，如果采用 user-level 中断的扩展，则将进行修改。</strong>&#x3D;&#x3D;</p>
</blockquote>
<h2 id="8-2-Hypervisor-and-Virtual-Supervisor-CSRs"><a href="#8-2-Hypervisor-and-Virtual-Supervisor-CSRs" class="headerlink" title="8.2 Hypervisor and Virtual Supervisor CSRs"></a>8.2 Hypervisor and Virtual Supervisor CSRs</h2><p>以HS-mode运行的OS或hypervisor使用supervisor CSR与异常、中断和地址转换子系统进行交互。<strong>额外的CSR提供给HS-mode，但不提供给VS-mode</strong>，用于管理两阶段地址转换和控制VS-mode客户机的行为:hstatus、hedeleg、hideleg、hvip、hip、hie、hgeip、hgeie、henvcfg、henvcfgh、hcounteren、htimedelta、htimedelta、htval、htinst和hgatp。</p>
<p>此外，一些virtual supervisor CSR (VS CSR)是正常supervisor CSR的副本。例如，vsstatus是复制了通常的sstatus CSR的VS CSR。</p>
<p><strong>当V&#x3D;1时</strong>，<strong>VS CSR代替相应的Supervisor CSR</strong>，除另有规定外，<strong>接管通常的Supervisor CSR的所有功能</strong>。通常<strong>读取或修改Supervisor CSR的指令应改为访问相应的VS CSR</strong>。当V&#x3D;1时，试图通过单独的CSR地址直接读写VS CSR会导致虚拟指令异常。(从U模式的尝试通常会导致非法指令异常。)</p>
<p>&#x3D;&#x3D;VS CSR只能通过M模式或HS模式访问。&#x3D;&#x3D;</p>
<p><strong>当V&#x3D;1时</strong>，<strong>被VS CSR取代的正常HS级Supervisor CSR保留其值，但不影响机器的行为</strong>，除非有专门的文件这样做。相反，<strong>当V&#x3D;0时，除了CSR指令可读可写之外，VS CSR通常不会影响机器的行为</strong>。</p>
<p>一些标准的supervisor CSR (senvcfg, scounteren和scontext，可能还有其他)没有匹配的VS CSR。当V&#x3D;1时，除了VS-mode和VU-mode取代了HS-mode和U-mode外，<strong>这些supervisor CSR仍然具有其通常的功能和可访问性</strong>。<strong>要求hypervisor软件将根据需要 手动交换这些寄存器的内容。</strong></p>
<blockquote>
<p>匹配的 VS CSR 只存在于必须复制的supervisor CSR 中，这些 CSR 主要是那些由traps自动写入的 CSR，或者仅凭软件无法在以下情况交换 CSR 时，在陷阱进入后 and&#x2F;or SRET之前立即影响指令执行的 CSR。目前，大多数supervisor CSR 都属于这一类，但未来可能不会。</p>
</blockquote>
<p>在本章中，我们使用术语HSXLEN来指代在HS-mode下执行时的有效XLEN，而使用术语VSXLEN来指代在VS模式下执行时的有效XLEN。</p>
<h3 id="8-2-1-Hypervisor-状态寄存器-hstatus"><a href="#8-2-1-Hypervisor-状态寄存器-hstatus" class="headerlink" title="8.2.1 Hypervisor 状态寄存器(hstatus)"></a>8.2.1 Hypervisor 状态寄存器(hstatus)</h3><p>hstatus寄存器是一个HSXLEN位读写寄存器，当HSXLEN&#x3D;32时格式如图8.1所示，当HSXLEN&#x3D;64时格式如图8.2所示。hstatus寄存器提供了类似于mstatus寄存器的功能，用于<strong>跟踪和控制VS模式客户机的异常行为</strong>。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619104021864-1730798006987-81.png" alt="image-20230619104021864"></p>
<p><strong>VSXL字段控制VS模式的有效XLEN</strong>(称为VSXLEN)，它可能与HS模式的XLEN (HSXLEN)不同。<br>当HSXLEN&#x3D;32时，VSXL字段不存在，且HSXLEN&#x3D;32。<br>当HSXLEN&#x3D;64时，VSXL是一个与misa的MXL字段编码相同的WARL字段，如第16页表3.1所示。<br>特别是，<strong>实现可以使VSXL成为只读字段，其值始终确保VSXLEN&#x3D;HSXLEN。</strong></p>
<p>如果将HSXLEN从32更改为更宽的宽度，并且如果字段VSXL不限于单个值，则它将获得与支持的最宽宽度相对应的值，该宽度不宽于新的HSXLEN。</p>
<p>hstatus字段<strong>VTSR、VTW和VTVM的定义类似于mstatus字段TSR、TW和TVM，但只影响VS模式下的执行，并且导致虚拟指令异常，而不是非法指令异常</strong>。</p>
<ul>
<li>当VTSR&#x3D;1时，试图在VS模式下执行SRET会引发一个虚拟指令异常。</li>
<li>当VTW&#x3D;1(并假设mstatus.TW&#x3D;0)时，如果WFI没有在特定于实现的有限时间限制内完成，则在VS模式下执行WFI的尝试会引发虚拟指令异常。</li>
<li>当VTVM&#x3D;1时，尝试以VS模式执行SFENCE。VMA或SINVAL。VMA或访问CSR satp会引发虚拟指令异常。</li>
</ul>
<p>&#x3D;&#x3D;<strong>VGEIN(虚拟guest外部中断号)字段为VS级外部中断选择guest外部中断源</strong>&#x3D;&#x3D;。VGEIN是一个WLRL字段<strong>，它必须能够保存介于0和最大guest外部中断数量(称为GEILEN)之间的值</strong>，包括在内。<strong>当VGEIN&#x3D;0时，对VS级外部中断不选择guest外部中断源</strong>。GEILEN可能为零，在这种情况下，VGEIN可能为只读零。客户外部中断将在8.2.4节中解释，VGEIN的使用将在8.2.3节中进一步介绍。</p>
<p><strong>字段HU (U模式hypervisor)控制虚拟机加载&#x2F;存储指令HLV、HLVX和HSV是否也可以在U模式下使用</strong>。当HU&#x3D;1时，这些指令可以像HS模式一样在U模式下执行。当HU&#x3D;0时，所有hypervisor指令都会导致U模式的非法指令trap。</p>
<blockquote>
<p>HU位允许虚拟机hypervisor的一部分以U模式运行，以更好地防止软件错误，同时仍然保留对虚拟机内存的访问。</p>
</blockquote>
<p><strong>SPV位(Supervisor Previous Virtualization mode)是在trap进入HS模式时由实现写入的</strong>。正如在发生trap时，sstatus中的SPP位被设置为(名义)特权模式，hstatus中的SPV位被设置为发生trap时虚拟化模式V的值。当一条SRET指令在V&#x3D;0时执行时，V被设置到 SPV。</p>
<p>当V&#x3D;1并且trap进入HS模式时，<strong>位SPVP (Supervisor Previous Virtual Privilege)被设置为trap发生时的名义特权模式</strong>，与status. spp相同。但如果在陷阱之前V&#x3D;0，则SPVP在陷阱进入时保持不变。SPVP控制由虚拟机加载&#x2F;存储指令HLV、HLVX和HSV进行的显式内存访问的有效权限。</p>
<blockquote>
<p>如果没有SPVP, HLV, HLVX和HSV的指示看起来反而是状态。那么，即使HU&#x3D;1, U模式也不能在VS级访问虚拟机内存，因为使用SRET进入U模式总是使SPP&#x3D;0。与SPP不同，SPVP不受HS模式和Umode之间来回转换的影响。</p>
</blockquote>
<p><strong>字段GVA(guest虚拟地址)由 实现(implementation)在trap进入HS模式时写入</strong>。对于任何将guest虚拟地址写入stval的陷阱(断点、地址不一致、访问错误、页面错误或guest页面错误)，GVA设置为1。对于其他进入HS模式的trap, GVA设置为0。</p>
<blockquote>
<p>对于将非零值写入stval的断点和内存访问陷阱，除了HLV、HLVX或HSV指令的显式内存访问导致错误外，GVA与字段SPV(两个位设置相同)是冗余的。在这种情况下，SPV&#x3D;0, GVA&#x3D;1。</p>
</blockquote>
<p><strong>VSBE位是一个WARL字段，它控制从VS模式进行的显式内存访问的端序。</strong>如果VSBE&#x3D;0，则从VS模式进行的显式加载和存储内存访问是小端序，如果VSBE&#x3D;1，则是大端序。VSBE还控制对VS级内存管理数据结构(如页表)的所有隐式访问的端序。一个实现可以使VSBE成为一个只读字段，它总是指定与HS模式相同的端序。</p>
<h3 id="8-2-2-Hypervisor-Trap-委托寄存器-hedeleg和hideleg"><a href="#8-2-2-Hypervisor-Trap-委托寄存器-hedeleg和hideleg" class="headerlink" title="8.2.2 Hypervisor Trap 委托寄存器(hedeleg和hideleg)"></a>8.2.2 Hypervisor Trap 委托寄存器(hedeleg和hideleg)</h3><p>寄存器hedeleg和hideleg是HSXLEN位读写寄存器，格式分别如图8.3和8.4所示。<strong>默认情况下，任何特权级别的所有陷阱都以M模式处理，尽管M模式通常使用medeleg和mideleg CSR将一些陷阱委托给HS模式</strong>。<strong>hedeleg和hideleg CSR允许将这些陷阱进一步委托给VS模式的客户机；它们的布局与medeleg和mideleg相同。</strong></p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619111427150-1730798006987-82.png" alt="image-20230619111427150"></p>
<p>如果在trap之前 V&#x3D;1 并且设置相应的 hedeleg 位，则已委派给 HS 模式（使用 medeleg）的同步trap将进一步委派给 VS 模式。</p>
<p>hedeleg的每个位要么为可写零，要么为只读零。<strong>hedeleg的许多位被明确要求为可写或为零，如表8.2所列。</strong>如果IALIGN&#x3D;32，对应于指令地址不对齐异常的位0必须是可写的。</p>
<blockquote>
<p>要求hedeleg的某些位是可写的，可以减轻hypervisor处理实现变化的负担。</p>
</blockquote>
<p>如果设置了相应的hideleg位，那么已经被委托到HS模式(使用mideleg)的中断将进一步被委托到VS模式。hideleg的15:0位中，10、6、2位(对应标准VS级中断)是可写的，12、9、5、1位(对应标准S级中断)是只读零。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619111621452-1730798006988-83.png" alt="image-20230619111621452"></p>
<p><strong>当虚拟管理器外部中断(代码10)被委托到VS模式时，它被机器自动转换为VS模式的管理器外部中断(代码9)，包括在中断陷阱上写入vscause的值。同样，将虚拟管理器定时器中断(6)转换为VS模式的管理器定时器中断(5)，将虚拟管理器软件中断(2)转换为VS模式的管理器软件中断(1)。对于平台或自定义中断原因(代码16及以上)，可能会或可能不会进行类似的翻译。</strong></p>
<h3 id="8-2-3-Hypervisor-中断寄存器-hvip、hip、hie"><a href="#8-2-3-Hypervisor-中断寄存器-hvip、hip、hie" class="headerlink" title="8.2.3 Hypervisor 中断寄存器(hvip、hip、hie)"></a>8.2.3 Hypervisor 中断寄存器(hvip、hip、hie)</h3><p><strong>寄存器hvip是一个HSXLEN位读&#x2F;写寄存器，hypervisor可以写入它来指示用于VS模式的虚拟中断。</strong>hvip中不可写的位是只读零。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619112857447-1730798006988-84.png" alt="image-20230619112857447"></p>
<p>hvip的标准部分(比特15:0)格式化如图8.6所示。<strong>hvip的VSEIP、VSTIP、VSSIP位是&#x3D;&#x3D;可写的&#x3D;&#x3D;。</strong></p>
<p><strong>在hvip中</strong><br><strong>设置VSEIP&#x3D;1断言一个VS级外部中断;</strong><br><strong>设置VSTIP&#x3D;1断言一个VS级定时器中断;</strong><br><strong>设置VSSIP&#x3D;1断言一个VS级软件中断。</strong></p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619112917408-1730798006988-85.png" alt="image-20230619112917408"></p>
<p>寄存器hip和hie是HSXLEN位读&#x2F;写寄存器，<strong>分别补充HS级的sip和sie。hip寄存器指示挂起的VS级中断和特定于hypervisor的中断，而hie包含相同中断的启用位。</strong></p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619112933217-1730798006988-86.png" alt="image-20230619112933217"></p>
<p><strong>对于sie中的每一个可写位，对应的位在hip和hie中都必须是只读零。因此，sie和hie中的非零位总是互斥的，sip和hip也是如此。</strong></p>
<blockquote>
<p>hip和hip的活动位不能放在HS级的sip和sie中，因为这样做会使软件无法在没有在硬件中实现的平台上模拟hypervisor扩展。</p>
</blockquote>
<p>当下列所有条件都为真时，<strong>中断i将被捕获到HS模式</strong>:</p>
<ol>
<li><p><strong>当前工作模式为HS模式，并且设置了<code>sstatus</code>寄存器中的<code>SIE</code>位，或者当前工作模式的特权小于HS模式;</strong></p>
</li>
<li><p><strong>第i位同时位于<code>sip</code> 和<code>sie</code>，或同时位于<code>hip</code> 和<code>hie</code>;和</strong></p>
</li>
<li><p><strong>第i位未设置在<code>hideleg</code>中。</strong></p>
</li>
</ol>
<p>如果<code>sie</code>的位 i 是只读零，则寄存器<code>hip</code>中的相同位可以是可写的，也可以是只读的。当<code>hip</code>中的位i可写时，可以通过向该位写入0来清除挂起的中断i。</p>
<p>如果中断i可以在hip中变为挂起，但hip中的位i是只读的，则可以通过清除<code>hvip</code>的位i来清除中断，或者实现必须提供一些其他机制来清除挂起的中断（这可能涉及对执行环境的调用）</p>
<p><strong>如果相应的中断可能在hip中挂起，则hie中的一位应是可写的。hie中不可写的位应为只读零。</strong></p>
<p>寄存器hip和hie的标准部分（位15:0）的格式分别如图8.9和8.10所示。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619133330589-1730798006988-87.png" alt="image-20230619133330589"></p>
<p>位<code>hip.SGEIP</code>和<code>hie.SGEIE</code>是Supervisor级（HS级）guest外部中断的中断挂起和中断启用位。</p>
<p><strong>&#x3D;&#x3D;<code>SGEIP</code>在<code>hip</code>中是只读的，当且仅当CSR <code>hgeip</code>和<code>hgeie</code>的逐位逻辑and在任何位中都是非零的时候为1。（参见第8.2.4节。）&#x3D;&#x3D;</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> SGEIP= |(hgeip[<span class="number">63</span>:<span class="number">0</span>] &amp; hgeie[<span class="number">63</span>:<span class="number">0</span>]);<span class="comment">//只要hgeip和hgeie中同样的位置同时为1，则SGEIP为1</span></span><br></pre></td></tr></table></figure>



<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619133352813-1730798006988-88.png" alt="image-20230619133352813"></p>
<p>位<code>hip.VSEIP</code>和<code>hie.VSEIE</code>是VS级<strong>外部中断</strong>的中断挂起和中断使能位。<strong>VSEIP在hip中是只读的</strong>，是这些中断源的逻辑或：</p>
<ul>
<li>位<code>hvip.VSEIP</code>；</li>
<li>由<code>hstatus.VGEIN</code>选择的<code>hgeip</code>的比特；</li>
<li>以及指向VS-level的任何其他平台特定的外部中断信号。</li>
</ul>
<p>位<code>hip.VSTIP</code>和<code>hie.VSTIE</code>是VS级<strong>定时器</strong>中断的中断挂起和中断使能位。<strong>VSTIP在hip中是只读的</strong>，并且是<code>hvip.VSTIP</code>和指向VS电平的任何其他特定于平台的定时器中断信号的逻辑或。</p>
<p>位<code>hip.VSSIP</code>和<code>hie.VSSIE</code>是VS级<strong>软件</strong>中断的中断挂起和中断使能位。<code>hip</code>中的<code>VSSIP</code>是<code>hvip</code>中相同位的别名（<strong>可写</strong>）。</p>
<p>以HS模式为目的地的多个同时中断按以下递减优先级顺序处理：&#x3D;&#x3D;SEI、SSI、STI、SGEI、VSEI、VSSI、VSTI。&#x3D;&#x3D;</p>
<h3 id="8-2-4-Hypervisor-Guest-外部中断寄存器-hgeip-and-hgeie"><a href="#8-2-4-Hypervisor-Guest-外部中断寄存器-hgeip-and-hgeie" class="headerlink" title="8.2.4 Hypervisor Guest 外部中断寄存器 (hgeip and hgeie)"></a>8.2.4 Hypervisor Guest 外部中断寄存器 (hgeip and hgeie)</h3><p><strong><code>hgeip</code>寄存器</strong>是一个HSXLEN位<strong>只读寄存器</strong>，其格式如图8.11所示，<strong>表示该hart的待处理guest外部中断</strong>。</p>
<p><strong><code>hgeie</code>寄存器</strong>是一个HSXLEN位<strong>读&#x2F;写寄存器</strong>，其格式如图8.12所示，<strong>其中包含该hart的guest外部中断的启用位</strong>。guest外部中断编号i与hgeip和hgeie中的位i都对应。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619133843695-1730798006988-89.png" alt="image-20230619133843695"></p>
<p><strong>guest外部中断表示在VS级别上指向单个虚拟机的中断</strong>。如果RISC-V平台支持<strong>将物理设备置于guest OS的直接控制之下</strong>，而虚拟机hypervisor的干预最少(称为虚拟机和物理设备之间的直通或直接分配)，那么，在这种情况下，<strong>来自设备的中断将用于特定的虚拟机</strong>。</p>
<p><strong>hgeip的每个位汇总了中断控制器收集和报告的指向一个虚拟Hart的所有待处理中断。要区分来自多个设备的特定待处理中断，软件必须查询中断控制器。</strong></p>
<blockquote>
<p><strong>对guest外部中断的支持需要一个中断控制器，它可以从其他中断中单独收集虚拟机定向中断</strong>。</p>
</blockquote>
<p>hgeip和hgeie中为guest外部中断实现的位数未指定，可能为零。这个数字被称为GEILEN。除0位外，最低有效位首先实现。因此，如果GEILEN为非零，GEILEN:1位在hgeie中是可写的，其他位在hgeip和hgeie中都是只读零。</p>
<blockquote>
<p>在一个物理hart接收和处理的guest外部中断集可能不同于在其他hart接收到的中断集。通常期望一个物理节点上的guest外部中断号i与任何其他节点上的guest外部中断号i不相同。对于任何一个<strong>物理hart</strong>，<strong>可以直接接收guest外部中断的虚拟hart的最大数量是由GEILEN限制的</strong>。对于任何实现，每个物理hart的<strong>这个数字的最大值是RV32的31和RV64的63</strong>。</p>
<p><strong>hypervisor始终可以自由地为任意数量的虚拟hart模拟设备</strong>，而不受GEILEN的限制。<strong>只有中断的直接传递(直接分配)受GEILEN限制的影响</strong>，并且<strong>限制的是接收此类中断的虚拟hart的数量</strong>，<strong>而不是接收到的不同中断的数量</strong>。一个虚拟hart可以接收的不同中断的数量是由中断控制器决定的。</p>
</blockquote>
<p>hgeie选择导致Supervisor级(HS级)guest外部中断的guest外部中断子集。hgeie中的使能位不影响hstatus.VGEIN从hgeip中选择的VS级外部中断信号。</p>
<h3 id="8-2-5-Hypervisor-环境配置寄存器-henvcfg-and-henvcfgh"><a href="#8-2-5-Hypervisor-环境配置寄存器-henvcfg-and-henvcfgh" class="headerlink" title="8.2.5 Hypervisor 环境配置寄存器(henvcfg and henvcfgh)"></a>8.2.5 Hypervisor 环境配置寄存器(henvcfg and henvcfgh)</h3><p><code>henvcfg</code> CSR是一个HSXLEN位读&#x2F;写寄存器，格式化为HSXLEN&#x3D;64，如图8.13所示，它<strong>控制虚拟化模式V&#x3D;1时执行环境的某些特征</strong>。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619134725508-1730798006988-90.png" alt="image-20230619134725508"></p>
<p>如果位FIOM (I&#x2F;O的Fence意味着内存)在henvcfg中设置为1，则在V&#x3D;1时执行的Fence指令被修改，因此对设备I&#x2F;O的顺序访问要求也意味着对主内存访问的顺序要求。表8.3详细说明了FIOM&#x3D;1和V&#x3D;1时FENCE指令位PI、PO、SI和SO的修改解释。</p>
<p>类似地，当FIOM&#x3D;1和V&#x3D;1时，如果一个原子指令访问一个排序为设备I&#x2F;O的区域，并且设置了aq和&#x2F;或rl位，那么该指令就被排序为既访问设备I&#x2F;O又访问内存。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619135337569-1730798006988-91.png" alt="image-20230619135337569"></p>
<p>表8.3:FIOM&#x3D;1和虚拟化模式V&#x3D;1时修改的FENCE前后继集解释。</p>
<table>
<thead>
<tr>
<th>Instruction bit</th>
<th>Meaning when set</th>
</tr>
</thead>
<tbody><tr>
<td>PI<br>PO</td>
<td>前置设备输入和内存读取(PR隐含) (PR implied)<br>前导设备输出和内存写入(PW隐含)</td>
</tr>
<tr>
<td>SI<br>SO</td>
<td>后继设备输入和内存读取(SR隐含)<br>后继设备输出和内存写入(SW隐含)</td>
</tr>
</tbody></table>
<p><code>PBMTE</code>位控制Svpbmt扩展是否可用于VS阶段地址转换。</p>
<ul>
<li>当PBMTE&#x3D;1时，Svpbmt可用于VS-stage地址转换。</li>
<li>当PBMTE&#x3D;0时，实现的行为就像没有为VS阶段地址转换实现Svpbmt一样。如果不实现Svpbmt, PBMTE为只读零。</li>
</ul>
<p><code>VSTCE</code>字段的定义将由即将发布的Sstc扩展提供。其在henvcfg内的分配可能在批准该延长之前发生变化。</p>
<p><code>CBZE</code>字段的定义将由即将到来的Zicboz扩展提供。其在henvcfg内的分配可能在批准该延长之前发生变化。</p>
<p><code>CBCFE</code>和<code>CBIE</code>字段的定义将由即将发布的Zicbom扩展提供。它们在henvcfg内的分配可能在批准该延长之前发生变化。</p>
<p>当HSXLEN&#x3D;32时，henvcfg包含与HSXLEN&#x3D;64时henvcfg中31:0位相同的字段。此外，当HSXLEN&#x3D;32时，henvcfgh是一个32位读&#x2F;写寄存器，其中包含与HSXLEN&#x3D;64时henvcfg的63:32位相同的字段。当HSXLEN&#x3D;64时，henvcfgh不存在。</p>
<h3 id="8-2-6-Hypervisor-计数器启用寄存器-hcounteren"><a href="#8-2-6-Hypervisor-计数器启用寄存器-hcounteren" class="headerlink" title="8.2.6 Hypervisor 计数器启用寄存器 (hcounteren)"></a>8.2.6 Hypervisor 计数器启用寄存器 (hcounteren)</h3><p>计数器启用寄存器hcounteren是一个32位寄存器，<strong>它控制硬件性能监视计数器对guest虚拟机的可用性</strong>。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619135943653-1730798006988-92.png" alt="image-20230619135943653"></p>
<p>当hcounteren寄存器中的CY、TM、IR或HPMn位清除时，在V&#x3D;1时尝试读取周期、时间、instet或hpmcountern寄存器，如果mcounteren中的相同位为1，则会导致虚拟指令异常。当这些位之一被设置时，当V&#x3D;1时允许访问相应的寄存器，除非由于其他原因阻止。在VU模式下，除非在hcounteren和scounteren中都设置了适用的位，否则计数器是不可读的。</p>
<p>必须实现hcounten。然而，任何比特都可以是只读的零，这表明当V＝1时，对相应计数器的读取将导致异常。因此，它们实际上是WARL字段。</p>
<h3 id="8-2-7-Hypervisor-时间增量寄存器-htimedelta-htimedeltah"><a href="#8-2-7-Hypervisor-时间增量寄存器-htimedelta-htimedeltah" class="headerlink" title="8.2.7 Hypervisor 时间增量寄存器 (htimedelta, htimedeltah)"></a>8.2.7 Hypervisor 时间增量寄存器 (htimedelta, htimedeltah)</h3><p>htimedelta CSR是一个读&#x2F;写寄存器，它<strong>包含time CSR的值和在VS模式或VU模式中返回的值之间的增量</strong>。也就是说，在VS或VU模式下读取时间CSR将返回htimedelta的内容与time的实际值之和</p>
<blockquote>
<p><strong>由于在对htimedelta和时间求和时忽略溢出，因此可以使用大的htimedelta值来表示负时间偏移。</strong></p>
</blockquote>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619140918185-1730798006988-93.png" alt="image-20230619140918185"></p>
<p>仅当HSXLEN&#x3D;32时，htimedelta保持delta的低32位，而htimedeltah保持delta中的高32位。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619140944661-1730798006988-94.png" alt="image-20230619140944661"></p>
<h3 id="8-2-8-Hypervisor-陷阱值寄存器-htval"><a href="#8-2-8-Hypervisor-陷阱值寄存器-htval" class="headerlink" title="8.2.8 Hypervisor 陷阱值寄存器 (htval)"></a>8.2.8 Hypervisor 陷阱值寄存器 (htval)</h3><p>htval寄存器是一个HSXLEN位读&#x2F;写寄存器，其格式如图8.17所示。<strong>当陷阱进入HS模式时，htval会与stval一起写入额外的异常特定信息，以帮助软件处理陷阱</strong>。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619141019050-1730798006988-95.png" alt="image-20230619141019050"></p>
<p>当客户页面故障陷阱进入HS模式时，写入的htval要么为零，要么为发生故障的guest physical addresses，右移2位。对于其他陷阱，htval设置为零，但未来的标准或扩展可能会重新定义htval对其他陷阱的设置。由于第一阶段（VS阶段）地址转换期间的隐式存储器访问，可能会出现访客页面故障，在这种情况下，写入htval的guest physical addresses是发生故障的隐式内存访问的地址，例如，无法读取的VS级页表项的地址。（当VS阶段转换无法完成时，与原始虚拟地址对应的guest物理地址是未知的。）CSR htinst中提供了其他信息，以消除此类情况的歧义。</p>
<p>否则，对于导致客户机页面错误的未对齐的加载和存储，htval中的非零客户机物理地址对应于stval中的虚拟地址所指示的访问的错误部分。对于具有变长指令的系统上的指令访客页面错误，一个非零的htval对应于由stval中的虚拟地址所指示的指令的错误部分。</p>
<blockquote>
<p>写入htval的guest physical addresses向右移动2位，以容纳比当前XLEN更宽的地址。对于RV32，虚拟机监控程序扩展允许guest physical addresses的宽度为34位，并且htval报告地址的位33:2。客户机物理地址的按2移位编码与PMP地址寄存器(章节3.7)和页表项(章节4.3、4.4、4.5和4.6)中的物理地址编码相匹配。</p>
<p>如果需要故障客户机物理地址的最低有效位，这些位通常与stval中故障虚拟地址的最低有效位相同。对于由于VS阶段地址转换的隐式内存访问而导致的错误，最低有效的两位将改为零。可以使用注册表htinst中提供的值来区分这些情况。</p>
</blockquote>
<p>htval是一个WARL寄存器，它必须能够保存0，并且可能只能够保存其他2位移位的guest physical addresses的任意子集(如果有的话)。</p>
<blockquote>
<p>除非有其他理由(例如平台标准)，否则将值写入htval的软件应该从htval回读以确认存储的值。</p>
</blockquote>
<h3 id="8-2-9-Hypervisor-陷阱指令寄存器-htinst"><a href="#8-2-9-Hypervisor-陷阱指令寄存器-htinst" class="headerlink" title="8.2.9 Hypervisor 陷阱指令寄存器 (htinst)"></a>8.2.9 Hypervisor 陷阱指令寄存器 (htinst)</h3><p>htinst寄存器是一个HSXLEN位读&#x2F;写寄存器，格式如图8.18所示。当一个陷阱进入HS模式时，htinst被写入一个值，如果该值非零，则提供有关被捕获的指令的信息，以帮助软件处理该陷阱。可以在trap上写入htinst的值在第8.6.3节中有文档说明。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619141250391-1730798006988-96.png" alt="image-20230619141250391"></p>
<p>htinst是一个WARL寄存器，它只需要能够保存实现可能在陷阱时自动写入它的值。</p>
<h3 id="8-2-10-Hypervisor-Guest-地址转换和保护寄存器-hgatp"><a href="#8-2-10-Hypervisor-Guest-地址转换和保护寄存器-hgatp" class="headerlink" title="8.2.10 Hypervisor Guest 地址转换和保护寄存器 (hgatp)"></a>8.2.10 Hypervisor Guest 地址转换和保护寄存器 (hgatp)</h3><p><strong>hgatp</strong>寄存器是一个HSXLEN位读&#x2F;写寄存器，<strong>它控制G-stage地址转换和保护</strong>，这是guest virtual addresses两阶段转换的第二阶段(参见8.5节)。</p>
<p>与CSR satp类似，该寄存器保存guest-physical root page table的物理页号(PPN)；虚拟机标识符 (VMID)，有助于在每个虚拟机的基础上进行地址转换(which facilitates address-translation fences on a per-virtual-machine basis)； </p>
<p><strong>MODE</strong> 字段，用于选择客户物理地址的地址转换方案。</p>
<p>当 mstatus.TVM&#x3D;1 时，在 HS 模式下执行时尝试读取或写入 <strong>hgatp</strong> 将引发非法指令异常。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619141328875-1730798006988-97.png" alt="image-20230619141328875"></p>
<p>表 8.4 显示了 HSXLEN&#x3D;32 和 HSXLEN&#x3D;64 时 MODE 字段的编码。</p>
<p>当MODE&#x3D;Bare时，guest physical addresses等于supervisor physical addresses，并且除了第3.7节中描述的物理内存保护方案之外，guest虚拟机没有进一步的内存保护。在这种情况下，<strong>hgatp</strong> 中的其余字段必须设置为零。</p>
<p>当 HSXLEN&#x3D;32 时，MODE 的唯一其他有效设置是 Sv32x4，它是通常 Sv32 分页虚拟内存方案的修改，扩展为支持 34 位客户机物理地址。</p>
<p>当 HSXLEN&#x3D;64 时，模式 Sv39x4、Sv48x4 和 Sv57x4 被定义为 Sv39、Sv48 和 Sv57 分页虚拟内存方案的修改。所有这些分页虚拟内存方案都在第 8.5.1 节中描述。</p>
<p>当 HSXLEN&#x3D;64 时剩余的 MODE 设置保留供将来使用，并且可以定义 <strong>hgatp</strong> 中其他字段的不同解释。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230719160026932-1730798006988-99.png" alt="image-20230719160026932"></p>
<p>当 HSXLEN&#x3D;64 时，实现不需要支持所有定义的 MODE 设置。</p>
<p>与 satp 一样，使用不支持的 MODE 值写入 hgatp 不会被忽略。相反，当如此指示时，hgatp 的字段以正常方式进行 WARL。</p>
<p>如第 8.5.1 节中所述，对于分页虚拟内存方案（Sv32x4、Sv39x4、Sv48x4 和 Sv57x4），根页表为 16 KiB，并且必须与 16 KiB 边界对齐。在这个模式下，hgatp 中物理页号 (PPN) 的最低两位始终读为零。仅支持定义的分页虚拟内存方案 和&#x2F;或 Bare 的实现可以使 PPN[1:0] 只读为零。</p>
<p>VMID 位的数量未指定，可能为零。所实现的 VMID 位的数量（称为 VMIDLEN）可以通过将 1 写入 VMID 字段中的每个位位置，然后读回 hgatp 中的值以查看 VMID 字段中的哪些位位置保持为 1 来确定。首先实现 VMID 的最低有效位：即，如果 VMIDLEN &gt; 0，则 VMID[VMIDLEN-1:0] 可写。 VMIDLEN 的最大值（称为 VMIDMAX）对于 Sv32x4 为 7，对于 Sv39x4、Sv48x4 和 Sv57x4 为 14。</p>
<p>出于地址转换算法的目的，<strong>hgatp</strong> 寄存器被视为活动的，除非有效特权模式为 U 并且 hstatus.HU&#x3D;0。</p>
<blockquote>
<p>此定义简化了 HLV、HLVX 和 HSV 指令的推测执行的实现。</p>
</blockquote>
<p>请注意，编写 <strong>hgatp</strong> 并不意味着页表更新和后续G-stage 地址转换之间存在任何顺序约束。如果新虚拟机的 guest 物理页表已被修改，或者 VMID 被重用，则可能需要在写入 <strong>hgatp</strong> 之前或之后执行 HFENCE.GVMA 指令（请参见第 8.3.2 节）。</p>
<h3 id="8-2-11-Virtual-Supervisor-状态寄存器-vsstatus"><a href="#8-2-11-Virtual-Supervisor-状态寄存器-vsstatus" class="headerlink" title="8.2.11 Virtual Supervisor 状态寄存器 (vsstatus)"></a>8.2.11 Virtual Supervisor 状态寄存器 (vsstatus)</h3><p>vsstatus寄存器是一个vslen位的读写寄存器，它是VS模式的管理寄存器sstatus的版本，当VSXLEN&#x3D;32时格式如图8.21所示，当VSXLEN&#x3D;64时格式如图8.22所示。当V&#x3D;1时，vsstatus代替了通常的sstatus，因此通常读取或修改sstatus的指令实际上访问的是vsstatus。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619155804871-1730798006988-98.png" alt="image-20230619155804871"></p>
<p>UXL字段控制VU模式的有效XLEN，它可能不同于vmode的XLEN (VSXLEN)。</p>
<p>当VSXLEN&#x3D;32时，表示UXL字段不存在，且u -mode XLEN&#x3D;32。</p>
<p>当VSXLEN&#x3D;64时，UXL是一个与misa的MXL字段编码相同的WARL字段，如第16页的表3.1所示。具体来说，实现可能会使UXL成为hstatus字段VSXL的只读副本，从而强制使用VU模式XLEN&#x3D;VSXLEN。</p>
<p>如果将VSXLEN从32更改为更宽的宽度，并且如果字段UXL不限制为单个值，则它将获得与支持的最宽宽度相对应的值，该宽度不大于新的VSXLEN。</p>
<p>当V&#x3D;1时，vsstatus.FS和HS级sstatus.FS均有效。当任一字段为 0（关闭）时尝试执行浮点指令会引发非法指令异常。当 V&#x3D;1 时修改浮点状态会导致两个字段都设置为 3（Dirty）。</p>
<blockquote>
<p>要使系统hypervisor受益于扩展上下文状态，它必须在HS级状态下拥有自己的副本，独立于以VS模式运行的guest OS进行维护。虽然扩展上下文状态的一个版本显然必须存在于VS模式的vsstatus中，但虚拟机监控程序不能依赖于正确维护该版本，因为VS级别的软件可以更改vsstatus。任意FS。如果HS-level状态为。FS不是独立活动的，由硬件与vsstatus并行维护。当V&#x3D;1时，hypervisor在虚拟机之间进行上下文切换时总是被迫保守地交换所有浮点状态。</p>
<p>为了使hypervisor从扩展上下文状态中受益，它必须在 HS 级别状态中有自己的副本，独立于在 VS 模式下运行的guest OS进行维护。虽然 VS 模式的扩展上下文状态的一个版本显然必须存在于 vsstatus 中，但hypervisor不能依赖此版本正确维护，因为 VS 级别的软件可以任意更改 vsstatus.FS。如果在 V&#x3D;1 时 HS 级别的 sstatus.FS 不是独立活动的并且由硬件与 vsstatus.FS 并行维护，则在虚拟机之间进行上下文切换时，Hypervisor将始终被迫保守地交换所有浮点状态。</p>
</blockquote>
<p>当V&#x3D;1时，vsstatus.VS和HS级sstatus.VS都有效。当任何一个字段为0 (Off)时，尝试执行向量指令将引发非法指令异常。当V&#x3D;1时修改向量状态会导致两个字段都被设置为3 (Dirty)。</p>
<p>只读字段SD和XS概述了扩展上下文状态，因为它仅对VS模式可见。例如HS级别的sstatus.FS的值不会影响vsstatus.SD。</p>
<p>实现可以使UBE字段成为hstatus.VSBE的只读副本。</p>
<p>当 V&#x3D;0 时，vsstatus 不会直接影响机器的行为，除非虚拟机加载&#x2F;存储（HLV、HLVX 或 HSV）或 mstatus 寄存器中的 MPRV 功能用于执行加载或存储，就像V&#x3D;1。</p>
<h3 id="8-2-12-Virtual-Supervisor-中断寄存器-vsip-and-vsie"><a href="#8-2-12-Virtual-Supervisor-中断寄存器-vsip-and-vsie" class="headerlink" title="8.2.12 Virtual Supervisor 中断寄存器 (vsip and vsie)"></a>8.2.12 Virtual Supervisor 中断寄存器 (vsip and vsie)</h3><p>vsip 和 vsie 寄存器是 VSXLEN 位读&#x2F;写寄存器，它们是管理器 CSR sip 和 sie 的 VS 模式版本，格式分别如图 8.23 和 8.24 所示。当V&#x3D;1时，vsip和vsie替代通常的sip和sie，因此通常读取或修改sip&#x2F;sie的指令实际上访问vsip&#x2F;vsie。然而，当 V&#x3D;1 时，针对 HS 级的中断继续在 HS 级 sip 寄存器中指示，而不是在 vsip 中。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619160157312-1730798006988-100.png" alt="image-20230619160157312"></p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619160224321-1730798006988-101.png" alt="image-20230619160224321"></p>
<p>寄存器vsip和vsie的标准部分(位15:0)分别格式化如图8.25和8.26所示。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619160338892-1730798006988-102.png" alt="image-20230619160338892"></p>
<ul>
<li><p>当hideleg的第10位为零时，vsip.SEIP和vsie.SEIE为只读零。否则，vsip.SEIP和vsie.SEIE是hip.VSEIP和hie.VSEIE的别名。</p>
</li>
<li><p>当hideleg的第6位为零时，vsip.STIP和vsie.STIE为只读零。否则，vsip.STIP和vsie.STIE是hip.VSTIP和hie.VSTIE的别名。</p>
</li>
<li><p>当hideleg的第2位为零时，vsip.SSIP和vsie.SSIE为只读零。否则，vsip.SSIP和vsie.SSIE是hip.VSSIP和hie.VSSIE的别名。</p>
</li>
</ul>
<h3 id="8-2-13-Virtual-Supervisor-陷阱向量基址寄存器-vstvec"><a href="#8-2-13-Virtual-Supervisor-陷阱向量基址寄存器-vstvec" class="headerlink" title="8.2.13 Virtual Supervisor 陷阱向量基址寄存器 (vstvec)"></a>8.2.13 Virtual Supervisor 陷阱向量基址寄存器 (vstvec)</h3><p>vstvec 寄存器是一个 VSXLEN 位读&#x2F;写寄存器，是 VS 模式版本的supervisor寄存器 stvec，格式如图 8.27 所示。当V&#x3D;1时，vstvec替代通常的stvec，因此通常读取或修改stvec的指令实际上访问vstvec。当V&#x3D;0时，vstvec不会直接影响机器的行为。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619160640694-1730798006988-103.png" alt="image-20230619160640694"></p>
<h3 id="8-2-14-Virtual-Supervisor-暂存寄存器-vsscratch"><a href="#8-2-14-Virtual-Supervisor-暂存寄存器-vsscratch" class="headerlink" title="8.2.14 Virtual Supervisor 暂存寄存器 (vsscratch)"></a>8.2.14 Virtual Supervisor 暂存寄存器 (vsscratch)</h3><p>vsscratch 寄存器是一个 VSXLEN 位读&#x2F;写寄存器，是 VS 模式的supervisor寄存器 sscratch 的版本，格式如图 8.28 所示。当 V&#x3D;1 时，vsscratch 会替代通常的 sscratch，因此通常读取或修改 sscratch 的指令实际上会访问 vsscratch。 vsscratch 的内容永远不会直接影响机器的行为。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619161552863-1730798006988-104.png" alt="image-20230619161552863"></p>
<h3 id="8-2-15-Virtual-Supervisor-异常程序计数器-vsepc"><a href="#8-2-15-Virtual-Supervisor-异常程序计数器-vsepc" class="headerlink" title="8.2.15 Virtual Supervisor 异常程序计数器 (vsepc)"></a>8.2.15 Virtual Supervisor 异常程序计数器 (vsepc)</h3><p>vsepc寄存器是一个VSXLEN位读&#x2F;写寄存器，它是VS模式的supervisor寄存器sepc版本，格式如图8.29所示。当V&#x3D;1时，vsepc代替了通常的sepc，因此通常读取或修改sepc的指令实际上会访问vsepc。当V&#x3D;0时，vsepc不会直接影响机器的行为。</p>
<p>vsepc是一个WARL寄存器，它必须能够保存sepc可以保存的相同值集。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619161636601-1730798006988-105.png" alt="image-20230619161636601"></p>
<h3 id="8-2-16-Virtual-Supervisor-原因寄存器-vscause"><a href="#8-2-16-Virtual-Supervisor-原因寄存器-vscause" class="headerlink" title="8.2.16 Virtual Supervisor 原因寄存器 (vscause)"></a>8.2.16 Virtual Supervisor 原因寄存器 (vscause)</h3><p>vscause寄存器是一个VSXLEN位读&#x2F;写寄存器，它是VS模式的supervisor寄存器scause版本，格式如图8.30所示。当V&#x3D;1时，vscause会替代通常的scause，因此通常读取或修改scause的指令实际上会访问vscause。当V&#x3D;0时，vscause不会直接影响机器的行为。</p>
<p>vscause是一个WLRL寄存器，它必须能够保存scause可以保存的相同值集。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619161708479-1730798006988-107.png" alt="image-20230619161708479"></p>
<h3 id="8-2-17-Virtual-Supervisor-陷阱值寄存器-vstval"><a href="#8-2-17-Virtual-Supervisor-陷阱值寄存器-vstval" class="headerlink" title="8.2.17 Virtual Supervisor 陷阱值寄存器 (vstval)"></a>8.2.17 Virtual Supervisor 陷阱值寄存器 (vstval)</h3><p>vstval寄存器是一个VSXLEN位读&#x2F;写寄存器，它是VS模式的supervisor寄存器stval版本，格式如图8.31所示。当V＝1时，vstval代替通常的stval，因此通常读取或修改stval的指令实际上访问vstval。当V&#x3D;0时，vstval不会直接影响机器的行为。</p>
<p>vstval是一个WARL寄存器，它必须能够保存stval可以保存的相同值集。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619161742529-1730798006988-106.png" alt="image-20230619161742529"></p>
<h3 id="8-2-18-Virtual-Supervisor-地址转换和保护寄存器-vsatp"><a href="#8-2-18-Virtual-Supervisor-地址转换和保护寄存器-vsatp" class="headerlink" title="8.2.18 Virtual Supervisor 地址转换和保护寄存器  (vsatp)"></a>8.2.18 Virtual Supervisor 地址转换和保护寄存器  (vsatp)</h3><p>vsatp寄存器是一个VSXLEN位读&#x2F;写寄存器，它是supervisor satp寄存器的VS模式版本，对于VSXLEN&#x3D;32，其格式如图8.32所示，对于VSXL EN&#x3D;64，其格式见图8.33。</p>
<p>当V&#x3D;1时，vsatp代替了通常的satp，因此通常读取或修改satp的指令实际上访问了vsatp。vsatp控制VS阶段地址转换，即guest virtual addresses的两阶段转换的第一阶段（见第8.5节）。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619161821642-1730798006988-108.png" alt="image-20230619161821642"></p>
<p>为了地址转换算法的目的，vsatp寄存器被认为是活动的，除非有效特权模式是U并且hstatus.HU&#x3D;0。然而，即使vsatp处于活动状态，VS阶段页表条目的A位也不能作为推测执行的结果而设置，除非有效的特权模式是VS或VU。</p>
<blockquote>
<p>特别是，错误执行的虚拟机加载&#x2F;存储（HLV、HLVX或HSV）指令不得导致VS阶段A位被设置。</p>
</blockquote>
<p>当V&#x3D;0时，对vsatp写入不支持的MODE值不会像对satp那样被忽略。相反，vsatp的字段以正常方式为WARL。</p>
<p>当V&#x3D;0时，vsatp不会直接影响机器的行为，除非虚拟机加载&#x2F;存储（HLV、HLVX或HSV）或mstatus寄存器中的MPRV功能被用来执行加载或存储，就像V&#x3D;1一样。</p>
<h2 id="8-3-Hypervisor-Instructions"><a href="#8-3-Hypervisor-Instructions" class="headerlink" title="8.3 Hypervisor Instructions"></a>8.3 Hypervisor Instructions</h2><p>系统hypervisor扩展添加了虚拟机加载和存储指令以及两条特权围栏指令。</p>
<h3 id="8-3-1-Hypervisor-Virtual-Machine-Load-and-Store-Instructions"><a href="#8-3-1-Hypervisor-Virtual-Machine-Load-and-Store-Instructions" class="headerlink" title="8.3.1 Hypervisor Virtual-Machine Load and Store Instructions"></a>8.3.1 Hypervisor Virtual-Machine Load and Store Instructions</h3><p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619162256524-1730798006988-109.png" alt="image-20230619162256524"></p>
<p>虚拟机监控程序虚拟机加载和存储指令仅在M模式或HS模式下有效，或在hstatus.HU&#x3D;1时在U模式下有效。每个指令执行显式存储器访问，就好像V＝1一样；即，具有适用于VS模式或VU模式下的存储器访问的地址转换和保护以及端序。hstatus的字段SPVP控制访问的权限级别。显式存储器访问在SPVP&#x3D;0时如同在VU模式下进行，并且在SPVP&#x3D;1时如同在VS模式下进行。通常，当V&#x3D;1时，应用两阶段地址转换，并且忽略HS级别sstatus.SUM。HS级别的sstatus.MXR使地址转换的两个阶段（VS阶段和G-stage）都可以读取仅执行页面，而vsstatus.MKR仅影响第一个转换阶段（VS步骤）。</p>
<p>对于每个RV32I或RV64I加载指令LB、LBU、LH、LHU、LW、LWU和LD，都有一个相应的虚拟机加载指令：HLV.B、HLV.BU、HLV.H、HLV.HU、HLV.W、HLV.WU和HLV.D。</p>
<p>对于每个RV32I或RV64I存储指令SB、SH、SW和SD，都有一个相应的虚拟机存储指令：HSV.B、HSV.H、HSV.W和HSV.D。</p>
<p>当然，指令HLV.WU、HLV.D和HSV.D对RV32无效。</p>
<p>指令HLVX.HU和HLVX.WU与HLV.HU和HLV.WU相同，只是在地址转换过程中执行权限代替读取权限。也就是说，被读取的内存必须在地址转换的两个阶段都是可执行的，但不需要读取权限。对于由地址转换产生的Supervisor物理地址，Supervisor物理内存属性必须同时授予执行和读取权限。（Supervisor物理内存属性是由物理内存保护第3.7节针对Supervisor级别修改的机器物理内存属性。）</p>
<blockquote>
<p>HLVX无法覆盖机器级物理内存保护（PMP），因此尝试读取PMP指定为仅执行的内存仍然会导致访问故障异常。</p>
</blockquote>
<p>HLVX.WU对RV32有效，即使LWU和HLV.WU无效。（对于RV32，HLVX.WU可以被视为HLV.W的变体，因为符号扩展与32位值无关。）</p>
<p>当V&#x3D;1时，试图执行虚拟机加载&#x2F;存储指令（HLV、HLVX或HSV）会导致虚拟指令陷阱。当hstatus.HU&#x3D;0时，尝试从U模式执行其中一条相同的指令会导致非法的指令陷阱。</p>
<h3 id="8-3-2-Hypervisor-Memory-Management-Fence-Instructions"><a href="#8-3-2-Hypervisor-Memory-Management-Fence-Instructions" class="headerlink" title="8.3.2 Hypervisor Memory-Management Fence Instructions"></a>8.3.2 Hypervisor Memory-Management Fence Instructions</h3><p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619162926132-1730798006988-110.png" alt="image-20230619162926132"></p>
<p>hypervisor内存管理围栏指令HFENCE.VMA和HFENCE.GVMA执行类似于SFENCE.VMA的功能（第4.2.1节），除了应用于由CSR vsatp（HFENCE.VVMA）控制的VS级存储器管理数据结构或由CSR hgatp（HFANCE.GVMA）控制（guestphysical memory management data structures）。指令SFENCE.VMA仅应用于由当前satp控制的存储器管理数据结构（当V&#x3D;0时为HS级satp或当V&#x3D;1时为vsatp）。</p>
<p>HFNCE.VVMA仅在M模式或HS模式下有效。它的效果与暂时进入VS模式并执行SFENCE.VMA大致相同。执行HFENCE..VVMA保证当前hart已经可见的任何先前存储在VS级内存管理数据结构的hart的所有后续隐式读取之前进行排序，而这些隐式读取是针对</p>
<ul>
<li>在HFNCE.VVMA之后，并且</li>
<li>当hgatp.VMID具有与执行HFENCE.VMA时相同的设置时执行。</li>
</ul>
<p>当hgatp.VMID与执行HFNCE.VVMA时不同时，无需对隐式读取进行排序。如果操作数&#x3D;&#x3D;<strong>rs1$\neq$x0</strong>&#x3D;&#x3D;，则指定单个guest虚拟地址；如果操作数&#x3D;&#x3D;<strong>rs2$\neq$x0</strong>&#x3D;&#x3D;，则规定单个guest地址空间标识符（ASID）。</p>
<blockquote>
<p>HFENCE.VMA指令仅适用于单个虚拟机，该虚拟机由HFENCE.VMA执行时hgatp.VMID的设置标识。</p>
</blockquote>
<p>当rs2$\neq$x0时，rs2中保持的值的位XLEN-1:ASIDMAX被保留以供将来的标准使用。在它们的使用被标准扩展定义之前，它们应该被软件归零，而被当前的实现忽略。此外，如果ASIDLEN&lt;ASIDMAX，则实现应忽略rs2中保持的值的位ASIDMAX-1:ASIDLEN。</p>
<blockquote>
<p>HFNCE.VVMA的更简单实现可以忽略rs1中的guest virtual addresses和rs2中的客户ASID值，以及hgatp.VMID，并始终为所有虚拟机的VS级内存管理执行全局围栏，甚至为所有内存管理数据结构执行全局围栏。</p>
</blockquote>
<p>mstatus.TVM和hstatus.VTVM都不会导致HFNCE.VVMA陷入陷阱。</p>
<p>当mstatus.TVM&#x3D;0时，HFENCE.GVMA仅在HS模式下有效，或在M模式下有效（与mstatus.TVM无关）。执行HFENCE.GVMA指令可确保当前hart已经可见的任何先前存储都在该hart为遵循HFENCE.GVMA的指令执行的guest物理内存管理数据结构的所有后续隐式读取之前排序。如果操作数rs1̸&#x3D;x0，它指定单个guest物理地址，右移2位，如果操作数rs2̸&#x3D;x0，则指定单个虚拟机标识符（VMID）。</p>
<blockquote>
<p>就像在陷阱上写入htval的guest physical addresses一样，rs1中指定的客户物理寻址被右移2位，以适应比当前XLEN更宽的地址。</p>
</blockquote>
<p>当rs2$\neq$x0时，rs2中保持的值的位XLEN-1:VMIDMAX被保留以供将来的标准使用。</p>
<p>在它们的使用被标准扩展定义之前，它们应该被软件归零，而被当前的实现忽略。此外，如果VMIDLEN＜VMIDMAX，则该实现将忽略rs2中保持的值的位VMIDMAX-1:VMIDLEN。</p>
<blockquote>
<p>HFENCE.GVMA的更简单实现可以忽略rs1中的guest physical addresses和rs2中的VMID值，并始终为所有虚拟机的客户物理内存管理执行全局围栏，甚至为所有内存管理数据结构执行全局围栏。</p>
</blockquote>
<p>如果为给定的VMID更改hgatp.MODE，则必须执行rs1&#x3D;x0（且rs2设置为x0或VMID）的HFENCE.GVMA，以便在MODE更改的情况下订购后续客户翻译，即使旧的MODE或新的MODE为Bare。</p>
<p>当V&#x3D;1时，尝试执行HFENCE.VMA或HFENCE.GVMA会导致虚拟指令陷阱，而在U模式下尝试执行同样的操作会导致非法指令陷阱。当mstatus.TVM&#x3D;1时，试图在HS模式下执行HFENCE.GVMA也会导致非法的指令陷阱。</p>
<h2 id="8-4-Machine-Level-CSR"><a href="#8-4-Machine-Level-CSR" class="headerlink" title="8.4  Machine-Level CSR"></a>8.4  Machine-Level CSR</h2><p>系统hypervisor扩展增强或修改了机器CSR mstatus、mstatush、mideleg、mip和mie，并添加了CSR mtval2和mtinst。</p>
<h3 id="8-4-1-机器状态寄存器（mstatus和mstatush）"><a href="#8-4-1-机器状态寄存器（mstatus和mstatush）" class="headerlink" title="8.4.1 机器状态寄存器（mstatus和mstatush）"></a>8.4.1 机器状态寄存器（mstatus和mstatush）</h3><p>系统hypervisor扩展将<strong>MPV</strong>和<strong>GVA</strong>两个字段添加到机器级mstatus或mstatus-CSR，并修改几个现有mstatus字段的行为。图8.34显示了在实现虚拟机监控程序扩展并且MXLEN&#x3D;64时修改的mstatus寄存器。当MXLEN&#x3D;32时，系统hypervisor扩展程序将MPV和GVA添加到mstatush，而不是mstatus。图8.35显示了当系统hypervisor扩展被实现并且MXLEN&#x3D;32时的mstatush寄存器。</p>
<p>每当陷阱进入M模式时，<strong>MPV</strong>（机器先前的虚拟化模式）都由实现写入。正如MPP字段在陷阱时被设置为（标称）特权模式一样，MPV bit 在陷阱时也被设置为虚拟化模式V的值。当执行MRET指令时，虚拟化模式V被设置为MPV，除非MPP＝3，在这种情况下V保持为0。</p>
<p>每当陷阱进入M模式时，<strong>GVA</strong>（guest虚拟地址）由实现写入。对于将guest虚拟地址写入mtval的任何陷阱（断点、地址未对齐、访问错误、页面错误或guest页面错误），GVA设置为1。对于进入M模式的任何其他陷阱，GVA设置为0。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619164229777-1730798006988-111.png" alt="image-20230619164229777"></p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619164410329-1730798006988-112.png" alt="image-20230619164410329"></p>
<p>mstatus的TSR和TVM字段仅在HS模式下影响执行，而在VS模式下不影响执行。TW字段影响除M模式以外的所有模式下的执行。</p>
<p>设置TVM&#x3D;1可防止HS模式访问hgatp或执行HFENCE.GVMA或HINVAL.VMA，但对访问vsatp或指令HFENCE.VMA或HINVAL.VVMA没有影响。</p>
<blockquote>
<p>TVM存在于mstatus中，允许机器级软件修改由Supervisor级OS管理的地址转换，通常是为了在OS控制的地址转换下面插入另一个地址转换阶段。TVM&#x3D;1启用的指令陷阱允许机器级同时选择satp和hgatp，并替换影子页表，这些影子页表将OS选择的页翻译与M级的低级翻译合并在一起，而OS对此一无所知。M级软件不仅需要这种能力来模拟hypervisor扩展（如果尚未支持的话），而且还需要模拟任何未来的RISC-V扩展，这些扩展可能会修改或添加地址转换阶段，例如，以提高对嵌套hypervisor的支持，即在其他hypervisor之上运行hypervisor。</p>
<p>然而，设置TVM&#x3D;1不会导致访问vsatp或指令HFENCE.VMA或HINVAL.VVMA的陷阱，也不会导致在VS模式下采取的任何操作的陷阱，因为M级软件预计不需要参与VS阶段地址转换。对于虚拟机来说，只保留VS阶段地址转换，并将所有其他转换阶段合并到由hgatp控制的G-stage阴影页表中，就足够了，而且很可能更快。这一假设确实对当前机器能够有效模拟的未来可能的RISC-V扩展设置了一些限制。</p>
</blockquote>
<p><strong>系统hypervisor扩展更改mstatus的Modify Privilege字段MPRV的行为</strong>。当MPRV&#x3D;0时，转换和保护行为正常。当MPRV&#x3D;1时，显式存储器访问被转换和保护，并且端序被应用，就好像当前虚拟化模式被设置为MPV并且当前标称特权模式被设置成MPP一样。表8.5列举了这些案例。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619165141590-1730798006988-113.png" alt="image-20230619165141590"></p>
<table>
<thead>
<tr>
<th align="center">MPRV</th>
<th align="center">MPV</th>
<th align="center">MPP</th>
<th>Effect</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">-</td>
<td align="center">-</td>
<td>正常访问；当前特权模式适用。</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td>仅提供HS级翻译和保护的U级访问。</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td>仅提供HS级翻译和保护的HS级访问。</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">-</td>
<td align="center">3</td>
<td>M级访问，无需翻译。</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td>VU级访问，具有两阶段翻译和保护功能。HS-level MXR位使任何可执行页面都可读。<br>vsstatus.MXR使那些在VS翻译阶段标记为可执行的页面可读，但前提是在guest物理翻译阶段可读。</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td>VS级访问，具有两阶段翻译和保护功能。HS-level MXR位使任何可执行页面都可读。<br>vsstatus.MXR使那些在VS翻译阶段标记为可执行的页面可读，但前提是在guest物理翻译阶段可读。<br>vsstatus.SUM取代HS-level SUM位。</td>
</tr>
</tbody></table>
<p>表8.5:MPRV对显式内存访问的翻译和保护的影响。</p>
<p>MPRV不影响虚拟机加载&#x2F;存储指令、HLV、HLVX和HSV。这些指令的显式加载和存储总是像V&#x3D;1一样，并且标称特权模式是hstatus.SSPP，覆盖MPRV。</p>
<p>mstatus寄存器是HS级sstatus寄存器的超集，但不是vsstatus的超集。</p>
<h3 id="8-4-2-机器中断委托寄存器-mideleg"><a href="#8-4-2-机器中断委托寄存器-mideleg" class="headerlink" title="8.4.2 机器中断委托寄存器(mideleg)"></a>8.4.2 机器中断委托寄存器(mideleg)</h3><p>当实现hypervisor扩展时，<strong>mideleg的第10、6和2位(对应于标准的VS级中断)都是只读的</strong>。此外，如果实现了任何客户机外部中断(GEILEN非零)，则mideleg的第12位(对应于Supervisor级客户机外部中断)也是只读位。<strong>VS级中断和guest外部中断总是从M模式委派到HS模式</strong>。</p>
<p>对于mideleg的位为零，hideleg、hip和hie中的相应位为只读零。</p>
<h3 id="8-4-3-机器中断寄存器-mip和mie"><a href="#8-4-3-机器中断寄存器-mip和mie" class="headerlink" title="8.4.3 机器中断寄存器(mip和mie)"></a>8.4.3 机器中断寄存器(mip和mie)</h3><p>hypervisor扩展为hypervisor添加的中断为寄存器mip和mie提供了额外的活动位。图8.36和8.37显示了实现hypervisor扩展时寄存器mip和mie的标准部分(15:0位)。</p>
<p>mip中的SGEIP、VSEIP、VSTIP、VSSIP是hypervisor CSR hip中相同位的别名</p>
<p>mie中的SGEIE、VSEIE、VSTIE、VSSIE是hypervisor CSR hie中相同位的别名。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619171652730-1730798006988-114.png" alt="image-20230619171652730"></p>
<h3 id="8-4-4-机器第二陷阱值寄存器-mtval2"><a href="#8-4-4-机器第二陷阱值寄存器-mtval2" class="headerlink" title="8.4.4 机器第二陷阱值寄存器(mtval2)"></a>8.4.4 机器第二陷阱值寄存器(mtval2)</h3><p>mtval2寄存器是一个mxlen位读&#x2F;写寄存器，格式如图8.38所示。当一个陷阱进入M模式时，除了mtval之外，还将使用附加的异常特定信息编写mtval2，以帮助软件处理陷阱。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619171747318-1730798006988-115.png" alt="image-20230619171747318"></p>
<p>当客户机页面错误陷阱进入M模式时，将用零或出错的客户机物理地址向右移动2位来写入mtval2。对于其他陷阱，mtval2设置为零，但未来的标准或扩展可能会为其他陷阱重新定义mtval2的设置。</p>
<p>如果客户机页面故障是由于第一阶段(VS阶段)地址转换期间的隐式内存访问造成的，那么写入mtval2的客户机物理地址就是发生故障的隐式内存访问的物理地址。CSR mist中提供了其他信息以消除这种情况的歧义。</p>
<p>否则，对于导致客户机页面错误的未对齐的加载和存储，mtval2中的非零客户机物理地址对应于mtval中的虚拟地址所指示的访问的错误部分。对于具有变长指令的系统上的指令访客页面错误，非零的mtval2对应于由mtval中的虚拟地址所指示的指令的错误部分。</p>
<p>mtval2是一个WARL寄存器，它必须能够保存0，并且可能只能够保存其他2位移位的guest physical addresses的任意子集(如果有的话)。</p>
<h3 id="8-4-5-机器陷阱指令寄存器-mtinst"><a href="#8-4-5-机器陷阱指令寄存器-mtinst" class="headerlink" title="8.4.5 机器陷阱指令寄存器(mtinst)"></a>8.4.5 机器陷阱指令寄存器(mtinst)</h3><p>mtinst寄存器是一个mxlen位读&#x2F;写寄存器，格式如图8.39所示。当一个陷阱进入M模式时，mtinst被写入一个值，如果该值非零，则提供有关被捕获的指令的信息，以帮助软件处理该陷阱。可以在trap上写入mtinst的值在第8.6.3节中有文档说明。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619171852916-1730798006988-116.png" alt="image-20230619171852916"></p>
<p>mtinst是一个WARL寄存器，它只需要能够保存实现可能在陷阱时自动写入它的值。</p>
<h2 id="8-5-两阶段地址转换"><a href="#8-5-两阶段地址转换" class="headerlink" title="8.5 两阶段地址转换"></a>8.5 两阶段地址转换</h2><p>每当 当前虚拟化模式V为1时，两阶段地址转换和保护生效。</p>
<p>对于任何虚拟内存访问，原始虚拟地址在<strong>第一阶段</strong>通过VS级地址转换(由<strong>vsatp</strong>寄存器控制)转换为guest physical addresses。</p>
<p>然后，在<strong>第二阶段</strong>，由<strong>hgatp</strong>寄存器控制的guest物理地址转换将guest物理地址转换为Supervisor物理地址。这两个阶段也被称为VS阶段和G-stage的翻译。虽然在V&#x3D;1时没有禁用两阶段地址转换的选项，但是通过将相应的vsatp或hgatp寄存器调零，可以有效地禁用两阶段转换。</p>
<p>每当当前虚拟化模式V为1时，两级地址转换和保护就生效。</p>
<ul>
<li>对于任何虚拟内存访问，原始虚拟地址(original <strong>virtual address</strong>)在第一阶段通过 VS 级地址转换（由 <strong>vsatp</strong> 寄存器控制）转换为<strong>guest physical addresses</strong>。</li>
<li>然后，在第二阶段，<strong>guest physical addresses</strong>通过guest physical addresses translation（由 <strong>hgatp</strong> 寄存器控制）转换为supervisor physical address。</li>
</ul>
<p>这两个阶段也称为 <strong>VS-stage</strong>和 <strong>G-stage</strong>翻译。尽管当 V&#x3D;1 时没有禁用两级地址转换的选项，但可以通过清零 vsatp 或 hgatp 寄存器来有效地禁用任一级地址转换。</p>
<p>vsstatus.MXR 使 <strong>只执行页面</strong>(execute-only pages) 可读，仅覆盖(overrides) VS-stage页面保护。在 VS 级别设置 MXR 不会覆盖guest-physical page保护。但是，在 HS 级别设置 MXR 会覆盖 VS-stage和 G-stage仅执行权限。</p>
<p>当V&#x3D;1时，通常绕过地址转换的内存访问只服从G-stage地址转换。这包括为支持VS级地址转换而进行的内存访问，例如VS级页表的读取和写入。</p>
<p>机器级物理内存保护适用于supervisor physical addresses，并且无论虚拟化模式如何都有效。</p>
<h3 id="8-5-1-Guest-Physical-Address转换"><a href="#8-5-1-Guest-Physical-Address转换" class="headerlink" title="8.5.1 Guest Physical Address转换"></a>8.5.1 Guest Physical Address转换</h3><p>guest physical addresses到supervisor physical addresses的映射由CSR hgatp控制(章节8.2.10)。</p>
<p>当hgatp的MODE字段选择的地址转换方案为Bare时，无需修改，guest物理地址等于Supervisor物理地址，并且在从guest物理地址到Supervisor物理地址的简单转换中不使用内存保护。</p>
<p>当hgatp.MODE指定Sv32x4、Sv39x4、Sv48x4或Sv57x4的转换方案，G-stage地址转换是Sv32、Sv39、Sv48或Sv57的基于页面的虚拟地址转换方案的变体。在每种情况下，入站地址的大小都被加宽2位(34,41或50位)。为了容纳额外的2位，根页表(仅根页表)被扩展了4倍，变为16 KiB，而不是通常的4 KiB。与其更大的大小相匹配，根页表也必须对齐到16 KiB边界，而不是通常的4 KiB页面边界。</p>
<p>除特别说明外，在G-stage翻译中，均采用Sv32、Sv39、Sv48、Sv57的其他方面不变。非根页表和所有页表项(pte)的格式与第4.3、4.4、4.5和4.6节中记录的格式相同。</p>
<p>对于Sv32x4，传入guest物理地址被划分为虚拟页码(VPN)和页面偏移量，如图8.40所示。这个分区与图4.16所示的Sv32虚拟地址的分区相同，只是在VPN的高端多了2位[1]。(注意，分区客户机物理地址的字段也与Sv32分配给物理地址的结构一一对应，如图4.17所示。)</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619172226512-1730798006988-117.png" alt="image-20230619172226512"></p>
<p>对于Sv39x4，传入guest物理地址被分区，如图8.41所示。这个分区与图4.19所示的Sv39虚拟地址的分区相同，只是在VPN的高端多了2位[2]。地址位63:41必须全部为零，否则会发生客户页面错误异常。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619172242100-1730798006988-118.png" alt="image-20230619172242100"></p>
<p>对于Sv48x4，传入guest物理地址被分区，如图8.42所示。这个分区与图4.22所示的Sv48虚拟地址的分区相同，只是在VPN的高端多了2位[3]。地址位63:50必须全部为零，否则会发生客户页面错误异常。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619172306796-1730798006988-119.png" alt="image-20230619172306796"></p>
<p>对于Sv57x4，传入guest物理地址被分区，如图8.43所示。这个分区与图4.25所示的Sv57虚拟地址的分区相同，只是在VPN的高端多了2位[3]。地址位63:50必须全部为零，否则会发生客户页面错误异常。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230619172325999-1730798006988-120.png" alt="image-20230619172325999"></p>
<blockquote>
<p>RV32的基于页面的G-stage地址转换方案Sv32x4被定义为支持34位guest物理地址，因此RV32hypervisor不需要限制其虚拟化实际32位RISC-V机器的能力，即使是那些具有33位或34位物理地址的机器。如果机器碰巧使用33位或34位物理地址，这可能包括对其自身进行虚拟化的可能性。将根页表的大小和对齐方式乘以4倍是扩展Sv32以覆盖34位地址的最便宜的方法。对于大多数(可能是所有)实际使用来说，不必要的大根页表可能造成的12 KiB的浪费可以忽略不计。</p>
<p>对物理地址空间是虚拟地址空间四倍的机器进行虚拟化的一致能力被认为对RV64也有一定的用处。例如，对于实现39位虚拟地址(Sv39)的机器，这允许hypervisor扩展最多支持41位guest物理地址空间，而不需要硬件支持48位虚拟地址(Sv48)，也不需要使用影子页表来模拟更大的地址空间。</p>
</blockquote>
<p>Sv32x4、Sv39x4、Sv48x4或Sv57x4 guest physical addresses的转换使用与第4.3.2节中介绍的Sv32、Sv39、Sv48或Sv57相同的算法完成，不同之处在于:</p>
<ul>
<li>hgatp代替通常的satp;</li>
<li>若要开始翻译，有效的特权模式必须是VS模式或VU模式;</li>
<li>检查位U时，始终取当前特权模式为U模式;和</li>
<li>引发guest-page-fault异常，而不是常规的page-fault异常。</li>
</ul>
<p>对于 G-stage 地址转换，所有内存访问(包括为VS阶段地址转换而访问数据结构的访问)都被认为是用户级访问，就像在U模式下执行一样。访问类型权限(可读、可写或可执行)在G-stage翻译期间进行检查，与VS阶段翻译相同。对于支持VS阶段地址转换的内存访问(例如读&#x2F;写VS级页表)，检查权限就像检查加载或存储一样，而不是检查原始访问类型。然而，对于原始访问类型(指令、加载或存储&#x2F;AMO)，总是报告任何异常。</p>
<p>所有G级pte中的G位都保留用于将来的标准使用。在标准扩展定义它的使用之前，软件应该清除它以实现向前兼容性，而硬件必须忽略它。</p>
<blockquote>
<p>G-stage 地址转换对pte使用与常规地址转换相同的格式，甚至包括U位，因为在G-stage 转换和常规HS级地址转换之间可能共享一些(或全部)页表。不管这种用法是否会变得普遍，我们选择不排除它。</p>
</blockquote>
<h3 id="8-5-2-Guest页错误"><a href="#8-5-2-Guest页错误" class="headerlink" title="8.5.2 Guest页错误"></a>8.5.2 Guest页错误</h3><p>Guest-page-fault trap可以在CSR medeleg的控制下从M模式委派到HS模式，但不能委派到其他特权模式。在客户机页面故障时，像往常一样使用发生故障的客户机虚拟地址写入CSR mtval或stval，而mtval2或htval要么使用零写入，要么使用发生故障的客户机物理地址写入，并向右移动2位。如第8.6.3节所述，还可以编写关于错误指令或访问的其他原因的信息。</p>
<p>当指令读取或内存访问不对齐跨越页面边界时，涉及两种不同的地址转换。在这种情况下发生客户页面故障时，写入mtval&#x2F;stval的故障虚拟地址与常规页面故障所需的虚拟地址相同。因此，如果页边界处的字节位于被访问的字节中，则故障虚拟地址可能是高于指令原始虚拟地址的页边界地址。</p>
<p>当客户页面故障不是由于VS阶段地址转换的隐式内存访问时，写入mtval2&#x2F;htval的非零guest physical addresses应与写入mtval&#x2F;stval的确切虚拟地址相对应。</p>
<h3 id="8-5-3-内存管理围栏"><a href="#8-5-3-内存管理围栏" class="headerlink" title="8.5.3 内存管理围栏"></a>8.5.3 内存管理围栏</h3><p>Memory-Management Fences</p>
<p>SFENCE的行为。VMA指令受当前虚拟化模式V的影响。当V&#x3D;0时，virtual-address参数为HS级虚拟地址，ASID参数为HS级ASID。指令指令仅存储到具有后续HS级地址转换的HS级地址转换结构中。</p>
<p>当V&#x3D;1时，虚拟地址参数为SFENCE。VMA是当前虚拟机中的guest虚拟地址，而ASID参数是当前虚拟机中的VS级ASID。当前虚拟机由CSR hgatp的VMID字段标识，有效的ASID可以认为是该VMID与VS级ASID的结合。<code>SFENCE.VMA</code>指令指令仅存储到VS级地址转换结构中，并在同一虚拟机中进行后续的VS级地址转换，即仅当hgatp。vid与SFENCE时相同。影响执行。</p>
<p>hypervisor指令<code>HFENCE.VVMA</code>和<code>HFENCE.GVMA</code>提供额外的内存管理栅栏来补充<code>senced.vma</code>。这些指令将在第8.3.2节中描述。</p>
<p>第3.7.2节讨论了物理内存保护(PMP)和基于页面的地址转换之间的交集。需要注意的是，当修改PMP设置的方式影响保存页表的物理内存或页表指向的物理内存时，M模式软件必须将PMP设置与虚拟内存系统同步。对于HS级地址转换，这是通过在M模式下执行一个SFENCE来完成的。在PMP CSR写入后，rs1&#x3D;x0和rs2&#x3D;x0的VMA指令。如果正在使用G-stage地址转换并且不是Bare，则还需要与其数据结构同步。当修改PMP设置的方式影响保存guest物理页表的物理内存或guest物理页表所指向的物理内存时，HFENCE。在PMP CSR写入后，必须以M模式执行rs1&#x3D;x0和rs2&#x3D;x0的GVMA指令。一个HFENCE。不需要VVMA指令。</p>
<h2 id="8-6-Traps"><a href="#8-6-Traps" class="headerlink" title="8.6 Traps"></a>8.6 Traps</h2><h3 id="8-6-1-Trap原因码"><a href="#8-6-1-Trap原因码" class="headerlink" title="8.6.1 Trap原因码"></a>8.6.1 Trap原因码</h3><p>hypervisor扩展扩展了陷阱原因编码。表8.6列出了实现hypervisor扩展时可能的M模式和HS模式trap原因码。添加了VS级中断(中断2、6、10)、Supervisor级guest外部中断(中断12)、虚拟指令异常(异常22)和guest页面错误(异常20、21、23)的代码。此外，来自VS模式的环境调用被分配原因10，而来自HS模式或S模式的调用通常使用原因9。</p>
<blockquote>
<p>HS模式和VS模式ECALLs使用不同的原因值，因此可以分别委托它们。</p>
</blockquote>
<p>当V&#x3D;1时，如果尝试的指令是HS合格的，但在V&#x3D;1时由于权限不足或由于指令被Supervisor程序或hypervisorCSR(如scounteren或hcounteren)明确禁用而无法执行，则通常会引发虚拟指令异常(代码22)，而不是非法指令异常。如果一条指令可以在HS模式下有效地执行(对于指令的寄存器操作数的某些值)，则该指令是HS合格的，假设CSR mstatus的字段TSR和TVM都为零。</p>
<p>对于访问32位高半CSR(如cycle、htimedelta)的CSR指令，有特殊的规则。当V&#x3D;1且XLEN&gt;32时，试图访问高阶Supervisor级CSR、高阶hypervisorCSR、高阶VS CSR或高阶无特权CSR总是引发非法指令异常。在VS模式中，如果VU模式的XLEN大于32，则访问高一半用户级CSR(不同于无特权CSR)的尝试总是引发非法指令异常。另一方面，当V&#x3D;1和XLEN&#x3D;32时，访问高一半S级、hypervisor、VS或无特权CSR的无效尝试会引发虚拟指令异常，而不是非法指令异常，如果合作伙伴低一半CSR的相同CSR指令(例如:cycle或htimedelta)是HS合格的。同样，在VS模式中，如果VU模式的XLEN为32，那么访问高一半用户级CSR的无效尝试将引发虚拟指令异常，而如果合作伙伴低一半CSR的相同CSR指令是HS合格的，则会引发非法指令异常。</p>
<blockquote>
<p>RISC-V特权架构目前没有定义用户级CSR，但它们可能会在该标准的未来版本或扩展中添加。</p>
</blockquote>
<img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V特权架构/image-20230620093251053-1730798006988-121.png" alt="image-20230620093251053" style="zoom:150%;">

<p>具体来说，在以下情况下会引发虚拟指令异常:</p>
<ul>
<li><p>在VS模式下，当hcounteren中对应位为0且mcounteren中同一位为1时，尝试访问非高半计数器CSR;</p>
</li>
<li><p>在VS模式中，如果XLEN &#x3D; 32，试图访问一个高半计数器CSR在相应的位hcounteren是0,同一位mcounteren是1;</p>
</li>
<li><p>在VU模式下，当hcounteren或scounteren中对应的位为0且mcounteren中相同的位为1时，尝试访问非高半计数器CSR;</p>
</li>
<li><p>在VU模式下，如果XLEN&#x3D;32，当hcounteren或scounteren中对应的位为0且mcounteren中相同的位为1时，尝试访问高半计数器CSR;</p>
</li>
<li><p>在VS模式或VU模式下，尝试执行hypervisor指令(HLV、HLVX、HSV或HFENCE);</p>
</li>
<li><p>在VS模式或VU模式中，当在HS模式中允许相同的访问(读&#x2F;写)时，尝试访问已实现的非高阶hypervisorCSR或VS CSR，假设status.TVM&#x3D;0;</p>
</li>
<li><p>假设mstatus.TVM&#x3D;0，在VS模式或VU模式下，如果XLEN&#x3D;32，尝试访问已实现的高半hypervisor CSR或高半VS CSR，而在HS模式下允许对CSR的低半伙伴进行相同的访问(读&#x2F;写);</p>
</li>
<li><p>在VU模式下，处于状态时尝试执行WFI。TW&#x3D;0，或者执行上级指令(SRET或SFENCE);</p>
</li>
<li><p>在VU模式中，当在HS模式中允许相同的访问(读&#x2F;写)时，尝试访问已实现的非高阶SupervisorCSR，假设mstatus.TVM&#x3D;0;</p>
</li>
<li><p>假设mstatus.TVM&#x3D;0，在VU模式下，如果XLEN&#x3D;32，尝试访问一个已实现的高半SupervisorCSR，而在HS模式下，对CSR的低半伙伴的访问是允许的;</p>
</li>
<li><p>在VS模式下，当hstatus.VTW&#x3D;1和mstatus.TW&#x3D;0时，尝试执行WFI，除非指令在特定于实现的有限时间内完成;</p>
</li>
<li><p>在VS模式下，当hstatus.VTSR&#x3D;1时，尝试执行SRET;</p>
</li>
<li><p>在VS模式下，尝试执行SFENCE。VMA或SINVAL。当hstatus.VTVM&#x3D;1时，VMA指令或访问satp。</p>
</li>
</ul>
<p>RISC-V特权架构的其他扩展可能会增加在V&#x3D;1时导致虚拟指令异常的情况集。</p>
<p>在虚拟指令陷阱中，mtval或stval的写入与非法指令陷阱相同。</p>
<blockquote>
<p>hypervisor必须模拟引发虚拟指令异常的指令，以支持嵌套hypervisor或出于其他原因，这是很常见的。通常期望机器级将虚拟指令陷阱直接委托给HS级，而非法指令陷阱可能首先在M模式中处理，然后(由软件)有条件地委托给HS级。因此，虚拟指令陷阱通常比非法指令陷阱处理得更快。</p>
<p>当不模拟捕获指令时，hypervisor应该将虚拟指令陷阱转换为客户虚拟机的非法指令异常。</p>
</blockquote>
<blockquote>
<p>由于处于状态的TSR和TVM旨在仅影响S模式(HS模式)，因此在确定VS模式中的异常时忽略它们。</p>
</blockquote>
<p>如果一条指令可能引发多个同步异常，表8.7中优先级递减的顺序指示了哪个异常被获取并在mcause或scause中报告。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620095034291-1730798006988-122.png" alt="image-20230620095034291"></p>
<h3 id="8-6-2-Trap表项"><a href="#8-6-2-Trap表项" class="headerlink" title="8.6.2 Trap表项"></a>8.6.2 Trap表项</h3><p>当trap在HS模式或U模式下发生时，它将进入M模式，除非由medelegate或mideleg委托，在这种情况下它将进入HS模式。当trap在VS模式或VU模式下发生时，它进入M模式，除非由medelegate或mideleg委托，在这种情况下，它进入HS模式，除非由hedeleg或hideleg进一步委托，在这种情况下，它进入VS模式。</p>
<p>当trap进入M模式时，虚拟化模式V设置为0,mstatus(或mstatush)中的MPV和MPP字段设置如表8.8所示。M模式的trap还写入mstatus&#x2F;mstatush中的GVA、MPIE和MIE字段，并写入CSR字段mepc、mcause、mtval、mtval2和mtinst。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620095148326-1730798006988-123.png" alt="image-20230620095148326"></p>
<p>当trap进入HS模式时，虚拟化模式V设置为0,hstatus设置为0。SPV和地位。SPP按表8.9设置。如果trap前V为1，则设置hstatus中的字段SPVP与status. spp相同;否则，SPVP保持不变。进入HS模式的trap还会在hstatus中写入字段GVA，在sstatus中写入字段SPIE和SIE，在CSR中写入字段sepc、cause、stval、htval和htinst。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620095233766-1730798006988-124.png" alt="image-20230620095233766"></p>
<p>当trap进入VS模式时，vsstatus。SPP按表8.10设置。不修改Register hstatus和HS-level sstatus，虚拟化模式V保持1。进入VS模式的trap还会在vsstatus中写入字段SPIE和SIE，并写入CSR vsepc、vcause和vstval。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620095311698-1730798006988-125.png" alt="image-20230620095311698"></p>
<h3 id="8-6-3-mtinst或htinst的转换指令或伪指令"><a href="#8-6-3-mtinst或htinst的转换指令或伪指令" class="headerlink" title="8.6.3 mtinst或htinst的转换指令或伪指令"></a>8.6.3 mtinst或htinst的转换指令或伪指令</h3><p>在任何进入M模式或HS模式的陷阱中，这些值会自动写入相应的陷阱指令CSR、mtinst或htinst中:</p>
<ul>
<li>零;</li>
<li>捕获指令的转换;</li>
<li>自定义值(仅当捕获指令是非标准指令时允许);</li>
<li>或一个特殊的伪指令。</li>
</ul>
<p>除非需要一个伪指令值(稍后会描述)，否则写入mtinst或htinst的值可能总是为零，这表明硬件没有在寄存器中为这个特定的陷阱提供任何信息。</p>
<blockquote>
<p>写入陷阱指令CSR的值有两个目的。首先是提高陷阱处理程序中指令仿真的速度，部分原因是允许处理程序跳过从内存加载陷阱指令，部分原因是避免了解码和执行指令的一些工作。第二个目的是通过伪指令提供额外的关于客户页面错误异常的信息，这些异常是由为VSstage地址转换进行的隐式内存访问引起的。</p>
<p>编写捕获指令的转换，而不是简单地复制原始指令，以便尽量减少硬件负担，同时仍然向陷阱处理程序提供模拟指令所需的信息。实现可以在任何时候通过用零代替转换后的指令来减少工作量。</p>
</blockquote>
<p>在中断时，写入陷阱指令寄存器的值总是零。在同步异常中，如果写入非零值，则该值的下列条件之一必须为真:</p>
<ul>
<li><p>比特0为1，将比特1替换为1，使该值成为标准指令的有效编码。<br>在这种情况下，被捕获的指令与寄存器值所指示的指令类型相同，寄存器值是捕获指令的转换，如后面定义的那样。例如，如果比特1:0为二进制11，寄存器值为标准LW(加载字)指令的编码，则捕获指令为LW，寄存器值为捕获LW指令的转换。</p>
</li>
<li><p>比特0为1，将比特1替换为1，使该值成为明确指定用于自定义指令的指令编码(而不是未使用的保留编码)。<br>这是一个自定义值。被捕获的指令是非标准指令。自定义值的解释在本标准中没有其他规定。</p>
</li>
<li><p>该值是后面定义的特殊伪指令之一，所有这些伪指令的bit1:0 &#x3D; 00。</p>
</li>
</ul>
<p>这三种情况排除了大量其他可能的值，例如所有那些位为1:0等于二进制10的值。未来的标准或扩展可能会定义额外的情况，从而允许当前排除的值。软件可以安全地将陷阱指令寄存器中无法识别的值视为零。</p>
<blockquote>
<p>为了向前兼容本标准的未来修订版，解释来自mtinst或htinst的非零值的软件必须完全验证该值符合上面列出的情况之一。例如，对于RV64，发现mtinst的6:0位是0000011，而14:12位是010，不足以确定第一种情况适用，并且捕获指令是标准的LW指令;相反，软件还必须确认mtinst的63:32位都是零。未来的标准可能会为64位mtinst定义新的值，这些值在63:32位中是非零的，但在31:0位中可能恰好具有与标准RV64指令相同的位模式。</p>
</blockquote>
<blockquote>
<p>与标准指令不同，不要求自定义值的指令编码与被捕获的指令具有相同的“类型”(甚至与捕获指令有任何相关性)。</p>
</blockquote>
<p>表8.11显示了针对每个标准异常原因可能自动写入trap指令寄存器的值。对于阻止获取指令的异常，只能写入零或伪指令值。只有当捕获指令是非标准指令时，才可以自动写入自定义值。将来的标准或扩展可能允许从先前建立的允许值集中选择其他值来写入。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620100733821-1730798006988-127.png" alt="image-20230620100733821"></p>
<p>如表中所列，同步异常可以将捕获指令的标准转换写入陷阱指令寄存器，仅用于显式内存访问(来自加载、存储和AMO指令)引起的异常。因此，目前仅为这些内存访问指令定义了标准转换。如果没有定义转换的标准指令发生同步陷阱，则陷阱指令寄存器应写入零(或者，在某些情况下，写入一个特殊的伪指令值)。</p>
<p>对于非压缩指令且为LB、LBU、LH、LHU、LW、LWU、LD、FLW、FLD、FLQ或FLH之一的标准加载指令，转换后的指令格式如图8.44所示。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620100753539-1730798006988-126.png" alt="image-20230620100753539"></p>
<p>对于一个不是压缩指令的标准存储指令，它是SB、SH、SW、SD、FSW、FSD、FSQ或FSH之一，转换后的指令格式如图8.45所示。</p>
<p>对于一个标准的原子指令(load-reserved、store-conditional或AMO指令)，转换后的指令格式如图8.46所示。</p>
<p>对于标准的虚拟机加载&#x2F;存储指令(HLV、HLVX或HSV)，转换后的指令格式如图8.47所示。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620100839882-1730798007010-130.png" alt="image-20230620100839882"></p>
<p>在上述所有转换后的指令中，Addr。偏移字段取代了19:15位指令的rs1字段，是故障虚拟地址(写入到mtval或stval)与原始虚拟地址之间的正差。只有在内存访问不对齐的情况下，这个差异才能是非零的。还要注意，对于基本加载和存储，转换将指令的直接偏移字段替换为零。</p>
<p>对于标准压缩指令(16位大小)，转换后的指令如下:</p>
<ol>
<li><p>将压缩指令展开为32位的等效指令。</p>
</li>
<li><p>转换32位等效指令。</p>
</li>
<li><p>将位1替换为0。</p>
</li>
</ol>
<p>如果捕获指令被压缩，转换后的标准指令的位1:0将是二进制01，如果没有压缩，则为11。</p>
<blockquote>
<p>在解码mtinst或htinst的内容时，一旦软件确定寄存器包含标准基本加载(LB、LBU、LH、LHU、LW、LWU、LD、FLW、FLD、FLQ或FLH)或基本存储(SB、SH、SW、SD、FSW、FSD、FSQ或FSH)的编码，就不需要再确认直接偏移字段(31:25、24:20或11:7)是否为零。知道寄存器的值是基本加载&#x2F;存储的编码就足以证明捕获指令是相同类型的</p>
<p>该标准的未来版本可能会向当前为零的字段添加信息。但是，为了向后兼容，任何此类信息将仅用于性能目的，可以安全地忽略。</p>
</blockquote>
<p>对于客户页面错误，如果:(a)错误是由VS阶段地址转换的隐式内存访问引起的，并且(b)将非零值(出错的guest physical addresses)写入mtval2或htval，则trap指令寄存器将使用一个特殊的伪指令值写入。如果两个条件都满足，则写入mtinst或htinst的值必须取自表8.12;零是不允许的。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620101004942-1730798006988-129.png" alt="image-20230620101004942"></p>
<p>定义的伪指令值被设计成与基本加载和存储的编码紧密对应，如表8.13所示。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230620101027513-1730798006988-128.png" alt="image-20230620101027513"></p>
<p>写伪指令(0x00002020或0x00003020)用于机器试图自动更新VS级页表中的A位和&#x2F;或D位的情况。所有其他用于VS阶段地址转换的隐式内存访问都将被读取。如果机器从未自动更新VS级页表中的a位或D位(将此留给软件)，则永远不会出现写情况。这种页表更新实际上必须是原子的，而不仅仅是简单的写操作，这一事实对于伪指令来说是忽略的。</p>
<blockquote>
<p>如果需要伪指令值的条件在M模式中可能出现，那么mtinst不能完全是只读零;HS-mode和hst也是如此。但是，在这种情况下，trap指令寄存器可能最低限度地只支持值0和0x00002000或0x00003000，也可能支持0x00002020或0x00003020，每个寄存器只需要硬件中的一个或两个触发器。</p>
<p>在这里，忽略页表更新的原子性需求并没有什么害处，因为在这些情况下，不希望hypervisor模拟失败的隐式内存访问。更确切地说，hypervisor获得了关于错误访问的足够信息，以便能够在通过重试错误指令恢复执行之前使内存可访问(例如，通过恢复丢失的虚拟内存页)。</p>
</blockquote>
<h3 id="8-6-4-Trap返回"><a href="#8-6-4-Trap返回" class="headerlink" title="8.6.4 Trap返回"></a>8.6.4 Trap返回</h3><p>MRET指令用于从进入M模式的陷阱返回。MRET首先根据mstatus或mstatush中的MPP和MPV值确定新的特权模式是什么，如表8.8所示。MRET则在mstatus&#x2F;mstatush中设置MPV&#x3D;0、MPP&#x3D;0、MIE&#x3D;MPIE、MPIE&#x3D;1。最后，MRET设置前面确定的特权模式，并设置pc&#x3D;mepc。</p>
<p>SRET指令用于从进入HS模式或VS模式的陷阱返回。它的行为取决于当前的虚拟化模式。</p>
<p>当以M模式或HS模式(即V&#x3D;0)执行时，SRET首先根据hstatus中的值确定新的特权模式是什么。SPV和地位。SPP，如表8.9中编码的。然后设置hstatus。SPV&#x3D;0，在sstatus中设置SPP&#x3D;0, SIE&#x3D;SPIE, SPIE&#x3D;1。最后，SRET设置前面确定的特权模式，并设置pc&#x3D;sepc。</p>
<p>当以VS模式(即V&#x3D;1)执行时，SRET根据表8.10设置特权模式，在vsstatus中设置SPP&#x3D;0, SIE&#x3D;SPIE, SPIE&#x3D;1，最后设置pc&#x3D;vsepc。</p>
<h1 id="9-RISC-V-特权指令集列表"><a href="#9-RISC-V-特权指令集列表" class="headerlink" title="9.  RISC-V 特权指令集列表"></a>9.  RISC-V 特权指令集列表</h1><p>本章介绍了 RISC-V特权架构中定义的所有指令的指令集列表。</p>
<p>本手册第一卷提供了非特权指令的指令集列表，包括 ECALL 和 EBREAK 指令。</p>
<p><img src="/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/image-20230725092356016-1730798007010-131.png" alt="image-20230725092356016"></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/RISC-V/" rel="tag"># RISC-V</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2023/11/06/RISC-V%E4%B8%AD%E6%96%AD/" rel="next" title="RISC-V中断">
                  RISC-V中断 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Wu JInlin</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"http://example.com/2023/11/06/RISC-V%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84/"}</script>
  <script src="/js/third-party/quicklink.js"></script>

</body>
</html>
